{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LibreTuya","text":"<p>PlatformIO development platform for IoT modules manufactured by Tuya Inc.</p> <p>The main goal of this project is to provide a usable build environment for IoT developers. While also providing vendor SDKs as PlatformIO cores, the project focuses on developing working Arduino-compatible cores for supported families. The cores are inspired by Espressif's official core for ESP32, which should make it easier to port/run existing ESP apps on Tuya IoT (and 3-rd party) modules.</p> <p>There's an ESPHome port based on LibreTuya, which supports BK7231 and RTL8710B chips.</p> <p>Note: this project is work-in-progress.</p>"},{"location":"#usage","title":"Usage","text":"<ol> <li>Install PlatformIO</li> <li><code>platformio platform install https://github.com/kuba2k2/libretuya</code></li> <li>Create a project, build it and upload!</li> <li>See the docs for any questions/problems.</li> </ol>"},{"location":"#arduino-core-support-status","title":"Arduino Core support status","text":"<p>Note: this list will probably change with each functionality update.</p>      <code>realtek-ambz</code> <code>beken-72xx</code>     Core functions \u2714\ufe0f \u2714\ufe0f   GPIO/PWM/IRQ \u2714\ufe0f/\u2714\ufe0f/\u2714\ufe0f \u2714\ufe0f/\u2714\ufe0f/\u2714\ufe0f   Analog input (ADC) \u2714\ufe0f \u2714\ufe0f   Serial \u2714\ufe0f \u2714\ufe0f   Serial (extra) 0, 1, 2 1, 2   Flash I/O \u2714\ufe0f \u2714\ufe0f   CORE LIBRARIES     SoftwareSerial \u2714\ufe0f \u274c   SPI \u274c \u274c   Wire \u2757 \u274c   OTHER LIBRARIES     Wi-Fi STA/AP/Mixed \u2714\ufe0f \u2714\ufe0f   Wi-Fi Events \u2714\ufe0f \u2714\ufe0f   TCP Client (SSL) \u2714\ufe0f (\u2714\ufe0f) \u2714\ufe0f (\u2757)   TCP Server \u2714\ufe0f \u2714\ufe0f   IPv6 \u274c \u274c   HTTP Client (SSL) \u2714\ufe0f (\u2714\ufe0f) \u2753   HTTP Server \u2714\ufe0f \u2714\ufe0f   NVS / Preferences \u274c \u274c   SPIFFS \u274c \u274c   BLE - \u274c   NTP \u274c \u274c   OTA \u2714\ufe0f \u2714\ufe0f   MDNS \u2714\ufe0f \u2714\ufe0f   MQTT \u2705 \u274c   SD \u274c \u274c    <p>Symbols:</p> <ul> <li>\u2714\ufe0f working</li> <li>\u2705 tested, external library</li> <li>\u2753 untested</li> <li>\u2757 broken</li> <li>\u274c not implemented (yet?)</li> <li>- not applicable</li> </ul> <p>Names:</p> <ul> <li>Core functions - stuff like delay(), millis(), yield(), etc.</li> <li>CORE LIBRARIES - included normally in all Arduino cores</li> <li>OTHER LIBRARIES - included in ESP32 core or downloadable</li> </ul>"},{"location":"#license","title":"License","text":"<p>See LICENSE. Project is licensed under MIT License.</p> <p>Parts of the code may come from third parties, vendor SDKs or other open-source projects. Most of these files are marked with appropriate copyright/author/license notices.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>\ud83d\ude0a Getting started<ul> <li>ESPHome</li> </ul> </li> <li>\ud83d\udcf2 Flashing/dumping</li> <li>\ud83d\udcbb Supported boards &amp; chips</li> <li>\ud83d\udcd6 Reference<ul> <li>Chip families<ul> <li>Beken BK72xx</li> <li>Realtek Ameba - info</li> <li>Realtek AmebaZ<ul> <li>Debugging</li> <li>Exception decoder</li> <li>C library<ul> <li>Built-in functions</li> <li>Memory management</li> </ul> </li> </ul> </li> </ul> </li> <li>\ud83d\udd27 LT configuration</li> <li>\u2714\ufe0f Implementation status</li> <li>\ud83d\udd0c Boards documentation</li> <li>\ud83d\udd0b Examples</li> <li>\ud83d\udcd6 LibreTuya API<ul> <li>LT class reference</li> <li>Common methods</li> <li>Wiring custom methods</li> <li>Logger</li> <li>Chip &amp; family IDs</li> <li>POSIX utilities</li> </ul> </li> <li>\ud83d\udcd6 Common API<ul> <li>FS</li> <li>Preferences</li> <li>SoftwareSerial</li> <li>WiFi API<ul> <li>TCP Client</li> <li>SSL Client</li> <li>TCP Server</li> </ul> </li> </ul> </li> <li>\ud83d\udcd6 LibreTuya libraries<ul> <li>base64</li> <li>Flash</li> <li>HTTPClient</li> <li>mDNS</li> <li>NetUtils<ul> <li>ssl/MbedTLSClient</li> <li>IPv6Address</li> <li>LwIPRxBuffer</li> </ul> </li> <li>Update</li> <li>WebServer</li> <li>WiFiMulti</li> </ul> </li> <li>Third party libraries</li> <li>Full documentation<ul> <li>Classes</li> <li>Functions</li> <li>Macros</li> <li>File list</li> </ul> </li> <li>\ud83d\udcc1 Project structure</li> <li>\u2708\ufe0f OTA format<ul> <li>uf2ota.py tool</li> <li>uf2ota.h library</li> </ul> </li> <li>\ud83d\udcd3 TODO</li> </ul> </li> <li>\ud83d\udd17 Resources</li> </ul>"},{"location":"TODO/","title":"TODO list","text":""},{"location":"TODO/#general","title":"General","text":""},{"location":"TODO/#environment-stability","title":"Environment stability","text":"<p>Do not publish any SDK functions, macros, defines and includes. Define only what's needed in LT's public headers (like <code>Arduino.h</code>). Everything else is taken from <code>sdk_extern.h</code> or <code>WVariant.h</code> (TODO decide whether to keep WV public / make both private / get rid of WV and use sdk_extern only). Private headers are included by LT's .cpp units (maybe a dedicated private header that would include sdk_extern + Arduino.h).</p> <p>Developers wanting to use SDK functions need to include them.</p> <p>Explicit is better than implicit.</p> <ul> <li>consider moving to C++17 (GNU)? or any newer than C++11</li> </ul>"},{"location":"TODO/#new-families","title":"New families","text":"<ul> <li>BL602</li> <li>RTL8710A</li> <li>RTL8720C</li> <li>RTL8720D</li> <li>W600 and/or W800</li> <li>LN8825</li> <li>BK7231Q</li> <li>host-native family</li> </ul>"},{"location":"TODO/#tools","title":"Tools","text":"<ul> <li>write OpenOCD flashers, using uf2ota library + FAL for partitions (in ltchiptool repository)</li> </ul>"},{"location":"TODO/#serial","title":"Serial","text":"<ul> <li>configuration of RX/TX pins</li> <li>SoftwareSerial library - receiving + Beken family</li> </ul>"},{"location":"TODO/#other","title":"Other","text":"<ul> <li>watchdog API</li> <li><code>Preferences</code> library</li> <li>test/fix IPv6 on different families</li> <li>what is <code>PowerManagement</code> at all? probably useless -&gt; remove</li> </ul>"},{"location":"TODO/#bk7231","title":"BK7231","text":"<ul> <li>fix WiFi on BK7231N, test other functionality</li> <li>fix SSL (mbedTLS)</li> <li>I2C (Wire)</li> <li>SPI</li> <li>BLE</li> </ul>"},{"location":"TODO/#rtl8710b","title":"RTL8710B","text":"<ul> <li>take all stdio functions from stdio.h</li> <li>rewrite most of Wiring (it was copied from <code>ambd_arduino</code>, and is ugly)</li> </ul>"},{"location":"boards/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Generic - BK7231N (Tuya QFN32)</li> <li>Generic - BK7231T (Tuya QFN32)</li> <li>Generic - BK7252</li> <li>Generic - RTL8710BN (2M/468k)</li> <li>Generic - RTL8710BN (2M/788k)</li> <li>Generic - RTL8710BX (4M/980k)</li> <li>Generic - RTL8720CF (2M/992k)</li> <li>BW12</li> <li>BW15</li> <li>CB2L</li> <li>CB2S</li> <li>CB3L</li> <li>CB3S</li> <li>CB3SE</li> <li>WB2L</li> <li>WB2S</li> <li>WB3L</li> <li>WB3S</li> <li>WR2</li> <li>WR2E</li> <li>WR3</li> <li>WR3E</li> <li>WR3N</li> <li>WR2L</li> <li>WR2LE</li> <li>WR3L</li> <li>WR3LE</li> <li>LSC LMA35</li> <li>LSC LMA35 T</li> <li>Generic - Host-native</li> </ul>"},{"location":"boards/bw12/","title":"BW12","text":"<p>by Ai-Thinker Co., Ltd.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> <li>Vendor datasheet</li> </ul>    Parameter Value     Board code <code>bw12</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ARI3-BW1X"},{"location":"boards/bw12/#usage","title":"Usage","text":"<p>Board code: <code>bw12</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:bw12]\nplatform = libretuya\nboard = bw12\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: bw12\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/bw12/#pinout","title":"Pinout","text":""},{"location":"boards/bw12/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA05    PWM4    D1 PA29 UART2_RX I2C0_SCL  PWM4    D2 PA00    PWM2    D3 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D4 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D5 PA30 UART2_TX I2C0_SDA  PWM4    D6 PA14    PWM0 SWCLK   D7 PA12    PWM3    D8 PA15    PWM1 SWDIO   D9 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D10 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    A0 PA19, ADC1"},{"location":"boards/bw12/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 468 KiB / 0x75000 0x080000   OTA2 Image 0x080000 468 KiB / 0x75000 0x0F5000   Key-Value Store 0x0F5000 24 KiB / 0x6000 0x0FB000   User Data 0x0FB000 1 MiB / 0x104000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/bw15/","title":"BW15","text":"<p>by Ai-Thinker Co., Ltd.</p> <p>Product page</p> <ul> <li>General info</li> <li>Vendor datasheet</li> </ul>    Parameter Value     Board code <code>bw15</code>   MCU RTL8720CF   Manufacturer Realtek   Series AmebaZ2   Frequency 100 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 8x PWM, 3x UART   Wi-Fi 802.11 b/g/n   BLE v4.2   FCC ID 2AXVG-BW15"},{"location":"boards/bw15/#usage","title":"Usage","text":"<p>Board code: <code>bw15</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:bw15]\nplatform = libretuya\nboard = bw15\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: bw15\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/bw15/#pinout","title":"Pinout","text":""},{"location":"boards/bw15/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Partition Table 0x000000 4 KiB / 0x1000 0x001000   System Data 0x001000 4 KiB / 0x1000 0x002000   Calibration 0x002000 4 KiB / 0x1000 0x003000   (reserved) 0x003000 4 KiB / 0x1000 0x004000   Boot Image 0x004000 32 KiB / 0x8000 0x00C000   OTA1 Image 0x00C000 992 KiB / 0xF8000 0x104000   OTA2 Image 0x104000 992 KiB / 0xF8000 0x1FC000   Key-Value Store 0x1FC000 8 KiB / 0x2000 0x1FE000   User Data 0x1FE000 8 KiB / 0x2000 0x200000"},{"location":"boards/cb2l/","title":"CB2L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>cb2l</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 5x PWM, 2x UART   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB2L"},{"location":"boards/cb2l/#usage","title":"Usage","text":"<p>Board code: <code>cb2l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb2l]\nplatform = libretuya\nboard = cb2l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: cb2l\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/cb2l/#pinout","title":"Pinout","text":""},{"location":"boards/cb2l/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P8    PWM2    D1 P7    PWM1    D2 P6    PWM0    D3 P26    PWM5    D4 P24    PWM4    D5 P10 UART1_RX       D6 P0 UART2_TX I2C2_SCL      D7 P11 UART1_TX       D8 P21  I2C1_SDA   TMS"},{"location":"boards/cb2l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb2s/","title":"CB2S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>cb2s</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB2S"},{"location":"boards/cb2s/#usage","title":"Usage","text":"<p>Board code: <code>cb2s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb2s]\nplatform = libretuya\nboard = cb2s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: cb2s\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/cb2s/#pinout","title":"Pinout","text":""},{"location":"boards/cb2s/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P6    PWM0    D1 P7    PWM1    D2 P8    PWM2    D3 P23     TDO   D4 P10 UART1_RX       D5 P11 UART1_TX       D6 P24    PWM4    D7 P26    PWM5    D8 P0 UART2_TX I2C2_SCL      D9 P1 UART2_RX I2C2_SDA      D10 P21  I2C1_SDA   TMS   A0 P23, ADC3"},{"location":"boards/cb2s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb3l/","title":"CB3L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>cb3l</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 12x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB3L"},{"location":"boards/cb3l/#usage","title":"Usage","text":"<p>Board code: <code>cb3l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb3l]\nplatform = libretuya\nboard = cb3l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: cb3l\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/cb3l/#pinout","title":"Pinout","text":""},{"location":"boards/cb3l/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P23     TDO   D1 P14   SCK     D2 P26    PWM5    D3 P24    PWM4    D4 P6    PWM0    D5 P9    PWM3    D6 P0 UART2_TX I2C2_SCL      D7 P21  I2C1_SDA   TMS   D8 P8    PWM2    D9 P7    PWM1    D10 P10 UART1_RX       D11 P11 UART1_TX       A0 P23, ADC3"},{"location":"boards/cb3l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb3s/","title":"CB3S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>cb3s</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 14x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB3S"},{"location":"boards/cb3s/#usage","title":"Usage","text":"<p>Board code: <code>cb3s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb3s]\nplatform = libretuya\nboard = cb3s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: cb3s\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/cb3s/#pinout","title":"Pinout","text":""},{"location":"boards/cb3s/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P23     TDO   D1 P14   SCK     D2 P26    PWM5    D3 P24    PWM4    D4 P6    PWM0    D5 P9    PWM3    D6 P0 UART2_TX I2C2_SCL      D7 P21  I2C1_SDA   TMS   D8 P8    PWM2    D9 P7    PWM1    D10 P10 UART1_RX       D11 P11 UART1_TX       D12 P22     TDI   D13 P20  I2C1_SCL   TCK   A0 P23, ADC3"},{"location":"boards/cb3s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/cb3se/","title":"CB3SE Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>cb3se</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1   FCC ID 2ANDL-CB3SE"},{"location":"boards/cb3se/#usage","title":"Usage","text":"<p>Board code: <code>cb3se</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:cb3se]\nplatform = libretuya\nboard = cb3se\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: cb3se\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/cb3se/#pinout","title":"Pinout","text":""},{"location":"boards/cb3se/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P23     TDO   D1 P14   SCK     D2 P26    PWM5    D3 P24    PWM4    D4 P6    PWM0    D5 P9    PWM3    D6 P0 UART2_TX I2C2_SCL      D7 P1 UART2_RX I2C2_SDA      D8 P8    PWM2    D9 P7    PWM1    D10 P10 UART1_RX       D11 P11 UART1_TX       D12 P15   CS     D13 P22     TDI   D14 P20  I2C1_SCL   TCK   D15 P17   MISO     D16 P16   MOSI     A0 P23, ADC3"},{"location":"boards/cb3se/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-bk7231n-qfn32-tuya/","title":"Generic - BK7231N (Tuya QFN32)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>generic-bk7231n-qfn32-tuya</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 19x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/generic-bk7231n-qfn32-tuya/#usage","title":"Usage","text":"<p>Board code: <code>generic-bk7231n-qfn32-tuya</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-bk7231n-qfn32-tuya]\nplatform = libretuya\nboard = generic-bk7231n-qfn32-tuya\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-bk7231n-qfn32-tuya\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-bk7231n-qfn32-tuya/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P0 UART2_TX I2C2_SCL      D1 P1 UART2_RX I2C2_SDA      D2 P6    PWM0    D3 P7    PWM1    D4 P8    PWM2    D5 P9    PWM3    D6 P10 UART1_RX       D7 P11 UART1_TX       D8 P14   SCK     D9 P15   CS     D10 P16   MOSI     D11 P17   MISO     D12 P20  I2C1_SCL   TCK   D13 P21  I2C1_SDA   TMS   D14 P22     TDI   D15 P23     TDO   D16 P24    PWM4    D17 P26    PWM5    D18 P28        A0 P23, ADC3"},{"location":"boards/generic-bk7231n-qfn32-tuya/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-bk7231t-qfn32-tuya/","title":"Generic - BK7231T (Tuya QFN32)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>generic-bk7231t-qfn32-tuya</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 19x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2"},{"location":"boards/generic-bk7231t-qfn32-tuya/#usage","title":"Usage","text":"<p>Board code: <code>generic-bk7231t-qfn32-tuya</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-bk7231t-qfn32-tuya]\nplatform = libretuya\nboard = generic-bk7231t-qfn32-tuya\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-bk7231t-qfn32-tuya\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-bk7231t-qfn32-tuya/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P0 UART2_TX I2C2_SCL      D1 P1 UART2_RX I2C2_SDA      D2 P6    PWM0    D3 P7    PWM1    D4 P8    PWM2    D5 P9    PWM3    D6 P10 UART1_RX       D7 P11 UART1_TX       D8 P14   SCK     D9 P15   CS     D10 P16   MOSI     D11 P17   MISO     D12 P20  I2C1_SCL   TCK   D13 P21  I2C1_SDA   TMS   D14 P22     TDI   D15 P23     TDO   D16 P24    PWM4    D17 P26    PWM5    D18 P28        A0 P23, ADC3"},{"location":"boards/generic-bk7231t-qfn32-tuya/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-bk7252/","title":"Generic - BK7252","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>generic-bk7252</code>   MCU BK7252   Manufacturer Beken   Series BK72XX   Frequency 180 MHz   Flash size 4 MiB   RAM size 512 KiB   Voltage 3.0V - 3.6V   I/O 38x GPIO, 4x PWM, 2x UART, 7x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.0"},{"location":"boards/generic-bk7252/#usage","title":"Usage","text":"<p>Board code: <code>generic-bk7252</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-bk7252]\nplatform = libretuya\nboard = generic-bk7252\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-bk7252\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-bk7252/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P0 UART2_TX I2C2_SCL      D1 P1 UART2_RX I2C2_SDA      D2 P2        D3 P3        D4 P4        D5 P5        D6 P6    PWM0    D7 P7    PWM1    D8 P10 UART1_RX       D9 P11 UART1_TX       D10 P12 UART1_CTS       D11 P13 UART1_RTS       D12 P14   SCK     D13 P15   CS     D14 P16   MOSI     D15 P17   MISO     D16 P18        D17 P19        D18 P20  I2C1_SCL   TCK   D19 P21  I2C1_SDA   TMS   D20 P22     TDI   D21 P23     TDO   D22 P24    PWM4    D23 P25        D24 P26    PWM5    D25 P27     DVP_MCLK   D26 P28        D27 P29     DVP_PCLK   D28 P30     DVP_HSYNC   D29 P31     DVP_VSYNC   D30 P32     DVP_PD0   D31 P33     DVP_PD1   D32 P34     DVP_PD2   D33 P35     DVP_PD3   D34 P36     DVP_PD4   D35 P37     DVP_PD5   D36 P38     DVP_PD6   D37 P39     DVP_PD7   A1 P4, ADC1        A2 P5, ADC2        A3 P23, ADC3        A4 P3, ADC5        A5 P2, ADC4        A6 P12, ADC6        A7 P13, ADC7"},{"location":"boards/generic-bk7252/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 4 MiB / 4,194,304 B / 0x400000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.7 MiB / 0x1BA000 0x1CB000   File System 0x1CB000 1.1 MiB / 0x119000 0x2E4000   Key-Value Store 0x2E4000 32 KiB / 0x8000 0x2EC000   OTA Image 0x2EC000 1.1 MiB / 0x112000 0x3FE000   Calibration 0x3FE000 4 KiB / 0x1000 0x3FF000   TLV Store 0x3FF000 4 KiB / 0x1000 0x400000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/generic-native/","title":"Generic - Host-native","text":"<p>by N/A</p> <p>Product page</p>    Parameter Value     Board code <code>generic-native</code>   MCU NATIVE   Manufacturer N/A   Series N/A   Frequency 1 GHz   Flash size 4 MiB   RAM size 4 MiB   Voltage 5V"},{"location":"boards/generic-native/#usage","title":"Usage","text":"<p>Board code: <code>generic-native</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-native]\nplatform = libretuya\nboard = generic-native\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-native\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-native/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 4 MiB / 4,194,304 B / 0x400000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 64 KiB / 0x10000 0x010000   System Data 0x010000 64 KiB / 0x10000 0x020000   OTA1 Image 0x020000 1 MiB / 0x100000 0x120000   OTA2 Image 0x120000 1 MiB / 0x100000 0x220000   OTA Image 0x220000 1 MiB / 0x100000 0x320000   Key-Value Store 0x320000 256 KiB / 0x40000 0x360000   User Data 0x360000 640 KiB / 0xA0000 0x400000"},{"location":"boards/generic-native/#description","title":"Description","text":"<p><code>generic-native</code> is a dummy board using the <code>host-native</code> family, which also serves as a template for building new families, as well as for testing flash-related modules (i.e. Fat FS, OTA, etc).</p>"},{"location":"boards/generic-rtl8710bn-2mb-468k/","title":"Generic - RTL8710BN (2M/468k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-rtl8710bn-2mb-468k</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/generic-rtl8710bn-2mb-468k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8710bn-2mb-468k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8710bn-2mb-468k]\nplatform = libretuya\nboard = generic-rtl8710bn-2mb-468k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-rtl8710bn-2mb-468k\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-rtl8710bn-2mb-468k/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA00    PWM2    D1 PA05    PWM4    D2 PA06   FCS     D3 PA07   FD1     D4 PA08   FD2     D5 PA09   FD0     D6 PA10   FSCK     D7 PA11   FD3     D8 PA12    PWM3    D9 PA14    PWM0 SWCLK   D10 PA15    PWM1 SWDIO   D11 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D12 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D13 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D14 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    D15 PA29 UART2_RX I2C0_SCL  PWM4    D16 PA30 UART2_TX I2C0_SDA  PWM4    A0 PA19, ADC1        A1 ADC2"},{"location":"boards/generic-rtl8710bn-2mb-468k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 468 KiB / 0x75000 0x080000   OTA2 Image 0x080000 468 KiB / 0x75000 0x0F5000   Key-Value Store 0x0F5000 24 KiB / 0x6000 0x0FB000   User Data 0x0FB000 1 MiB / 0x104000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/generic-rtl8710bn-2mb-788k/","title":"Generic - RTL8710BN (2M/788k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-rtl8710bn-2mb-788k</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/generic-rtl8710bn-2mb-788k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8710bn-2mb-788k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8710bn-2mb-788k]\nplatform = libretuya\nboard = generic-rtl8710bn-2mb-788k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-rtl8710bn-2mb-788k\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-rtl8710bn-2mb-788k/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA00    PWM2    D1 PA05    PWM4    D2 PA06   FCS     D3 PA07   FD1     D4 PA08   FD2     D5 PA09   FD0     D6 PA10   FSCK     D7 PA11   FD3     D8 PA12    PWM3    D9 PA14    PWM0 SWCLK   D10 PA15    PWM1 SWDIO   D11 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D12 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D13 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D14 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    D15 PA29 UART2_RX I2C0_SCL  PWM4    D16 PA30 UART2_TX I2C0_SDA  PWM4    A0 PA19, ADC1        A1 ADC2"},{"location":"boards/generic-rtl8710bn-2mb-788k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/generic-rtl8710bx-4mb-980k/","title":"Generic - RTL8710BX (4M/980k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>generic-rtl8710bx-4mb-980k</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 4 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 17x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n"},{"location":"boards/generic-rtl8710bx-4mb-980k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8710bx-4mb-980k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8710bx-4mb-980k]\nplatform = libretuya\nboard = generic-rtl8710bx-4mb-980k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-rtl8710bx-4mb-980k\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-rtl8710bx-4mb-980k/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA00    PWM2    D1 PA05    PWM4    D2 PA06   FCS     D3 PA07   FD1     D4 PA08   FD2     D5 PA09   FD0     D6 PA10   FSCK     D7 PA11   FD3     D8 PA12    PWM3    D9 PA14    PWM0 SWCLK   D10 PA15    PWM1 SWDIO   D11 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D12 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D13 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D14 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    D15 PA29 UART2_RX I2C0_SCL  PWM4    D16 PA30 UART2_TX I2C0_SDA  PWM4    A0 PA19, ADC1"},{"location":"boards/generic-rtl8710bx-4mb-980k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 4 MiB / 4,194,304 B / 0x400000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 980 KiB / 0xF5000 0x100000   OTA2 Image 0x100000 980 KiB / 0xF5000 0x1F5000   Key-Value Store 0x1F5000 32 KiB / 0x8000 0x1FD000   User Data 0x1FD000 2 MiB / 0x202000 0x3FF000   RDP 0x3FF000 4 KiB / 0x1000 0x400000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/generic-rtl8710bx-4mb-980k/#information","title":"Information","text":"<p>This is a generic board definition for RTL8710BX with 4 MiB of flash. It has a bigger application partition size (980 KiB). The used bootloader is also different from the standard Tuya one.</p> <p>It can be found in Ezviz T31 smart plug - bare chip soldered onto the manufacturer-made PCB. The plug is not Tuya/SmartLife-compatible and has a 25Q32CSIG flash chip. Refer to libretuya#23 for photos and more information.</p> <p>Note that stock firmware seems to use smaller app images (0x80000 / 512 KiB). After 0x180000 some product-test data and device logs can be found. Because the OTA2 offset is 0x100000, the board definition was configured to use all available space.</p>"},{"location":"boards/generic-rtl8720cf-2mb-992k/","title":"Generic - RTL8720CF (2M/992k)","text":"<p>by Generic</p> <p>Product page</p> <ul> <li>General info</li> </ul>    Parameter Value     Board code <code>generic-rtl8720cf-2mb-992k</code>   MCU RTL8720CF   Manufacturer Realtek   Series AmebaZ2   Frequency 100 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 20x GPIO, 8x PWM, 3x UART   Wi-Fi 802.11 b/g/n   BLE v4.2"},{"location":"boards/generic-rtl8720cf-2mb-992k/#usage","title":"Usage","text":"<p>Board code: <code>generic-rtl8720cf-2mb-992k</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:generic-rtl8720cf-2mb-992k]\nplatform = libretuya\nboard = generic-rtl8720cf-2mb-992k\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: generic-rtl8720cf-2mb-992k\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/generic-rtl8720cf-2mb-992k/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Partition Table 0x000000 4 KiB / 0x1000 0x001000   System Data 0x001000 4 KiB / 0x1000 0x002000   Calibration 0x002000 4 KiB / 0x1000 0x003000   (reserved) 0x003000 4 KiB / 0x1000 0x004000   Boot Image 0x004000 32 KiB / 0x8000 0x00C000   OTA1 Image 0x00C000 992 KiB / 0xF8000 0x104000   OTA2 Image 0x104000 992 KiB / 0xF8000 0x1FC000   Key-Value Store 0x1FC000 8 KiB / 0x2000 0x1FE000   User Data 0x1FE000 8 KiB / 0x2000 0x200000"},{"location":"boards/lsc-lma35/","title":"LSC LMA35","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>lsc-lma35</code>   MCU BK7231N   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 15x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v5.1"},{"location":"boards/lsc-lma35/#usage","title":"Usage","text":"<p>Board code: <code>lsc-lma35</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:lsc-lma35]\nplatform = libretuya\nboard = lsc-lma35\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: lsc-lma35\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/lsc-lma35/#pinout","title":"Pinout","text":""},{"location":"boards/lsc-lma35/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P26    PWM5    D1 P14   SCK     D2 P16   MOSI     D3 P24    PWM4    D4 P22     TDI   D5 P0 UART2_TX I2C2_SCL      D6 P23     TDO   D7 P8    PWM2    D8 P9    PWM3    D9 P21  I2C1_SDA   TMS   D10 P6    PWM0    D11 P7    PWM1    D12 P10 UART1_RX       D13 P11 UART1_TX       D14 P1 UART2_RX I2C2_SDA      A0 P23, ADC3"},{"location":"boards/lsc-lma35/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x119000 0x12A000   OTA Image 0x12A000 664 KiB / 0xA6000 0x1D0000   Calibration 0x1D0000 4 KiB / 0x1000 0x1D1000   Network Data 0x1D1000 4 KiB / 0x1000 0x1D2000   TLV Store 0x1D2000 4 KiB / 0x1000 0x1D3000   Key-Value Store 0x1D3000 32 KiB / 0x8000 0x1DB000   User Data 0x1DB000 148 KiB / 0x25000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/lsc-lma35/#information","title":"Information","text":"<p>This board has no marking on the front side, only something that looks like PCB manufacturing info on the back; thus it was named based on these symbols.</p> <p>It can be found in 'LSC Smart Connect Outdoor LED Strip', and is likely custom-made for this product.</p> <p>The pinout was established by writing to and probing consecutive GPIOs, using the generic board definition.</p> <p>Pins marked with '?' are currently unknown, with a possibility of being CEN. Pin 22 (P1/D14) is also not confirmed.</p>"},{"location":"boards/lsc-lma35-t/","title":"LSC LMA35 BK7231T","text":"<p>by Unknown</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>lsc-lma35-t</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 15x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2"},{"location":"boards/lsc-lma35-t/#usage","title":"Usage","text":"<p>Board code: <code>lsc-lma35-t</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:lsc-lma35-t]\nplatform = libretuya\nboard = lsc-lma35-t\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: lsc-lma35-t\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/lsc-lma35-t/#pinout","title":"Pinout","text":""},{"location":"boards/lsc-lma35-t/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P26    PWM5    D1 P14   SCK     D2 P16   MOSI     D3 P24    PWM4    D4 P22     TDI   D5 P0 UART2_TX I2C2_SCL      D6 P23     TDO   D7 P8    PWM2    D8 P9    PWM3    D9 P21  I2C1_SDA   TMS   D10 P6    PWM0    D11 P7    PWM1    D12 P10 UART1_RX       D13 P11 UART1_TX       D14 P1 UART2_RX I2C2_SDA      A0 P23, ADC3"},{"location":"boards/lsc-lma35-t/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/lsc-lma35-t/#information","title":"Information","text":"<p>This board has no marking on the front side, only something that looks like PCB manufacturing info on the back; thus it was named based on these symbols.</p> <p>It can be found in 'LSC Smart Connect Outdoor LED Strip', and is likely custom-made for this product.</p> <p>The pinout was established by writing to and probing consecutive GPIOs, using the generic board definition.</p> <p>Pins marked with '?' are currently unknown, with a possibility of being CEN. Pin 22 (P1/D14) is also not confirmed.</p>"},{"location":"boards/wb2l/","title":"WB2L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>wb2l</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 13x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB2L"},{"location":"boards/wb2l/#usage","title":"Usage","text":"<p>Board code: <code>wb2l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb2l]\nplatform = libretuya\nboard = wb2l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wb2l\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wb2l/#pinout","title":"Pinout","text":""},{"location":"boards/wb2l/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P8    PWM2    D1 P7    PWM1    D2 P6    PWM0    D3 P26    PWM5    D4 P24    PWM4    D5 P10 UART1_RX       D6 P11 UART1_TX       D7 P1 UART2_RX I2C2_SDA      D8 P0 UART2_TX I2C2_SCL      D9 P20  I2C1_SCL   TCK   D10 P21  I2C1_SDA   TMS   D11 P23     TDO   D12 P22     TDI   A0 P23, ADC3"},{"location":"boards/wb2l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb2s/","title":"WB2S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>wb2s</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 14x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB2S"},{"location":"boards/wb2s/#usage","title":"Usage","text":"<p>Board code: <code>wb2s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb2s]\nplatform = libretuya\nboard = wb2s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wb2s\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wb2s/#pinout","title":"Pinout","text":""},{"location":"boards/wb2s/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P8    PWM2    D1 P7    PWM1    D2 P6    PWM0    D3 P23     TDO   D4 P10 UART1_RX       D5 P11 UART1_TX       D6 P24    PWM4    D7 P26    PWM5    D8 P20  I2C1_SCL   TCK   D9 P9    PWM3    D10 P1 UART2_RX I2C2_SDA      D11 P0 UART2_TX I2C2_SCL      D12 P21  I2C1_SDA   TMS   D13 P22     TDI   A0 P23, ADC3"},{"location":"boards/wb2s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb3l/","title":"WB3L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>wb3l</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 16x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB3L"},{"location":"boards/wb3l/#usage","title":"Usage","text":"<p>Board code: <code>wb3l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb3l]\nplatform = libretuya\nboard = wb3l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wb3l\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wb3l/#pinout","title":"Pinout","text":""},{"location":"boards/wb3l/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P23     TDO   D1 P14   SCK     D2 P26    PWM5    D3 P24    PWM4    D4 P6    PWM0    D5 P9    PWM3    D6 P0 UART2_TX I2C2_SCL      D7 P16   MOSI     D8 P8    PWM2    D9 P7    PWM1    D10 P10 UART1_RX       D11 P11 UART1_TX       D12 P22     TDI   D13 P21  I2C1_SDA   TMS   D14 P20  I2C1_SCL   TCK   D15 P1 UART2_RX I2C2_SDA      A0 P23, ADC3"},{"location":"boards/wb3l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wb3s/","title":"WB3S Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> </ul>    Parameter Value     Board code <code>wb3s</code>   MCU BK7231T   Manufacturer Beken   Series BK72XX   Frequency 120 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 15x GPIO, 6x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   Bluetooth BLE v4.2   FCC ID 2ANDL-WB3S"},{"location":"boards/wb3s/#usage","title":"Usage","text":"<p>Board code: <code>wb3s</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wb3s]\nplatform = libretuya\nboard = wb3s\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wb3s\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wb3s/#pinout","title":"Pinout","text":""},{"location":"boards/wb3s/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 P23     TDO   D1 P14   SCK     D2 P26    PWM5    D3 P24    PWM4    D4 P6    PWM0    D5 P7    PWM1    D6 P0 UART2_TX I2C2_SCL      D7 P1 UART2_RX I2C2_SDA      D8 P9    PWM3    D9 P8    PWM2    D10 P10 UART1_RX       D11 P11 UART1_TX       D12 P22     TDI   D13 P21  I2C1_SDA   TMS   D14 P20  I2C1_SCL   TCK   A0 P23, ADC3"},{"location":"boards/wb3s/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Bootloader 0x000000 68 KiB / 0x11000 0x011000   App Image 0x011000 1.1 MiB / 0x121000 0x132000   OTA Image 0x132000 664 KiB / 0xA6000 0x1D8000   Key-Value Store 0x1D8000 32 KiB / 0x8000 0x1E0000   Calibration 0x1E0000 4 KiB / 0x1000 0x1E1000   TLV Store 0x1E1000 4 KiB / 0x1000 0x1E2000   Network Data 0x1E2000 4 KiB / 0x1000 0x1E3000   User Data 0x1E3000 116 KiB / 0x1D000 0x200000    <p>Bootloader and app partitions contain CRC16 sums every 32 bytes. That results in the actual flash offsets/sizes not aligned to sector boundaries. To simplify calculations, the values shown in the table (extracted from bootloader's partition table) were aligned to 4096 bytes.</p>"},{"location":"boards/wr2/","title":"WR2 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 7x GPIO, 5x PWM, 1x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR2"},{"location":"boards/wr2/#usage","title":"Usage","text":"<p>Board code: <code>wr2</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2]\nplatform = libretuya\nboard = wr2\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr2\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr2/#pinout","title":"Pinout","text":""},{"location":"boards/wr2/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA12    PWM3    D1 PA00    PWM2    D2 PA05    PWM4    D4 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D5 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    D6 PA14    PWM0 SWCLK   D7 PA15    PWM1 SWDIO   A1 ADC2"},{"location":"boards/wr2/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr2e/","title":"WR2E Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2e</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 7x GPIO, 4x PWM, 1x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR2E"},{"location":"boards/wr2e/#usage","title":"Usage","text":"<p>Board code: <code>wr2e</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2e]\nplatform = libretuya\nboard = wr2e\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr2e\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr2e/#pinout","title":"Pinout","text":""},{"location":"boards/wr2e/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA12    PWM3    D1 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D2 PA05    PWM4    D3 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D4 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    D5 PA14    PWM0 SWCLK   D6 PA15    PWM1 SWDIO   A0 PA19, ADC1        A1 ADC2"},{"location":"boards/wr2e/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr2l/","title":"WR2L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2l</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 5x GPIO, 4x PWM, 1x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR2L"},{"location":"boards/wr2l/#usage","title":"Usage","text":"<p>Board code: <code>wr2l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2l]\nplatform = libretuya\nboard = wr2l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr2l\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr2l/#pinout","title":"Pinout","text":""},{"location":"boards/wr2l/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA15    PWM1 SWDIO   D1 PA14    PWM0 SWCLK   D2 PA05    PWM4    D3 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D4 PA12    PWM3    A0 PA19, ADC1"},{"location":"boards/wr2l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr2le/","title":"WR2LE Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr2le</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 5x GPIO, 5x PWM, 1x UART   Wi-Fi 802.11 b/g/n"},{"location":"boards/wr2le/#usage","title":"Usage","text":"<p>Board code: <code>wr2le</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr2le]\nplatform = libretuya\nboard = wr2le\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr2le\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr2le/#pinout","title":"Pinout","text":""},{"location":"boards/wr2le/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA15    PWM1 SWDIO   D1 PA14    PWM0 SWCLK   D2 PA05    PWM4    D3 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D4 PA12    PWM3"},{"location":"boards/wr2le/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr3/","title":"WR3 Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3"},{"location":"boards/wr3/#usage","title":"Usage","text":"<p>Board code: <code>wr3</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3]\nplatform = libretuya\nboard = wr3\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr3\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr3/#pinout","title":"Pinout","text":""},{"location":"boards/wr3/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D1 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D2 PA14    PWM0 SWCLK   D3 PA15    PWM1 SWDIO   D4 PA00    PWM2    D5 PA29 UART2_RX I2C0_SCL  PWM4    D6 PA30 UART2_TX I2C0_SDA  PWM4    D7 PA05    PWM4    D8 PA12    PWM3    D9 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D10 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    A0 PA19, ADC1        A1 ADC2"},{"location":"boards/wr3/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr3e/","title":"WR3E Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3e</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3E"},{"location":"boards/wr3e/#usage","title":"Usage","text":"<p>Board code: <code>wr3e</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3e]\nplatform = libretuya\nboard = wr3e\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr3e\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr3e/#pinout","title":"Pinout","text":""},{"location":"boards/wr3e/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA29 UART2_RX I2C0_SCL  PWM4    D1 PA14    PWM0 SWCLK   D2 PA15    PWM1 SWDIO   D3 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D4 PA00    PWM2    D5 PA30 UART2_TX I2C0_SDA  PWM4    D6 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D7 PA05    PWM4    D8 PA12    PWM3    D9 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D10 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    A0 PA19, ADC1        A1 ADC2"},{"location":"boards/wr3e/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr3l/","title":"WR3L Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3l</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3L"},{"location":"boards/wr3l/#usage","title":"Usage","text":"<p>Board code: <code>wr3l</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3l]\nplatform = libretuya\nboard = wr3l\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr3l\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr3l/#pinout","title":"Pinout","text":""},{"location":"boards/wr3l/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D1 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D2 PA14    PWM0 SWCLK   D3 PA15    PWM1 SWDIO   D4 PA00    PWM2    D5 PA29 UART2_RX I2C0_SCL  PWM4    D6 PA30 UART2_TX I2C0_SDA  PWM4    D7 PA05    PWM4    D8 PA12    PWM3    D9 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D10 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    A0 PA19, ADC1        A1 ADC2"},{"location":"boards/wr3l/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr3le/","title":"WR3LE Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3le</code>   MCU RTL8710BX   Manufacturer Realtek   Series AmebaZ   Frequency 62.5 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 11x GPIO, 6x PWM, 2x UART, 2x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3LE"},{"location":"boards/wr3le/#usage","title":"Usage","text":"<p>Board code: <code>wr3le</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3le]\nplatform = libretuya\nboard = wr3le\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr3le\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr3le/#pinout","title":"Pinout","text":""},{"location":"boards/wr3le/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA29 UART2_RX I2C0_SCL  PWM4    D1 PA14    PWM0 SWCLK   D2 PA15    PWM1 SWDIO   D3 PA22 UART0_RTS I2C0_SCL SPI0_MISO, SPI1_MISO PWM5    D4 PA00    PWM2    D5 PA30 UART2_TX I2C0_SDA  PWM4    D6 PA19 UART0_CTS I2C0_SDA SPI0_CS, SPI1_CS     D7 PA05    PWM4    D8 PA12    PWM3    D9 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D10 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    A0 PA19, ADC1        A1 ADC2"},{"location":"boards/wr3le/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"boards/wr3n/","title":"WR3N Wi-Fi Module","text":"<p>by Tuya Inc.</p> <p>Product page</p> <ul> <li>General info</li> <li>Flashing guide</li> <li>Debugging</li> </ul>    Parameter Value     Board code <code>wr3n</code>   MCU RTL8710BN   Manufacturer Realtek   Series AmebaZ   Frequency 125 MHz   Flash size 2 MiB   RAM size 256 KiB   Voltage 3.0V - 3.6V   I/O 9x GPIO, 5x PWM, 2x UART, 1x ADC   Wi-Fi 802.11 b/g/n   FCC ID 2ANDL-WR3N"},{"location":"boards/wr3n/#usage","title":"Usage","text":"<p>Board code: <code>wr3n</code></p> <p>In <code>platformio.ini</code>:</p> <pre><code>[env:wr3n]\nplatform = libretuya\nboard = wr3n\nframework = arduino\n</code></pre> <p>In ESPHome YAML:</p> <pre><code>libretuya:\n  board: wr3n\n  framework:\n    version: dev\n</code></pre>"},{"location":"boards/wr3n/#pinout","title":"Pinout","text":""},{"location":"boards/wr3n/#arduino-core-pin-mapping","title":"Arduino Core pin mapping","text":"No. Pin UART I\u00b2C SPI PWM Other     D0 PA29 UART2_RX I2C0_SCL  PWM4    D1 PA14    PWM0 SWCLK   D2 PA15    PWM1 SWDIO   D3 PA00    PWM2    D4 PA30 UART2_TX I2C0_SDA  PWM4    D5 PA05    PWM4    D6 PA12    PWM3    D7 PA18 UART0_RX I2C1_SCL SPI0_SCK, SPI1_SCK     D8 PA23 UART0_TX I2C1_SDA SPI0_MOSI, SPI1_MOSI PWM0    A1 ADC2"},{"location":"boards/wr3n/#flash-memory-map","title":"Flash memory map","text":"<p>Flash size: 2 MiB / 2,097,152 B / 0x200000</p> <p>Hex values are in bytes.</p>    Name Start Length End     Boot XIP 0x000000 16 KiB / 0x4000 0x004000   Boot RAM 0x004000 16 KiB / 0x4000 0x008000   (reserved) 0x008000 4 KiB / 0x1000 0x009000   System Data 0x009000 4 KiB / 0x1000 0x00A000   Calibration 0x00A000 4 KiB / 0x1000 0x00B000   OTA1 Image 0x00B000 788 KiB / 0xC5000 0x0D0000   OTA2 Image 0x0D0000 788 KiB / 0xC5000 0x195000   Key-Value Store 0x195000 24 KiB / 0x6000 0x19B000   User Data 0x19B000 400 KiB / 0x64000 0x1FF000   RDP 0x1FF000 4 KiB / 0x1000 0x200000    <p>RDP is most likely not used in Tuya firmwares, as the System Data partition contains an incorrect offset 0xFF000 for RDP, which is in the middle of OTA2 image.</p> <p>Additionally, Tuya firmware uses an encrypted KV or file storage, which resides at the end of flash memory. This seems to overlap system RDP area.</p>"},{"location":"docs/","title":"Documentation","text":"<p>This documentation is best suited for rendering with MkDocs. Some elements may not display correctly in the GitHub markdown reader.</p> <p>Please visit https://docs.libretuya.ml/ for the full experience.</p> <p>If you still want to read the docs on GitHub, visit SUMMARY.md.</p>"},{"location":"docs/libs-3rd-party/","title":"Libraries","text":"<p>A page outlining 3-rd party libraries compatible with LibreTuya.</p>  <p>Note</p> <p>To use some (most? (all?)) of these, a flag in <code>platformio.ini</code> is required to disable compatibility checks (because most libs are meant for ESP32/Arduino official framework): <pre><code>[env:my_board]\nlib_compat_mode = off\n</code></pre></p>"},{"location":"docs/libs-3rd-party/#mqtt","title":"MQTT","text":"<p>Tested with <code>realtek-ambz</code>. <pre><code>lib_deps = 256dpi/MQTT@^2.5.0\n</code></pre></p>"},{"location":"docs/libs-3rd-party/#dnsserver","title":"DNSServer","text":"<p>Tested with <code>beken-72xx</code>. <pre><code>lib_deps = bbx10/DNSServer@^1.1.0\n</code></pre> This is the same library as in ESP32 Arduino Core.</p>"},{"location":"docs/libs-3rd-party/#asynctcp-esphome","title":"AsyncTCP-esphome","text":"<p>Tested with <code>beken-72xx</code> and <code>realtek-ambz</code>. <pre><code>lib_deps = esphome/AsyncTCP-esphome@^2.0.0\n</code></pre> This is ESPHome's fork of the original library.</p>"},{"location":"docs/libs-3rd-party/#espasyncwebserver-esphome","title":"ESPAsyncWebServer-esphome","text":"<p>Tested with <code>beken-72xx</code> and <code>realtek-ambz</code>. <pre><code>lib_deps = esphome/ESPAsyncWebServer-esphome@^3.0.0\n</code></pre> This is ESPHome's fork of the original library.</p>"},{"location":"docs/libs-built-in/","title":"Built-in libraries","text":"<p>(in alphabetical order)</p>"},{"location":"docs/libs-built-in/#base64","title":"base64","text":"<ul> <li>Source: ESP32 Arduino Core</li> <li>Reference</li> </ul> <p>Helper base64 encoder used in some libs taken from ESP32.</p>"},{"location":"docs/libs-built-in/#httpclient","title":"HTTPClient","text":"<ul> <li>Source: ESP32 Arduino Core</li> <li>Reference</li> <li>Examples</li> </ul> <p>HTTP(S) client.</p>"},{"location":"docs/libs-built-in/#netutils","title":"NetUtils","text":"<p>Utilities and common classes related to network.</p> <ul> <li>ssl/MbedTLSClient.cpp (source: ESP32 WiFiClientSecure)</li> <li>IPv6Address.cpp (source: ESP32 IPv6Address)</li> <li>LwIPRxBuffer.cpp (source: ESP32 WiFiClient)</li> </ul>"},{"location":"docs/libs-built-in/#webserver","title":"WebServer","text":"<ul> <li>Source: ESP32 Arduino Core</li> <li>Reference</li> <li>Examples:<ul> <li>HelloServer</li> <li>MultiHomedServers</li> </ul> </li> </ul>"},{"location":"docs/libs-built-in/#wifimulti","title":"WiFiMulti","text":"<ul> <li>Source: ESP32 Arduino Core</li> <li>Reference</li> <li>Docs</li> <li>Examples:<ul> <li>WiFiMulti</li> <li>WiFiClientBasic</li> </ul> </li> </ul> <p>Class for selecting best available AP from a list of several ones.</p>"},{"location":"docs/flashing/SUMMARY/","title":"Flashing/dumping methods &amp; guides","text":"<ul> <li>Flashing PlatformIO projects</li> <li>Flashing ESPHome</li> <li>Using ltchiptool GUI</li> <li>Converting with tuya-cloudcutter</li> <li>\ud83d\udd0c Chip connection guide<ul> <li>Beken BK72xx</li> <li>Realtek RTL8710Bx</li> </ul> </li> <li>Auto-download-reboot</li> </ul>"},{"location":"docs/flashing/esphome/","title":"Flashing ESPHome","text":"<p>ESPHome can be flashed in few different ways, depending on your needs.</p>  <p>Abstract</p> <p>All binary files generated by ESPHome will be in <code>.esphome/build/&lt;yourdevice&gt;/.pioenvs/&lt;yourdevice&gt;/</code>. The methods described below may require you to get a file from that directory.</p> <p>If you're using the GUI (ESPHome Dashboard) this path will be in your <code>configs/</code> directory.</p> <p>This path will be referred to as build directory.</p>"},{"location":"docs/flashing/esphome/#built-in-flasher","title":"Built-in flasher","text":"CLIGUI   <p>The flasher program built-in LibreTuya is also available for ESPHome.</p> <ul> <li>use <code>python -m esphome run yourdevice.yml</code> to recompile AND upload the firmware</li> <li>use <code>python -m esphome upload yourdevice.yml</code> to upload without recompiling</li> </ul> <p>  The device needs to be connected to your PC with a UART-TTL adapter. Refer to chip connection guides (see: menu on the left) to learn how to connect your device.</p>  <p>If your device is already running ESPHome, refer to the OTA guide below.</p>   <p>The built-in flasher is not yet available in the GUI. Here are your options:</p> <ul> <li>OTA, using the downloaded UF2 file (if you're already running ESPHome)</li> <li>wired (also UF2), using ltchiptool</li> <li>wirelessly, using tuya-cloudcutter</li> </ul> <p>Read below for more details on each of these methods.</p>"},{"location":"docs/flashing/esphome/#over-the-air-ota","title":"Over-the-Air (OTA)","text":"<p>This method requires having ESPHome already installed on your device.</p> <ul> <li>If you've added the Web Server component, navigate to the device's IP address (or <code>.local</code> name) in your web browser. Grab <code>firmware.uf2</code> from the build directory and drop it on the \"OTA Update\" field.</li> <li>You can also use ESPHome CLI to flash via OTA. Add a <code>--device</code> argument to the command, as such: <code>python -m esphome upload yourdevice.yml --device yourdevice.local</code></li> </ul>"},{"location":"docs/flashing/esphome/#using-ltchiptool-wired-via-uart","title":"Using ltchiptool (wired, via UART)","text":"<p>You can use the ltchiptool GUI or CLI to manually flash the firmware. Grab the <code>firmware.uf2</code> file from the build directory. Then, follow the ltchiptool usage guide to flash it to the device.</p>  <p>Tip</p> <p>The UF2 file may have a different name, depending on the project you're building. Usually it's best to grab the latest (sorted by date) file with UF2 extension from the build directory.</p>"},{"location":"docs/flashing/esphome/#converting-devices-with-tuya-cloudcutter","title":"Converting devices with tuya-cloudcutter","text":"<p>Note</p> <p>This currently applies to BK7231T and BK7231N only. <code>tuya-cloudcutter</code> can't be used for other chips.</p>  <p>Grab the <code>bk7231x_app.ota.ug.bin</code> file from the build directory - take care to choose the correct file. It must have \"OTA\" and \"UG\" in its name.</p> <p>Next, refer to Using tuya-cloudcutter guide.</p>"},{"location":"docs/flashing/esphome/#migrating-from-openbeken-ota","title":"Migrating from OpenBeken (OTA)","text":"<p>OpenBeken is a custom, Tasmota-like firmware for non-ESP chips. Currently, this part of the guide applies to BK7231 only, as that's the only chip supported both by LT and OBK.</p> <p>OBK is compatible with standard Beken OTA packages, but the web panel does a filename check to prevent chip type mismatch. Grab the <code>bk7231x_app.ota.bin</code> file from build directory (note: without \"UG\" in the name!), rename it to something like <code>OpenBK7231T_esphome.rbl</code> (change T to N depending on the chip type), and drop it on the OTA panel.</p>"},{"location":"docs/flashing/platformio/","title":"Flashing PlatformIO projects","text":"<p>PlatformIO projects developed with LibreTuya can be flashed just like any other PIO project.</p>  <p>Abstract</p> <p>All binary files generated by PlatformIO will be in <code>.pio/build/&lt;my_board&gt;/</code>. The methods described below may require you to get a file from that directory.</p> <p>This path will be referred to as build directory.</p>"},{"location":"docs/flashing/platformio/#built-in-flasher","title":"Built-in flasher","text":"<p>LibreTuya has a built-in firmware uploader, based on ltchiptool. Pressing <code>Upload</code> in PlatformIO IDE does all the work for you.</p> <p>If you have more than one COM port, configure your PIO project first:</p> platformio.ini<pre><code>[env:my_board]\nmonitor_port = COM96\nupload_port = COM96\n</code></pre>  <p>The device needs to be connected to your PC with a UART-TTL adapter. Refer to chip connection guides (see: menu on the left) to learn how to connect your device.</p>"},{"location":"docs/flashing/platformio/#using-ltchiptool-wired-via-uart","title":"Using ltchiptool (wired, via UART)","text":"<p>You can use the ltchiptool GUI or CLI to manually flash the firmware. Grab the <code>firmware.uf2</code> file from the build directory. Then, follow the ltchiptool usage guide to flash it to the device.</p>  <p>Tip</p> <p>The UF2 file may have a different name, depending on the project you're building. Usually it's best to grab the latest (sorted by date) file with UF2 extension from the build directory.</p>"},{"location":"docs/flashing/inc/ota-cloudcutter/","title":"Ota cloudcutter","text":""},{"location":"docs/flashing/inc/ota-cloudcutter/#converting-devices-with-tuya-cloudcutter","title":"Converting devices with tuya-cloudcutter","text":"<p>Note</p> <p>This currently applies to BK7231T and BK7231N only. <code>tuya-cloudcutter</code> can't be used for other chips.</p>  <p>Grab the <code>bk7231x_app.ota.ug.bin</code> file from the build directory - take care to choose the correct file. It must have \"OTA\" and \"UG\" in its name.</p> <p>Next, refer to Using tuya-cloudcutter guide.</p>"},{"location":"docs/flashing/inc/ota-openbeken/","title":"Ota openbeken","text":""},{"location":"docs/flashing/inc/ota-openbeken/#migrating-from-openbeken-ota","title":"Migrating from OpenBeken (OTA)","text":"<p>OpenBeken is a custom, Tasmota-like firmware for non-ESP chips. Currently, this part of the guide applies to BK7231 only, as that's the only chip supported both by LT and OBK.</p> <p>OBK is compatible with standard Beken OTA packages, but the web panel does a filename check to prevent chip type mismatch. Grab the <code>bk7231x_app.ota.bin</code> file from build directory (note: without \"UG\" in the name!), rename it to something like <code>OpenBK7231T_esphome.rbl</code> (change T to N depending on the chip type), and drop it on the OTA panel.</p>"},{"location":"docs/flashing/inc/uart-info/","title":"Uart info","text":"<p>The device needs to be connected to your PC with a UART-TTL adapter. Refer to chip connection guides (see: menu on the left) to learn how to connect your device.</p>"},{"location":"docs/flashing/inc/uart-ltchiptool/","title":"Uart ltchiptool","text":""},{"location":"docs/flashing/inc/uart-ltchiptool/#using-ltchiptool-wired-via-uart","title":"Using ltchiptool (wired, via UART)","text":"<p>You can use the ltchiptool GUI or CLI to manually flash the firmware. Grab the <code>firmware.uf2</code> file from the build directory. Then, follow the ltchiptool usage guide to flash it to the device.</p>  <p>Tip</p> <p>The UF2 file may have a different name, depending on the project you're building. Usually it's best to grab the latest (sorted by date) file with UF2 extension from the build directory.</p>"},{"location":"docs/flashing/tools/adr/","title":"Auto-download-reboot","text":"<p>(CEN-less uploading)</p> <p>This feature allows to upload code using UART, without needing to ground the CEN wire or power-cycle the device.</p> <p>It is enabled by default (using the <code>LT_AUTO_DOWNLOAD_REBOOT</code> option). It works by listening to incoming UART data, and checking if it matches a command that the flashing program would send. If it does, a chip reboot is performed and the uploading process starts.</p>  <p>Note</p> <p>ADR will only work if there's already a recent build of LibreTuya flashed to the device (and if the device doesn't bootloop or freeze immediately).</p>"},{"location":"docs/flashing/tools/adr/#beken-72xx","title":"Beken 72xx","text":"<p>The code listens on UART1 for a link-check command (<code>01 E0 FC 01 00</code>). The baudrate configured on the serial port has to be 115200 - it is configured automatically upon booting, but ADR won't work anymore if you change the baudrate manually. Because BK72xx doesn't have a dedicated \"persistent\" download mode, a normal reboot is performed and the chip waits a few hundred milliseconds for another link-check command.</p>"},{"location":"docs/flashing/tools/adr/#realtek-amebaz","title":"Realtek AmebaZ","text":"<p>This is not yet implemented.</p>"},{"location":"docs/flashing/tools/cloudcutter/","title":"Converting with tuya-cloudcutter","text":"<p>Note</p> <p>This currently applies to BK7231T and BK7231N only. <code>tuya-cloudcutter</code> can't be used for other chips.</p>  <p><code>tuya-cloudcutter</code> is a tool that disconnects IoT devices from the Tuya cloud, while also allowing remote firmware flashing. This means you can flash ESPHome without even disassembling it.</p>  <p>Warning</p> <p>This guide might be outdated. For an up-to-date guide, always refer to tuya-cloudcutter/INSTRUCTIONS.md.</p>  <p>If your device doesn't have a profile yet, it will probably not work. You can contribute by taking a device dump and posting it on cloudcutter's issues page.</p>"},{"location":"docs/flashing/tools/cloudcutter/#instructions","title":"Instructions","text":""},{"location":"docs/flashing/tools/cloudcutter/#preparation","title":"Preparation","text":"<ol> <li>Get a laptop (or a PC with Wi-Fi) with Linux and Docker installed. This was tested on Ubuntu 20.04, but you should be able to use another Debian-based distribution with NetworkManager.<ul> <li>To install Docker, run <code>sudo apt-get install docker.io</code>. When it completes, run <code>sudo adduser &lt;your username&gt; docker</code> and reboot the machine.</li> <li>This was also successfully performed on a VirtualBox VM, with a USB Wi-Fi adapter redirected to the VM.</li> </ul> </li> <li>Install <code>git</code>, if you haven't already (<code>sudo apt-get install git</code>).</li> <li><code>git clone https://github.com/tuya-cloudcutter/tuya-cloudcutter</code></li> </ol>"},{"location":"docs/flashing/tools/cloudcutter/#firmware-building","title":"Firmware building","text":"<ol> <li>Compile ESPHome, or your custom firmware based on LibreTuya.</li> <li>Get the firmware binary, named <code>bk7231x_app.ota.ug.bin</code> from the build directory (<code>.pio/build/&lt;board&gt;/</code> or <code>.esphome/build/&lt;board&gt;/.pioenvs/&lt;board&gt;/</code>).</li> <li>Put it in the <code>custom-firmware</code> directory of tuya-cloudcutter.</li> </ol>"},{"location":"docs/flashing/tools/cloudcutter/#pairing-and-flashing","title":"Pairing and flashing","text":"<ol> <li>Run <code>./tuya-cloudcutter.sh</code> from the cloudcutter directory.</li> <li>Answer questions about the desired firmware file, the device vendor and profile.</li> <li>Put the device to AP mode: (**)<ul> <li>Bulbs (devices without buttons) usually need to be power-cycled a few times, until they start blinking slowly.</li> <li>Switches, plugs, relays (devices with buttons) usually enable AP after pressing the button for a few seconds.</li> <li>If the device (bulb or switch LED) is blinking quickly (~2 times per second), do the procedure again.</li> </ul> </li> <li>Cloudcutter will scan for APs, connect to the device and send a payload to it.</li> <li>The device will most likely hang (not respond). Reboot it again to AP mode (just like in step 9).</li> <li>Cloudcutter will scan for APs again, configure the device to talk to it, then begin the OTA update.</li> <li>After around 30 seconds, the device will boot new firmware \ud83d\udc4f</li> </ol> <p>** Use a smartphone with the Wi-Fi screen open and scanning, so that you can see if AP mode got enabled.</p>"},{"location":"docs/flashing/tools/ltchiptool/","title":"ltchiptool","text":"<p>ltchiptool is a universal, easy-to-use GUI flashing/dumping tool for BK7231, RTL8710B and RTL8720C. It also contains some CLI utilities for binary firmware manipulation.</p>"},{"location":"docs/flashing/tools/ltchiptool/#installation","title":"Installation","text":"<p> Download Windows GUI</p>"},{"location":"docs/flashing/tools/ltchiptool/#cli-program","title":"CLI program","text":"<p>Install the package from PyPI, using <code>pip install ltchiptool</code>. Run the CLI using <code>python -m ltchiptool</code> or just <code>ltchiptool</code>.</p>"},{"location":"docs/flashing/tools/ltchiptool/#gui-application","title":"GUI application","text":"Windows 7 and newer <p>Download the latest release .EXE from the GitHub Releases page. Open the file, and you're ready to go!</p>   Windows (manual installation) <p>Install the package from PyPI (including GUI extras), using <code>pip install ltchiptool[gui]</code>. Note that Python 3.10 or newer is required for the GUI. I recommend Python 3.10 since it has prebuilt wheels of wxPython, which doesn't require C++ build dependencies.</p>   Linux (Ubuntu) <p>Install the package from PyPI, using <code>pip install ltchiptool</code>. Python 3.10 or newer is required.</p> <p>Make sure you have wxPython installed. Install it from PyPI (if you have the necessary build dependencies), or refer to the wxPython Downloads page to install prebuilt wheels (recommended).</p> <p>Next, open a terminal and run <code>ltchiptool gui</code> (or <code>python -m ltchiptool gui</code>).</p>   MacOS (untested) <p>Install the package from PyPI, using <code>pip install ltchiptool</code>. Python 3.10 or newer is required.</p> <p>Install wxPython from PyPI as well. Version 4.2.0 (latest at the time of writing) has some wheels for MacOS, so that should work.</p>"},{"location":"docs/flashing/tools/ltchiptool/#gui-usage","title":"GUI Usage","text":"<p>The main window is somewhat similar to NodeMCU PyFlasher.</p> <ul> <li>For dumping, choose <code>Read flash</code>. If you've previously chosen an input or output file, it will generate a dump filename with the current timestamp and chip type. Otherwise, click <code>Browse</code> and choose the output file. By default, the tool will attempt to read the entire flash chip (usually 2 MiB).</li> <li>For flashing, choose <code>Write flash</code>. Click <code>Browse</code> and select any valid firmware file. The file type and chip type will be auto-detected, along with correct flash offset and length. No need to worry about overwriting the bootloader anymore!<ul> <li>If the file you're selecting is <code>Unrecognized</code> or <code>Not flashable</code>, it's most likely not a valid firmware file. Refer to usage guides of the custom firmware project of choice, to find which file is meant for flashing.</li> </ul> </li> <li>It's best to leave <code>Auto-detect advanced parameters</code> checked. If you're an experienced user and want to flash custom areas of the flash, uncheck the box and specify the parameters manually.</li> <li>When you're ready, hit <code>Start</code>. The tool will try to connect to the chip on the selected UART port. The black log window will print any warnings/errors, as well as a short guide on how to put the chip in download mode.</li> </ul>  <p>Info</p> <p>LibreTuya generates multiple firmware files in the build directory. You usually want to flash the <code>.uf2</code> file, but since ltchiptool can detect file types, you can choose a different firmware file and it'll tell you if that works.</p>"},{"location":"docs/flashing/tools/ltchiptool/#cli-usage","title":"CLI Usage","text":"<p>Note</p> <p>If you're here to learn how to flash or dump firmware files, use the instructions above.</p> <p>The content below serves as a short documentation page for <code>ltchiptool</code> and is mostly meant for advanced users.</p>  <pre><code>$ ltchiptool --help\nUsage: ltchiptool [OPTIONS] COMMAND [ARGS]...\n\n  Tools for working with LT-supported IoT chips\n\nOptions:\n  -v, --verbose         Output debugging messages (repeat to output more)\n  -T, --traceback       Print complete exception traceback\n  -t, --timed           Prepend log lines with timing info\n  -r, --raw-log         Output logging messages with no additional styling\n  -i, --indent INTEGER  Indent log messages using graph lines\n  -V, --version         Show the version and exit.\n  -h, --help            Show this message and exit.\n\nCommands:\n  dump      Capture or process device dumps\n  elf2bin   Generate firmware binaries from ELF file\n  flash     Flashing tool - reading/writing\n  link2bin  Link code to binary format\n  list      List boards, families, etc.\n  soc       Run SoC-specific tools\n  uf2       Work with UF2 files\n</code></pre>"},{"location":"docs/flashing/tools/ltchiptool/#flashingdumping","title":"Flashing/dumping","text":"<p>There are three main commands used for flashing:</p> <ul> <li><code>ltchiptool flash file &lt;FILE&gt;</code> - detect file type based on its contents (i.e. chip from which a dump was acquired), similar to Linux <code>file</code> command</li> <li><code>ltchiptool flash read &lt;FAMILY&gt; &lt;FILE&gt;</code> - make a full flash dump of the connected device; specifying the family is required</li> <li><code>ltchiptool flash write &lt;FILE&gt;</code> - upload a file to the device; detects file type automatically (just like the <code>file</code> command above)</li> </ul> <p>Supported device families can be checked using <code>ltchiptool list families</code> command. In the commands above, you can use any of the family names (name/code/short name/etc).</p> <p>The upload UART port and baud rate is detected automatically. To override it, use <code>-d COMx</code> or <code>-d /dev/ttyUSBx</code>. To change the target baud rate, use <code>-b 460800</code>. Note that the baud rate is changed after linking. Linking is performed using chip-default baud rate.</p> <p>It's not required to specify chip family for writing files - <code>ltchiptool</code> tries to recognize contents of the file, and chooses the best settings automatically. If you want to flash unrecognized/raw binaries (or fine-tune the flashing parameters), specify <code>-f &lt;FAMILY&gt;</code> and <code>-s &lt;START OFFSET&gt;</code>.</p>"},{"location":"docs/flashing/tools/ltchiptool/#uf2-example","title":"UF2 Example","text":"<pre><code>$ ltchiptool uf2 info ./arduinotest_22.08.01_wb2l_BK7231T_lt0.8.0.uf2\nFamily: BK7231T / Beken 7231T\nTags:\n - BOARD: wb2l\n - DEVICE_ID: d80e20c2\n - LT_VERSION: 0.8.0\n - FIRMWARE: arduinotest\n - VERSION: 22.08.01\n - OTA_VERSION: 01\n - DEVICE: LibreTuya\n - BUILD_DATE: 6d08e862\n - LT_HAS_OTA1: 01\n - LT_HAS_OTA2: 00\n - LT_PART_1: app\n - LT_PART_2:\nData chunks: 1871\nTotal binary size: 478788\n</code></pre>"},{"location":"docs/getting-started/","title":"Getting started","text":"<p>Using LibreTuya is simple, just like every other PlatformIO development platform.</p> <ol> <li>Install PlatformIO</li> <li><code>platformio platform install -f https://github.com/kuba2k2/libretuya</code></li> </ol>"},{"location":"docs/getting-started/#board-selection","title":"Board selection","text":"<ul> <li>Go to Boards &amp; CPU list.</li> <li>Find the board your device has (usually, the model number is written on the silkscreen).<ul> <li>If your board isn't available yet, use one of the \"Generic\" boards that matches the CPU you have.</li> </ul> </li> <li>Click on the board name. From the documentation page, note the board code.</li> <li>Use this code to create a PlatformIO project.</li> </ul>"},{"location":"docs/getting-started/#run-community-projects","title":"Run community projects","text":"<p>LibreTuya was developed with popular community projects in mind. Currently, unofficial ESPHome port is available (the PR will hopefully be merged into upstream at some point).</p>"},{"location":"docs/getting-started/#develop-your-own-project","title":"Develop your own project","text":"<p>If you're developing your own embedded software, and want it to run on LibreTuya-supported chips, create a project.</p> <ul> <li>use PlatformIO IDE (PIO Home -&gt; Open -&gt; New Project)</li> <li>run <code>pio project init</code> in your desired project directory</li> </ul> <p>Next, read one of the flashing guides to run your project!</p>"},{"location":"docs/getting-started/#lt-configuration","title":"LT configuration","text":"<p>LibreTuya has a few configuration options that change its behavior or features. Refer to LT configuration for details.</p>"},{"location":"docs/getting-started/#gpio-usage","title":"GPIO usage","text":"<p>Important</p> <p>This can be confusing at first, so make sure to read this part carefully to understand it.</p> <p>Input/output pin numbers in Arduino code (i.e. <code>digitalWrite()</code>) use Arduino pin numbers - for example <code>D1</code>, <code>D3</code>. This is the same as simply <code>1</code> or <code>3</code>, but it cannot be confused with CPU GPIO numbers.</p> <p>On the board pinout page, the purple blocks represent Arduino pins, while the dark red blocks refer to GPIO numbers.</p>"},{"location":"docs/getting-started/#examples","title":"Examples","text":"<ul> <li>PinScan</li> </ul>"},{"location":"docs/ota/","title":"UF2-based OTA","text":"<p>LibreTuya's OTA updating is based on Microsoft's UF2 specification. Some aspects of the process, such as OTA1/2 support and target partition selection, have been customized with extension tags.</p>  <p>Note</p> <p>Just like in UF2, all values in this format are little-endian.</p>"},{"location":"docs/ota/#firmware-images","title":"Firmware images","text":"<p>UF2 files may contain multiple firmware images that are to be flashed, i.e. main firmware + bootloader + some config partition.</p> <p>Some CPUs support dual-OTA schemes: firmware runs from one image, while the other one is reserved for updated firmware. After applying the update, a reboot causes to run the other image instead.</p> <p>Each firmware image may be either applicable:</p> <ol> <li>only when flashing OTA1 (<code>part;file;;</code>)</li> <li>only when flashing OTA2 (<code>;;part;file</code>)</li> <li>for both schemes to a single partition (<code>part;file</code>)</li> <li>for both schemes but different partitions (<code>part1;file;part2;file</code>)</li> <li>for both schemes but with a different binary (<code>part;file1;part;file2</code>)</li> <li>for both schemes, with different binaries and target partitions (<code>part1;file1;part2;file2</code>)</li> </ol> <p>* <code>part</code> means partition here</p> <p>** values in parentheses show the input format to use for <code>uf2ota.py</code></p> <p>For easier understanding, these update types will be referred to in this document using the numbers.</p>"},{"location":"docs/ota/#custom-family-ids","title":"Custom family IDs","text":"Title Name (parent) Code Short name &amp; ID Arduino Core Source SDK     Realtek Ameba1 <code>-</code> <code>-</code> <code>RTL8710A</code> (0x9FFFD543) \u274c -   Realtek AmebaZ <code>realtek-ambz</code> (<code>realtek-amb</code>) <code>ambz</code> (<code>amb</code>) <code>RTL8710B</code> (0x22E0D6FC) \u2714\ufe0f <code>framework-realtek-amb1</code> (amb1_sdk)   Realtek AmebaZ2 <code>realtek-ambz2</code> (<code>realtek-amb</code>) <code>ambz2</code> (<code>amb</code>) <code>RTL8720C</code> (0xE08F7564) \u274c <code>framework-realtek-ambz2</code> (ambz2_sdk)   Realtek AmebaD <code>-</code> <code>-</code> <code>RTL8720D</code> (0x3379CFE2) \u274c -   Beken 7231U/7231T <code>beken-7231u</code> (<code>beken-72xx</code>) <code>bk7231u</code> (<code>bk72xx</code>) <code>BK7231U</code> (0x675A40B0) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Beken 7231N <code>beken-7231n</code> (<code>beken-72xx</code>) <code>bk7231n</code> (<code>bk72xx</code>) <code>BK7231N</code> (0x7B3EF230) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Beken 7251/7252 <code>beken-7251</code> (<code>beken-72xx</code>) <code>bk7251</code> (<code>bk72xx</code>) <code>BK7251</code> (0x6A82CC42) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Boufallo 602 <code>-</code> <code>-</code> <code>BL602</code> (0xDE1270B7) \u274c -   Xradiotech 809 <code>-</code> <code>-</code> <code>XR809</code> (0x51E903A8) \u274c -   Native host architecture <code>host-native</code> <code>native</code> <code>NATIVE</code> (0xDEADBEEF) \u274c -"},{"location":"docs/ota/#extension-tags","title":"Extension tags","text":"<p>Standard tags are used: <code>VERSION</code>, <code>DEVICE</code> and <code>DEVICE_ID</code>.</p> <p>Additionally, custom tags are defined:</p>    Name ID Type Description     <code>OTA_VERSION</code> 0x5D57D0 int 8-bit format version (for simple compatibility checks)   <code>BOARD</code> 0xCA25C8 string board name / code (lowercase)   <code>FIRMWARE</code> 0x00DE43 string firmware description / name   <code>BUILD_DATE</code> 0x822F30 int 32-bit build date/time as Unix timestamp   <code>LT_VERSION</code> 0x59563D semver LT version   <code>LT_PART_1</code> 0x805946 string OTA1 partition name   <code>LT_PART_2</code> 0xA1E4D7 string OTA2 partition name   <code>LT_HAS_OTA1</code> 0xBBD965 bool 8-bit image has any data for OTA1   <code>LT_HAS_OTA2</code> 0x92280E bool 8-bit image has any data for OTA2   <code>LT_BINPATCH</code> 0xB948DE bytes binary patch to convert OTA1-&gt;OTA2"},{"location":"docs/ota/#update-types","title":"Update types","text":""},{"location":"docs/ota/#single-ota-scheme-1-2","title":"Single OTA scheme (1, 2)","text":"<p>Image is ignored if the OTA scheme does not match. UF2 has <code>LT_PART_1</code> or <code>LT_PART_2</code> set to target partition name. The other partition tag is present, but empty (0 bytes).</p> <pre><code>08 46 59 80 6f 74 61 31 | .FY.ota1 | LT_PART_1\n04 d7 e4 a1             | ....     | LT_PART_2\n</code></pre>"},{"location":"docs/ota/#dual-otasingle-file-scheme-3-4","title":"Dual-OTA/single-file scheme (3, 4)","text":"<p>One image is used for both OTA schemes. UF2 has <code>LT_PART_1</code> and <code>LT_PART_2</code> tags set. For type <code>3</code> these two tags contain the same partition name.</p> <pre><code>08 46 59 80 6f 74 61 31 | .FY.ota1 | LT_PART_1\n08 d7 e4 a1 6f 74 61 32 | ....ota2 | LT_PART_2\n</code></pre>"},{"location":"docs/ota/#dual-otadual-file-scheme-5-6","title":"Dual-OTA/dual-file scheme (5, 6)","text":"<p>Just like types <code>3</code> and <code>4</code>, UF2 has two partition tags set. For type <code>5</code> they have the same name.</p> <p>The image stored in UF2 is meant for OTA1 scheme. There is an additional tag <code>LT_BINPATCH</code> present. In OTA1 flashing scheme, it is ignored.</p>"},{"location":"docs/ota/#binary-patching","title":"Binary patching","text":"<p>OTA2 images are not stored directly, as that would needlessly double the UF2 file size. Instead, binary patching instructions, embedded into the extension tags area, allow the CPU to convert the OTA1 image from UF2 into OTA2 image.</p> <p>There can be at most one binpatch tag in a UF2 block. It has the following format:</p> <ul> <li>opcode (1 byte) - operation type:<ul> <li><code>DIFF32</code> (0xFE) - difference between 32-bit values</li> </ul> </li> <li>length (1 byte) - data length</li> <li>data (<code>length</code> bytes)<ul> <li>for <code>DIFF32</code>:<ul> <li>difference value (signed int 32-bit)</li> <li>offset table (<code>length-4</code> bytes)</li> </ul> </li> </ul> </li> </ul> <p>The presented structure can be repeated in a single binpatch tag.</p>"},{"location":"docs/ota/#diff32","title":"DIFF32","text":"<p>This method works by adding the difference value to a 32-bit integer. It allows to save the most space in OTA1/2 image scenarios, where the only different values are, for example, flash memory addresses. The offset table contains positions within the 256-byte block, to which the difference value should be mathematically added.</p> <p>For a block like: <pre><code>000  72 71 73 61 76 65 00 00  5f 66 72 65 65 72 74 6f  |rqsave.._freerto|\n010  73 5f 6d 75 74 65 78 5f  67 65 74 5f 74 69 6d 65  |s_mutex_get_time|\n020  6f 75 74 00 5d a4 03 08  61 a4 03 08 85 a4 03 08  |out.]...a.......|\n030  5d a4 03 08 61 a4 03 08  85 a4 03 08 81 a9 03 08  |]...a...........|\n040  6d a9 03 08 7d a4 03 08  d9 a8 03 08 05 a7 03 08  |m...}...........|\n050  bd a4 03 08 ad a8 03 08  59 a7 03 08 9d a8 03 08  |........Y.......|\n060  01 a7 03 08 51 a8 03 08  21 aa 03 08 b9 a4 03 08  |....Q...!.......|\n070  85 a3 03 08 89 a3 03 08  4d a4 03 08 a1 a8 03 08  |........M.......|\n080  00 00 00 00 00 00 00 00  19 a8 03 08 c1 a4 03 08  |................|\n090  8d a8 03 08 ed a6 03 08  dd a7 03 08 ad a4 03 08  |................|\n0a0  9d a7 03 08 95 a4 03 08  81 a7 03 08 09 a7 03 08  |................|\n0b0  31 a7 03 08 d1 a6 03 08  dd a5 03 08 61 aa 03 08  |1...........a...|\n0c0  c5 a2 03 08 d5 a2 03 08  d9 a2 03 08 b1 a6 03 08  |................|\n0d0  65 aa 03 08 ad a6 03 08  a9 a6 03 08 8d a6 03 08  |e...............|\n0e0  e5 a2 03 08 e9 a2 03 08  1d a4 03 08 ed a3 03 08  |................|\n0f0  35 a4 03 08 05 a4 03 08  bd a3 03 08 8d a3 03 08  |5...............|\n</code></pre></p> <p>a DIFF32 patch containing: <pre><code>     fe 39 00 50 0c 00 24 28  2c 30 34 38 3c 40 44 48  |.9.P..$(,048&lt;@DH|\n     4c 50 54 58 5c 60 64 68  6c 70 74 78 7c 88 8c 90  |LPTX\\`dhlptx|...|\n     94 98 9c a0 a4 a8 ac b0  b4 b8 bc c0 c4 c8 cc d0  |................|\n     d4 d8 dc e0 e4 e8 ec f0  f4 f8 fc                 |...........     |\n</code></pre></p> <p>adds 0x000C5000 to 53 values, producing OTA2 output like this: <pre><code>000  72 71 73 61 76 65 00 00  5f 66 72 65 65 72 74 6f  |rqsave.._freerto|\n010  73 5f 6d 75 74 65 78 5f  67 65 74 5f 74 69 6d 65  |s_mutex_get_time|\n020  6f 75 74 00 5d f4 0f 08  61 f4 0f 08 85 f4 0f 08  |out.]...a.......|\n030  5d f4 0f 08 61 f4 0f 08  85 f4 0f 08 81 f9 0f 08  |]...a...........|\n040  6d f9 0f 08 7d f4 0f 08  d9 f8 0f 08 05 f7 0f 08  |m...}...........|\n050  bd f4 0f 08 ad f8 0f 08  59 f7 0f 08 9d f8 0f 08  |........Y.......|\n060  01 f7 0f 08 51 f8 0f 08  21 fa 0f 08 b9 f4 0f 08  |....Q...!.......|\n070  85 f3 0f 08 89 f3 0f 08  4d f4 0f 08 a1 f8 0f 08  |........M.......|\n080  00 00 00 00 00 00 00 00  19 f8 0f 08 c1 f4 0f 08  |................|\n090  8d f8 0f 08 ed f6 0f 08  dd f7 0f 08 ad f4 0f 08  |................|\n0a0  9d f7 0f 08 95 f4 0f 08  81 f7 0f 08 09 f7 0f 08  |................|\n0b0  31 f7 0f 08 d1 f6 0f 08  dd f5 0f 08 61 fa 0f 08  |1...........a...|\n0c0  c5 f2 0f 08 d5 f2 0f 08  d9 f2 0f 08 b1 f6 0f 08  |................|\n0d0  65 fa 0f 08 ad f6 0f 08  a9 f6 0f 08 8d f6 0f 08  |e...............|\n0e0  e5 f2 0f 08 e9 f2 0f 08  1d f4 0f 08 ed f3 0f 08  |................|\n0f0  35 f4 0f 08 05 f4 0f 08  bd f3 0f 08 8d f3 0f 08  |5...............|\n</code></pre></p>"},{"location":"docs/ota/flashing/","title":"Flashing","text":"<p>It is possible to upload firmware binaries manually, using the command-line tool <code>ltchiptool</code>. For this, you need the <code>.uf2</code> file generated after compilation (usually found in <code>.pio/build/my_board/</code>).</p> <ol> <li>Install Python. Afterwards, run <code>pip install ltchiptool</code>.</li> <li><code>ltchiptool uf2 upload my_firmware.uf2 uart COM96</code> (replace <code>my_firmware.uf2</code> with your file name and <code>COM96</code> with your upload port).</li> </ol>"},{"location":"docs/ota/library/","title":"uf2ota library","text":"<p>uf2ota library allows to write a LibreTuya UF2 file to the flash, while parsing all the necessary tags. It manages the target partitions, compatibility checks, and works on top of the FAL provided by FlashDB.</p>"},{"location":"docs/ota/library/#usage-example","title":"Usage example","text":"<pre><code>uint8_t target     = 1;          // target OTA scheme - 1 or 2\nuint32_t family    = F_RTL8710B; // chip's UF2 family ID\nuf2_ota_t *ctx     = uf2_ctx_init(target, family);\nuf2_info_t *info   = uf2_info_init(); // optional, for getting firmware info\nuf2_block_t *block = (uf2_block_t *)malloc(UF2_BLOCK_SIZE);\nuf2_err_t err;\n\n// ... // read the first header block (512 bytes) into *block\n\n// check the block for validity\nerr = uf2_check_block(ctx, block);\nif (err &gt; UF2_ERR_IGNORE)\n    // handle the error\n    return;\n\n// parse the header block\n// note: if you don't need info, you can skip this step and call uf2_write() directly\nerr = uf2_parse_header(ctx, block, info);\nif (err)\n    // handle the error\n    return;\n\nwhile (/* have input data */) {\n\n    // ... // read the next block into *block\n\n    // check the block for validity\n    err = uf2_check_block(ctx, block);\n    if (err == UF2_ERR_IGNORE)\n        // skip this block\n        continue;\n    if (err)\n        // handle the error\n        return;\n\n    // write the block to flash\n    err = uf2_write(ctx, block);\n    if (err &gt; UF2_ERR_IGNORE)\n        // handle the error\n        return;\n}\n\n// finish the update process\n\n// ... // activate your new OTA partition\n\n// cleanup\nfree(ctx);\nfree(block);\nuf2_info_free(info);\n</code></pre>"},{"location":"docs/ota/uf2ota/","title":"uf2ota.py","text":"<p>This is a tool for converting LibreTuya firmware images to UF2 format for OTA updates.</p> <pre><code>$ python uf2ota.py\nusage: uf2ota [-h] [--output OUTPUT] [--family FAMILY] [--board BOARD] [--version VERSION] [--fw FW] {info,dump,write} inputs [inputs ...]\nuf2ota: error: the following arguments are required: action, inputs\n</code></pre>"},{"location":"docs/ota/uf2ota/#write","title":"write","text":"<p>Generate a UF2 file from a firmware image or several images.</p> <pre><code>$ python uf2ota.py write --family RTL8710B --board wr3 --version 0.4.0 --fw esphome:2022.6.0-dev \"ota1;xip1.bin;ota2;xip2.bin\"\n\n$ ls -l out.uf2\n-rw-r--r-- 1 Kuba None 605696 May 28 14:35 out.uf2\n</code></pre>"},{"location":"docs/ota/uf2ota/#inputs-format","title":"inputs format","text":"<p>Format for <code>inputs</code> parameter is <code>part;file[;part;file]</code> (square brackets mean optional). First two (colon separated) values correspond to flashing OTA1 region, second two to OTA2.</p> <p>Partition name can be suffixed by <code>+offset</code>, which causes writing the image file to the partition after some byte offset. Both files and/or partition names can be equal. Values can be empty (like <code>part;file;;</code> or <code>;;part;file</code>) if OTA1/2 images are not present in this file.</p> <p>When using two different firmware binaries, they need to have the same <code>offset</code> and be of the same size.</p> <p><code>inputs</code> parameter can be repeated in order to embed multiple files in the UF2. For example: <pre><code>\"bootloader;boot.bin\" \"ota1;xip1.bin;ota2;xip2.bin\" \"config;config1.bin;config;config2.bin\"\n</code></pre> will:</p> <ul> <li>flash the bootloader in both OTA schemes</li> <li>flash <code>xip1.bin</code> or <code>xip2.bin</code> to <code>ota1</code> or <code>ota2</code> partitions</li> <li>flash <code>config1.bin</code> or <code>config2.bin</code> to <code>config</code> partition</li> </ul>"},{"location":"docs/ota/uf2ota/#info","title":"info","text":"<p>This command shows some basic parameters of a UF2 image.</p> <pre><code>$ python uf2ota.py info out.uf2\nFamily: RTL8710B\nTags:\n - BOARD: wr3\n - DEVICE_ID: 312d5ec5\n - LT_VERSION: 0.4.0\n - FIRMWARE: esphome\n - VERSION: 2022.6.0-dev\n - OTA_VERSION: 01\n - DEVICE: LibreTuya\n - LT_HAS_OTA1: 01\n - LT_HAS_OTA2: 01\n - LT_PART_1: ota1\n - LT_PART_2: ota2\n - LT_BINPATCH: fe0900500c009094989ca0\nData chunks: 1182\nTotal binary size: 302448\n</code></pre>"},{"location":"docs/ota/uf2ota/#dump","title":"dump","text":"<p>Dump UF2 file (only LibreTuya format) into separate firmware binaries.</p> <pre><code>$ python uf2ota.py dump out.uf2\n\n$ ls -1 out.uf2_dump/\nesphome_2022.6.0-dev_lt0.4.0_wr3_1_ota1_0x0.bin\nesphome_2022.6.0-dev_lt0.4.0_wr3_2_ota2_0x0.bin\n</code></pre>"},{"location":"docs/platform/beken-72xx/","title":"Beken 72xx","text":""},{"location":"docs/platform/beken-72xx/#resources","title":"Resources","text":"Name Notes     BK7231U Datasheet v0.71 Machine-translated to English   BL2028N Datasheet v1.0 BL2028N is a \"clone\" of BK7231N   BK72XX SDK User Manual 3.0.3 Machine-translated to English   BEKEN WiFi SDK API Reference 3.0.27 Machine-translated to English   Beken SDK documentation (online) Not much here   <code>encrypt v0.3</code> source code    <code>ota_tools</code> source code Encryption routines and FPGA code used on the chip   BK7231 OpenOCD debugging From Elektroda.pl user <code>@xabean</code>"},{"location":"docs/platform/beken-72xx/#general-info","title":"General info","text":"<p>There are many chip variations in this SoC family:</p> <ul> <li>BK7231 - marked BK7321QN40, so we're calling it \"BK7231Q\" to reduce confusion</li> <li>BK7231T</li> <li>BK7231N</li> <li>BK7231S</li> <li>BK7231U</li> </ul> <p>The \"officially existing\" ones are BK7231Q, BK7231N and BK7231U. These are supported by Beken SDKs, such as <code>bdk_freertos</code>, although <code>bk7231s_alios_sdk</code> also existed at some point.</p> <ul> <li>BK7231N is substantially different than the other chips, so running T code on N (and vice versa) is not directly possible.</li> <li>BK7231Q does not have eFuse.</li> <li>there are some references to U meaning USB support</li> <li>T seems to be exclusive to Tuya boards (that would explain the name); in the T SDK from Tuya, <code>CFG_SOC_NAME</code> is set to <code>SOC_BK7231U</code></li> <li>T's bootloader greets with <code>BK7231S_1.0.5</code> on UART</li> </ul> <p>Regarding <code>bdk_freertos</code>:</p> <ul> <li><code>make</code> allows selecting for which MCU the code should be compiled</li> <li><code>make bk7231</code> doesn't compile at all</li> <li><code>make bk7231u</code> doesn't run on T with Tuya's bootloader (1.0.5), though it works just fine after replacing the bootloader with one of these included with <code>bdk_freertos</code> (1.0.8) (yes, even <code>bk7231n</code> bootloader)</li> <li>after making a few changes to <code>driver/entry</code> and <code>driver/intc</code> (so it looks more like the code from T SDK) <code>bdk_freertos</code> runs just fine</li> </ul>"},{"location":"docs/platform/beken-72xx/flashing/","title":"Download mode - Beken 72xx","text":"<p>Read chip docs</p>  <p>Downloading is done using UART. For best experience, you should have two USB&lt;-&gt;UART adapters plugged in:</p> <ul> <li>One for flashing, preferably a real FT232RL or a good alternative. This connects to UART1 of the chip.</li> <li>One for log output - BK72xx outputs messages on a separate port. You can have a terminal session continuously open on this adapter. This connects to UART2 of the chip - but it's not necessary for flashing.</li> </ul> <p>Read Using ltchiptool to learn the flashing procedure</p>  <p>Wiring</p> <p>Connect UART1 of the BK7231 to the USB-TTL adapter:</p>    PC BK7231     RX TX1 (GPIO11 / P11)   TX RX1 (GPIO10 / P10)   RTS CEN (or RST, optional)   GND GND    <p>Make sure to use a good 3.3V power supply, otherwise the adapter might lose power during chip reset. Usually, the adapter's power regulator is not enough and an external power supply is needed (like AMS1117).</p> <p>If you didn't connect RTS to CEN, after starting the flasher you have around 20 seconds to reset the chip manually. In order to do that, you need to bridge CEN to GND with a wire.</p>  <p>Note that the download mode can only be activated when the flasher is running (there's no GPIO-strapping like on ESP8266). Additionally, BK7231T (not N) will exit the download mode when the flasher finishes its work.</p>  <p>Tip</p> <p>BK7231N can't be software-bricked, because it has a ROM that contains the download mode. BK7231T doesn't contain the ROM, so be careful with this one.</p>"},{"location":"docs/platform/beken-72xx/flashing/#bk7231tools","title":"bk7231tools","text":"<p><code>ltchiptool</code>'s Beken flashing program is based on bk7231tools. Refer to the guide for information how to use it, but keep in mind that using the ltchiptool GUI is probably just easier.</p>"},{"location":"docs/platform/beken-72xx/flashing/#auto-download-reboot","title":"Auto-download-reboot","text":"<p>If you have a recent version of LibreTuya installed on the chip, you can use Auto-download-reboot to reboot the chip automatically. This is enabled by default, so you don't have to change anything.</p>"},{"location":"docs/platform/beken-72xx/flashing/#single-adapter-usage","title":"Single-adapter usage","text":"<p>If you only have a single adapter, or just want to use the UART1 (upload) port only, you can change the logging port.</p> <p>Refer to Options &amp; config (<code>Serial output</code> section). Set <code>LT_UART_DEFAULT_PORT</code> to <code>1</code>, which will use UART1 for all output.</p>"},{"location":"docs/platform/beken-72xx/flashing/#firmware-output-files","title":"Firmware output files","text":"<p>These files are present in the build directory after successful compilation:</p>    File Description     firmware.uf2 UF2 package for UART and OTA upload   bk7231t_app.ota.rbl Beken OTA package (e.g. OpenBeken)   bk7231t_app.ota.ug.bin Tuya OTA package (incl. Cloudcutter)   bk7231t_app_0x011000.rbl App partition - flashable at 0x11000   bk7231t_app_0x011000.crc Encrypted app image - not for flashing   bk7231t_app_0x129F0A.rblh RBL header - not for flashing"},{"location":"docs/platform/beken-72xx/flashing/#spi-flashing-unbricking-bk7231t","title":"SPI flashing (unbricking BK7231T)","text":"<p>The bk7231_spi_flasher.py script can be used to put BK7231 in SPI flashing mode. Then, one can use flashrom to read/write the raw flash chip.</p>"},{"location":"docs/platform/beken-72xx/flashing/#other-toolsguides","title":"Other tools/guides","text":"<p>These tools are not recommended and are kept here for reference only. Don't use them, please.</p> <ul> <li>Flashing (Tuya manual)</li> <li>BkWriter v1.6.0</li> <li>hid_download_py</li> </ul>"},{"location":"docs/platform/realtek-amb/","title":"Realtek Ameba","text":"<p>The logic behind naming of Realtek chips and their series took me some time to figure out:</p> <ul> <li>RTL8xxxA - Ameba1/Ameba Series</li> <li>RTL8xxxB - AmebaZ Series</li> <li>RTL8xxxC - AmebaZ2/ZII Series</li> <li>RTL8xxxCS - Ameba CS Series</li> <li>RTL8xxxD - AmebaD Series</li> <li>Realtek product pages</li> </ul> <p>As such, there are numerous CPUs with the same numbers but different series. Different Ameba series are not compatible with each other, which makes them require different code and SDKs.</p>   Ameba series comparison table"},{"location":"docs/platform/realtek-amb/#table-from-wwwe-paper-displaycom","title":"Table from www.e-paper-display.com","text":"<p>(modified a bit)</p>    Realtek P/N Series Protocol CPU Frequency SRAM UART SPI I2S ADC/DAC     RTL8710BN Ameba Z WiFi ARM M4 125M 256KB 1 1 N Y/N   RTL8710BX Ameba Z WiFi ARM M4 62.5M 256KB 1 1 N Y/N   RTL8710CX Ameba Zii WiFi ARM M4 100M 256KB 3 1 N N/N   RTL8710CM Ameba Zii WiFi ARM M4 100M 256K+4M 3 1 N N/N   RTL8720CN Ameba Zii WiFi+BLE4.2 ARM M4 100M 256KB 2 1 N N/N   RTL8720CF Ameba Zii WiFi+BLE4.2 ARM M4 100M 256KB 2 1 N N/N   RTL8720CM Ameba Zii WiFi+BLE4.2 ARM M4 100M 256KB 2 1 N N/N   RTL8720CS Ameba CS WiFi+BLE5 Mesh M0+M4 200M 512KB 2 2 Y Y/Y   RTL8721CSM Ameba CS WiFi+BLE5 Mesh M0+M4 200M 512K+4M 3 2 Y Y/Y   RTL8722CSM Ameba CS WiFi+BLE5 Mesh M0+M4 200M 512K+4M 4 2 Y Y/Y   RTL8720DN Ameba D 2.4G+5G+BLE5 M0+M4 200M 512K 2 1 Y Y/Y   RTL8721DM Ameba D 2.4G+5G+BLE5 M0+M4 200M 512K+4M 3 2 Y Y/Y   RTL8722DM Ameba D 2.4G+5G+BLE5 M0+M4 200M 512K+4M 4 2 Y Y/Y"},{"location":"docs/platform/realtek-amb/#other-chips","title":"Other chips","text":"<ul> <li>RTL8195AM</li> <li>RTL8710AF (found in amb1_arduino)</li> <li>RTL8711AM</li> <li>RTL8710BN</li> <li>RTL8710BX (found in Tuya product pages)</li> <li>RTL8710B? (found in amb1_sdk)</li> <li>RTL8711B? (found in amb1_sdk)</li> <li>RTL8710CM</li> <li>RTL8722CSM (found in ambd_arduino)</li> <li>RTL8720DN (found in ambd_arduino)</li> <li>RTL8721DM</li> <li>RTL8722DM (found in ambd_arduino)</li> </ul>"},{"location":"docs/platform/realtek-ambz/","title":"Realtek AmebaZ","text":""},{"location":"docs/platform/realtek-ambz/#resources","title":"Resources","text":"Name Notes     Realtek Ameba-Z datasheet v3.4    Ameba1/AmebaZ SDK"},{"location":"docs/platform/realtek-ambz/#realtek-documents","title":"Realtek documents","text":"Code Name       From amb1_sdk   AN0004 Realtek low power wi-fi mp user guide   AN0011 Realtek wlan simple configuration   AN0012 Realtek secure socket layer(ssl)   AN0025 Realtek at command   AN0033 Realtek Ameba-1 over the air firmware update   AN0045 Realtek Ameba-1 power modes   AN0046 Realtek Ameba uart adapter   AN0060 Realtek UART update user manual   AN0075 Realtek Ameba-all at command v2.0   AN0096 Realtek xmodem UART update user manual   AN0110 Realtek Ameba-Z over the air firmware update   AN0111 Realtek Ameba-Z FreeRTOS tickless   UM0006 Realtek wificonf application programming interface   UM0014 Realtek web server user guide   UM0023 Realtek Ameba-1 build environment setup - iar   UM0027 Realtek Ameba-1 crypto engine   UM0034 Realtek Ameba-1 memory layout   UM0039 Realtek Ameba-1 SDK quick start   UM0048 Realtek Ameba1 DEV 1v0 User Manual_1v8_20160328   UM0060 Realtek Ameba-1 mqtt user guide   UM0096 Realtek Ameba build environment setup - gcc   UM0096 Realtek Ameba-1 build environment setup - gcc   UM0101 Realtek Ameba-1 peripheral developerment user manual   UM0110 Realtek Ameba-Z build environment setup - iar   UM0111 Realtek Ameba-Z memory layout   UM0112 Realtek Ameba-Z SDK quick start   UM0113 Realtek Ameba-Z DEV 1v0 User Manual   UM0115 Realtek Ameba-Z Introduction   UM0116 Realtek Ameba-Z SDK change   UM0120 Realtek Ameba-Z User Configuration   UM0121 Realtek Ameba-Z suspend resume api   UM0123 Realtek Ameba-Z power modes"},{"location":"docs/platform/realtek-ambz/debugging/","title":"Debugging","text":"<p>Debugging of Realtek Ameba chips is possible and was tested with OpenOCD running remotely on a Raspberry Pi.</p> <p>(the following is applicable to Arduino framework, and was not tested with SDK framework)</p> <p>LibreTuya has ready-to-use OpenOCD config files:</p> <ul> <li>platform/realtek-ambz/openocd/amebaz.cfg</li> </ul>"},{"location":"docs/platform/realtek-ambz/debugging/#local-debugger","title":"Local debugger","text":"<p>It should be possible to use PlatformIO's built-in debugging capabilities directly, when plugging an OpenOCD-compatible debugger into your PC. As there are no debugger interfaces built into Tuya boards, you need to specify your interface of choice in <code>platformio.ini</code>: <pre><code>[env:my_board]\nopenocd_interface = &lt;interface name&gt;\n</code></pre> where <code>&lt;interface name&gt;</code> is for example <code>raspberrypi2-native</code>, <code>stlink</code>, etc.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#remote-debugger","title":"Remote debugger","text":"<p>Using a Raspberry Pi is probably the easiest option (and cheapest, as everyone has a spare Pi laying around).</p> <p>Connect your Realtek board to your Pi, as per Programming Microcontrollers using OpenOCD on a Raspberry Pi.</p> <p>Check out RPi BCM2711 GPIOs to read more about BCM pin mappings.</p> <p>TL;DR: Install OpenOCD. Conenct A14 to BCM GPIO#11, A15 to BCM GPIO#25. Remember to join GND together. Refer to boards/ for pinouts.</p>  <p>Note</p> <p>On Raspberry Pi 4, additional config might be needed: <pre><code>bcm2835gpio peripheral_base 0xFE000000\nbcm2835gpio speed_coeffs 236181 60\n</code></pre> Save the lines to a .cfg file, and pass it to OpenOCD using <code>-f file.cfg</code>. Read more here.</p>  <p>Start OpenOCD like this (you also need your config file in the working directory): <pre><code>sudo openocd -f interface/raspberrypi2-native.cfg -f amebaz.cfg -c \"bindto 0.0.0.0\"\n</code></pre> The bindto line is important, as it will allow remote connections.</p> <p>Configure <code>platformio.ini</code> not to start local OpenOCD: <pre><code>[env:my_board]\ndebug_tool = custom\ndebug_port = 192.168.0.33:3333\ndebug_server =\n</code></pre> Replace IP with your Pi's address.</p> <p>Done, go to PlatformIO in VSCode (or whatever you're using) and click <code>Start Debugging</code>.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#openocd-output","title":"OpenOCD output","text":"<p>OpenOCD should show this if everything is connected properly: <pre><code>alpine:~$ sudo openocd -f interface/raspberrypi2-native.cfg -f amebaz.cfg -c \"bindto 0.0.0.0\"\nOpen On-Chip Debugger 0.11.0\nLicensed under GNU GPL v2\nFor bug reports, read\n        http://openocd.org/doc/doxygen/bugs.html\nBCM2835 GPIO nums: swclk = 11, swdio = 25\n\nWarn : Interface already configured, ignoring\nInfo : Listening on port 6666 for tcl connections\nInfo : Listening on port 4444 for telnet connections\nInfo : BCM2835 GPIO JTAG/SWD bitbang driver\nInfo : clock speed 1001 kHz\nInfo : SWD DPIDR 0x2ba01477\nInfo : rtl8711b.cpu: hardware has 6 breakpoints, 4 watchpoints\nInfo : starting gdb server for rtl8711b.cpu on 3333\nInfo : Listening on port 3333 for gdb connections\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/debugging/#auto-reset","title":"Auto reset","text":"<p>PlatformIO will reset your board by default when starting debugging. Sometimes this may not be desired. Also the current config is a bit buggy: VSCode thinks the board is halt, but it's actually running so you need to press continue for that first time.</p> <p>To disable auto reset before and after debugging: <pre><code>[env:my_board]\ndebug_init_cmds =\n  target extended-remote $DEBUG_PORT ; remove this line if you're debugging locally\n  $INIT_BREAK\n;   monitor reset halt\n  $LOAD_CMDS\n  monitor init\n;   monitor reset halt\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/debugging/#technical-details","title":"Technical details","text":"<p>GDB is first configured with <code>mem 0x8000000 0x8200000 ro</code> in order to mark flash memory as read-only. This makes GDB use hardware breakpoints, as software BPs don't work on these boards.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#more-powerful-playground","title":"More powerful playground","text":"<pre><code>Microsoft Windows [Version 6.1.7601]\n\nKuba@KUBA-PC C:\\Users\\Kuba\n# telnet 192.168.0.33 4444\nOpen On-Chip Debugger\n&gt; mdw 0x8000000\n0x08000000: 96969999\n\n&gt; halt\ntarget halted due to debug-request, current mode: Thread\nxPSR: 0x61000000 pc: 0x0000b462 msp: 0x1003ef5c\n&gt; reg\n===== arm v7m registers\n(0) r0 (/32): 0x035a9584\n(1) r1 (/32): 0x00000015\n[...]\n===== Cortex-M DWT registers\n\n&gt; resume\n&gt;\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#useful-openocd-commands","title":"Useful OpenOCD commands","text":"<p>Run them in your power playground.</p>"},{"location":"docs/platform/realtek-ambz/debugging/#soft-reset","title":"Soft reset","text":"<p>Doesn't even disconnect from WiFi (which confuses the code and makes it disconnect anyway). <pre><code>mww 0xE000ED0C 0x05FA0007\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/debugging/#uart-upload-mode","title":"UART upload mode","text":"<pre><code>mww 0x40000138 0x8\nmww 0xE000ED0C 0x05FA0007\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#hard-fault","title":"Hard Fault","text":"<pre><code>halt\nreg pc 0\nresume\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#rom-dump","title":"ROM dump","text":"<pre><code>&gt; dump_image rom2.bin 0x0 0x80000\ndumped 524288 bytes in 14.041406s (36.464 KiB/s)\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#flash-dump","title":"Flash dump","text":"<pre><code>&gt; dump_image flash.bin 0x8000000 0x200000\ndumped 2097152 bytes in 54.447296s (37.614 KiB/s)\n</code></pre>"},{"location":"docs/platform/realtek-ambz/debugging/#efuse-dump","title":"Efuse dump","text":"<p>(or something that looks like it) <pre><code>&gt; dump_image efuse.bin 0x40000000 0x400\ndumped 1024 bytes in 0.026813s (37.295 KiB/s)\n</code></pre></p>"},{"location":"docs/platform/realtek-ambz/exception-decoder/","title":"Exception decoder","text":"<p>Configure built-in hard fault decoder in <code>platformio.ini</code>:</p> <pre><code>[env:my_board]\nmonitor_speed = 115200\nmonitor_filters = rtl_hard_fault_decoder\n</code></pre>"},{"location":"docs/platform/realtek-ambz/flashing/","title":"Download mode - Realtek AmebaZ","text":"<p>Read chip docs</p>  <p>Downloading is done using UART2 (sometimes called Log_UART). Refer to your board documentation to find the correct pins. You need a good USB&lt;-&gt;UART adapter (preferably a real FT232RL) for the process.</p> <p>Read Using ltchiptool to learn the flashing procedure</p>  <p>Wiring</p> <p>Connect UART2 of the Realtek chip to the USB-TTL adapter:</p>    PC RTL8710B     RX TX2 (Log_TX / PA30)   TX RX2 (Log_RX / PA29)   RTS CEN (or RST, optional)   DTR TX2 (Log_TX / PA30, optional)   GND GND    <p>Make sure to use a good 3.3V power supply, otherwise the adapter might lose power during chip reset. Usually, the adapter's power regulator is not enough and an external power supply is needed (like AMS1117).</p> <p>If you didn't connect RTS and DTR, you need to put the chip in download mode manually. This is done by connecting CEN to GND, while holding TX2 (Log_TX) to GND as well. After doing that, you need to disconnect TX2 from GND.</p> <p>If the download mode is enabled, you'll see a few garbage characters printed to the serial console every second.</p>   <p>Tip</p> <p>Because the UART uploading code is programmed in the ROM of the chip, it can't be software-bricked, even if you damage the bootloader.</p>"},{"location":"docs/platform/realtek-ambz/flashing/#firmware-output-files","title":"Firmware output files","text":"<p>These files are present in the build directory after successful compilation:</p>    File Description     firmware.uf2 UF2 package for UART and OTA upload   image_0x00B000.ota1.bin OTA 1 image, flashable to 0xB000   image_0x0D0000.ota2.bin OTA 2 image, flashable to 0xD0000 (the address might be different)"},{"location":"docs/platform/realtek-ambz/flashing/#other-toolsguides","title":"Other tools/guides","text":"<p>These tools are not recommended and are kept here for reference only. Don't use them, please.</p> <ul> <li>Flashing (Tuya manual)</li> <li>ImageTool (AmebaZ/AmebaD)</li> <li>rtltool.py</li> </ul> <p>OTA1/2 files can be flashed using <code>ImageTool_v2.3.1_AmebaZ(8710b)</code>. Browse and select one of the files and enter an appropriate address. Select COM port, press <code>Open</code> and then <code>Download</code>.</p> <p>This method is not recommended, as it requires you to know the currently enabled OTA index (1 or 2). Flashing the wrong file will either not make any changes, or upload firmware which won't run.</p>"},{"location":"docs/platform/realtek-ambz/memory-management/","title":"Memory management","text":"Function Target #define location Notes     <code>malloc</code> <code>pvPortMalloc</code> <code>component/common/api/platform/platform_stdlib.h</code>    <code>zalloc</code> <code>os_zalloc</code> (ROM)  This is PROBABLY BROKEN. ROM disassembly shows it only does memset on a fixed memory range.   <code>zalloc</code> <code>pvPortZalloc</code> <code>arduino/realtek-ambz/cores/WVariant.h</code> Custom implementation in <code>rtl_sys.cpp</code>   <code>calloc</code> <code>os_calloc</code> ? This one is not in ROM. I didn't dig any deeper into it.   <code>calloc</code> <code>calloc_freertos</code> <code>component/os/freertos/cmsis_os.h</code> Probably not used   <code>calloc</code> <code>__rtl_calloc_r</code> (ROM)  Not used, as I preferred to use FreeRTOS memory management.   <code>calloc</code> <code>pvPortCalloc</code> <code>arduino/realtek-ambz/cores/WVariant.h</code> Custom implementation in <code>rtl_sys.cpp</code>   <code>realloc</code> <code>pvPortRealloc</code> <code>arduino/realtek-ambz/cores/WVariant.h</code>    <code>free</code> <code>vPortFree</code> <code>component/common/api/platform/platform_stdlib.h</code>     <p>Underlined item means that it is defined and used in code.</p>"},{"location":"docs/platform/realtek-ambz/stdlib/","title":"C library","text":"<p>The following is an auto-generated list of C standard library definitions included in the SDK. <code>Location</code> column contains the location of a matching symbol.</p>"},{"location":"docs/platform/realtek-ambz/stdlib/#ctypeh","title":"ctype.h","text":""},{"location":"docs/platform/realtek-ambz/stdlib/#character-classification-functions","title":"Character classification functions","text":"Definition Value Location     <code>isalnum</code>     <code>isalpha</code>     <code>isblank</code>     <code>iscntrl</code>     <code>isdigit</code> <code>in_range</code>    <code>isgraph</code>     <code>islower</code> <code>in_range</code>    <code>isprint</code> <code>in_range</code>    <code>ispunct</code>     <code>isspace</code>     <code>isupper</code>     <code>isxdigit</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#stdargh","title":"stdarg.h","text":"Definition Value Location     <code>va_start</code> <code>__builtin_va_start</code>    <code>va_arg</code> <code>__builtin_va_arg</code>    <code>va_end</code> <code>__builtin_va_end</code>    <code>va_copy</code> <code>__builtin_va_copy</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#stddefh","title":"stddef.h","text":"Definition Value Location     <code>ptrdiff_t</code> <code>long int</code>    <code>size_t</code> <code>long unsigned int</code>    <code>max_align_t</code>     <code>nullptr_t</code>     <code>NULL</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#stdinth","title":"stdint.h","text":""},{"location":"docs/platform/realtek-ambz/stdlib/#types","title":"Types","text":"Definition Value Location     <code>intmax_t</code> <code>long int</code>    <code>uintmax_t</code> <code>long unsigned int</code>    <code>int8_t</code> <code>signed char</code>    <code>uint8_t</code> <code>unsigned char</code>    <code>int16_t</code> <code>short int</code>    <code>uint16_t</code> <code>short unsigned int</code>    <code>int32_t</code> <code>int</code>    <code>uint32_t</code> <code>unsigned int</code>    <code>int64_t</code> <code>long int</code>    <code>uint64_t</code> <code>long unsigned int</code>    <code>int_least8_t</code> <code>signed char</code>    <code>uint_least8_t</code> <code>unsigned char</code>    <code>int_least16_t</code> <code>short int</code>    <code>uint_least16_t</code> <code>short unsigned int</code>    <code>int_least32_t</code> <code>int</code>    <code>uint_least32_t</code> <code>unsigned int</code>    <code>int_least64_t</code> <code>long int</code>    <code>uint_least64_t</code> <code>long unsigned int</code>    <code>int_fast8_t</code> <code>signed char</code>    <code>uint_fast8_t</code> <code>unsigned char</code>    <code>int_fast16_t</code> <code>long int</code>    <code>uint_fast16_t</code> <code>long unsigned int</code>    <code>int_fast32_t</code> <code>long int</code>    <code>uint_fast32_t</code> <code>long unsigned int</code>    <code>int_fast64_t</code> <code>long int</code>    <code>uint_fast64_t</code> <code>long unsigned int</code>    <code>intptr_t</code> <code>long int</code>    <code>uintptr_t</code> <code>long unsigned int</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#stdioh","title":"stdio.h","text":""},{"location":"docs/platform/realtek-ambz/stdlib/#formatted-inputoutput","title":"Formatted input/output","text":"Definition Value Location     <code>fprintf</code>     <code>fscanf</code>     <code>printf</code> <code>rtl_printf</code> <code>lib_rtlstd.a</code>   <code>scanf</code>     <code>snprintf</code> <code>rtl_snprintf</code> <code>lib_rtlstd.a</code>   <code>sprintf</code> <code>rtl_sprintf</code> <code>lib_rtlstd.a</code>   <code>sscanf</code> <code>_sscanf_patch</code> <code>lib_platform.a</code>   <code>vfprintf</code>     <code>vfscanf</code>     <code>vprintf</code>     <code>vscanf</code>     <code>vsnprintf</code> <code>rtl_vsnprintf</code> <code>lib_rtlstd.a</code>   <code>vsprintf</code>     <code>vsscanf</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#error-handling","title":"Error-handling","text":"Definition Value Location     <code>clearerr</code> <code>__sclearerr</code>    <code>feof</code> <code>__sfeof</code>    <code>ferror</code> <code>__sferror</code>    <code>perror</code>  <code>lib_mdns.a</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#stdlibh","title":"stdlib.h","text":""},{"location":"docs/platform/realtek-ambz/stdlib/#string-conversion","title":"String conversion","text":"Definition Value Location     <code>atof</code>     <code>atoi</code> <code>prvAtoi</code> ROM   <code>atol</code> <code>simple_strtol</code> ROM   <code>atoll</code>     <code>strtod</code>     <code>strtof</code>     <code>strtol</code> <code>simple_strtol</code> ROM   <code>strtold</code>     <code>strtoll</code>     <code>strtoul</code> <code>simple_strtoul</code> ROM   <code>strtoull</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#pseudo-random-sequence-generation","title":"Pseudo-random sequence generation","text":"Definition Value Location     <code>rand</code> <code>Rand</code> ROM   <code>srand</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#dynamic-memory-management","title":"Dynamic memory management","text":"Definition Value Location     <code>calloc</code>     <code>free</code> <code>vPortFree</code> SDK   <code>malloc</code> <code>pvPortMalloc</code> SDK   <code>realloc</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#stringh","title":"string.h","text":""},{"location":"docs/platform/realtek-ambz/stdlib/#copying","title":"Copying","text":"Definition Value Location     <code>memcpy</code> <code>_memcpy</code> ROM   <code>memmove</code> <code>__rtl_memmove_v1_00</code> ROM   <code>strcpy</code> <code>_strcpy</code> ROM   <code>strncpy</code> <code>_strncpy</code> ROM"},{"location":"docs/platform/realtek-ambz/stdlib/#concatenation","title":"Concatenation","text":"Definition Value Location     <code>strcat</code> <code>__rtl_strcat_v1_00</code> ROM   <code>strncat</code> <code>__rtl_strncat_v1_00</code> ROM"},{"location":"docs/platform/realtek-ambz/stdlib/#comparison","title":"Comparison","text":"Definition Value Location     <code>memcmp</code> <code>_memcmp</code> ROM   <code>strcmp</code> <code>prvStrCmp</code> ROM   <code>strcoll</code>     <code>strncmp</code> <code>_strncmp</code> ROM   <code>strxfrm</code>"},{"location":"docs/platform/realtek-ambz/stdlib/#searching","title":"Searching","text":"Definition Value Location     <code>memchr</code> <code>__rtl_memchr_v1_00</code> ROM   <code>strchr</code> <code>_strchr</code> ROM   <code>strcspn</code>     <code>strpbrk</code> <code>_strpbrk</code> ROM   <code>strrchr</code>     <code>strspn</code>     <code>strstr</code> <code>prvStrStr</code> ROM   <code>strtok</code> <code>prvStrtok</code> ROM"},{"location":"docs/platform/realtek-ambz/stdlib/#other","title":"Other","text":"Definition Value Location     <code>memset</code> <code>_memset</code> ROM   <code>strerror</code>     <code>strlen</code> <code>prvStrLen</code> ROM"},{"location":"docs/projects/esphome/","title":"ESPHome","text":"<p>Because ESPHome does not natively support running on non-ESP chips, you need to use a fork of the project.</p> <p>There are two basic ways to install and use LibreTuya-ESPHome. You can choose the option that best suits you:</p> <ul> <li>command line (CLI) - for more experienced users; compilation using CLI commands, somewhat easier to troubleshoot</li> <li>ESPHome Dashboard (GUI) - for new users, might be an easy way to go; config management &amp; compilation using web-based dashboard</li> </ul>  <p>Tip</p> <p>You can use LibreTuya-ESPHome for ESP32/ESP8266 compilation as well - the forked version extends the base, and doesn't remove any existing features. Keep in mind that you might not have latest ESPHome updates until the fork gets updated (which usually happens at most every few weeks).</p>"},{"location":"docs/projects/esphome/#find-your-devices-board","title":"Find your device's board","text":"<p>Go to Boards &amp; CPU list, find your board (chip model), click on it and remember the <code>Board code</code>. This will be used later, during config creation.</p> <p>If your board isn't listed, use one of the Generic boards, depending on the chip type of your device.</p>"},{"location":"docs/projects/esphome/#download-esphome","title":"Download ESPHome","text":"CLIGUI    <p>Important</p> <p>Read Getting started first - most importantly, the first part about installation.</p> <p>It is very important that you have the latest version of LibreTuya installed (not <code>libretuya-esphome</code> - this is a different thing!) so that you don't face issues that are already resolved.</p>  <p>Assuming you have PlatformIO, git and Python installed:</p> <ol> <li>Open a terminal/cmd.exe, create <code>esphome</code> directory and <code>cd</code> into it.</li> <li><code>git clone https://github.com/kuba2k2/libretuya-esphome</code></li> <li><code>cd</code> into the newly created <code>libretuya-esphome</code> directory.</li> <li>Check if it works by typing <code>python -m esphome</code></li> </ol>  <p>Tip</p> <p>For Linux users (or if <code>python -m esphome</code> doesn't work for you):</p> <ul> <li>uninstall ESPHome first: <code>pip uninstall esphome</code></li> <li>install the forked version: <code>pip install -e .</code></li> </ul>    <p>For this, you need Docker, Docker Compose and Python installed. After running the commands, you'll have a running ESPHome Dashboard interface that you can connect to.</p> <ol> <li><code>git clone https://github.com/kuba2k2/libretuya-esphome</code> (or download the .ZIP and unpack it, not recommended)</li> <li>Open a terminal/cmd.exe in the cloned directory (<code>libretuya-esphome</code>).</li> <li><code>python docker/build.py --tag libretuya --arch amd64 --build-type docker build</code> - this will build the Docker image of ESPHome. Change <code>amd64</code> to something else if you're using a Raspberry Pi.</li> <li> <p>Create a <code>docker-compose.yml</code> file in the same directory:</p> docker-compose.yml<pre><code>version: \"3\"\nservices:\n  esphome:\n    container_name: esphome-libretuya\n    image: esphome/esphome-amd64:libretuya # (2)!\n    volumes:\n      - ./configs:/config:rw # (1)!\n      - /etc/localtime:/etc/localtime:ro\n    restart: always\n    privileged: false\n    network_mode: host\n</code></pre> <ol> <li>You can change <code>./configs</code> to another path, in which your ESPHome configs will be stored.</li> <li>Ensure the architecture (<code>amd64</code>) matches the one you selected in step 3.</li> </ol> </li> <li> <p>Start the container - <code>docker-compose up</code>. You should be able to open the GUI on http://localhost:6052/.</p> </li> </ol>"},{"location":"docs/projects/esphome/#create-your-device-config","title":"Create your device config","text":"CLIGUI   <ol> <li>Create a YAML config file for your device. You can either:<ul> <li>use <code>python -m esphome wizard yourdevice.yml</code> - type answers to the six questions the wizard asks, OR:</li> <li>write a config file manually:     yourdevice.yml<pre><code>esphome:\n  name: yourdevice\n\nlibretuya:\n  board: wr3  # THIS IS YOUR BOARD CODE\n  framework:\n    version: latest\n\nlogger:\napi:\n  password: \"\"\nota:\n  password: \"\"\n\nwifi:\n  ssid: \"YourWiFiSSID\"\n  password: \"SecretPa$$w0rd\"\n  ap:\n    ssid: \"Yourdevice Fallback Hotspot\"\n    password: \"Dv2hZMGZRUvy\"\n</code></pre></li> </ul> </li> </ol>   <ol> <li>Open the GUI on http://localhost:6052/ (or a different IP address if you're running on a Pi).</li> <li>Go through the wizard steps:<ul> <li><code>New Device</code></li> <li><code>Continue</code></li> <li>enter name and WiFi details</li> <li>choose <code>LibreTuya</code></li> <li>choose the board that you found before</li> <li>select <code>Skip</code></li> </ul> </li> <li>A new config file will be added. Press <code>Edit</code> and proceed to the next section.</li> </ol>"},{"location":"docs/projects/esphome/#add-components","title":"Add components","text":"<p>Now, just like with standard ESPHome on ESP32/ESP8266, you need to add components for your device. Visit ESPHome homepage to learn about YAML configuration. If you want, you can upload an \"empty\" config first, and add actual components later.</p>  <p>Important</p> <p>It's highly recommended to always include the <code>web_server</code> and <code>captive_portal</code> components - even in your first \"empty\" upload.</p> <p>Adding these two components will safeguard you against accidentally soft-bricking the device, by e.g. entering invalid Wi-Fi credentials. The Web Server provides an easy way to flash a new image over-the-air, and the Captive Portal allows to easily open the Web Server on a fallback AP.</p>"},{"location":"docs/projects/esphome/#build-upload","title":"Build &amp; upload","text":"CLIGUI   <p>The command <code>python -m esphome compile yourdevice.yml</code> will compile ESPHome.</p>   <p>Close the config editor. Press the three dots icon and select <code>Install</code>. Choose <code>Manual download</code> and <code>Modern format</code>. The firmware will be compiled and a UF2 file will be downloaded automatically.</p>    <p>Now, refer to the flashing guide to learn how to upload ESPHome to your device. There's also info on using <code>tuya-cloudcutter</code> in that guide.</p>"},{"location":"docs/projects/esphome/#advanced-lt-configuration","title":"Advanced: LT configuration","text":"<p>Note</p> <p>This part is for advanced users. You'll probably be fine with the default options.</p>  <p>All options from Options &amp; config can be customized in the <code>libretuya:</code> block:</p> <p>yourdevice.yml<pre><code>libretuya:\n  framework:\n    version: latest\n  lt_config:\n    LT_LOG_HEAP: 1\n    LT_UART_DEFAULT_PORT: 2\n    LT_UART_SILENT_ALL: 0\n</code></pre> (this is only an example)</p> <p>Additionally, few options have their dedicated keys:</p> <p>yourdevice.yml<pre><code>libretuya:\n  framework:\n    version: latest\n  # verbose/trace/debug/info/warn/error/fatal\n  loglevel: warn\n  # suppress chip's SDK log messages\n  # (same as LT_UART_SILENT_ALL above)\n  sdk_silent: true\n  # disable SWD/JTAG so that all GPIOs can be used\n  # set to false if you want to attach a debugger\n  gpio_recover: true\n</code></pre> (these values are defaults)</p>"},{"location":"docs/reference/config/","title":"Configuration","text":""},{"location":"docs/reference/config/#project-options","title":"Project options","text":"platformio.ini<pre><code>[env:my_board]\n# custom firmware name, present in UF2 output files\n# - default: project directory name\ncustom_fw_name = my_firmware\n# custom firmware version\n# - default: current date in yy.mm.dd format\ncustom_fw_version = 1.2.0\n</code></pre>"},{"location":"docs/reference/config/#libretuya-options","title":"LibreTuya options","text":"<p>Note</p> <p>See LibreTuyaConfig.h for most options and their defaults.</p>  <p>All options are configurable via C++ defines in PlatformIO project file. For example: platformio.ini<pre><code>[env:my_board]\nbuild_flags =\n  -D LT_LOGLEVEL=LT_LEVEL_DEBUG\n</code></pre></p>  <p>Tip</p> <p>Values in parentheses represent the defaults for the config options.</p>"},{"location":"docs/reference/config/#logger","title":"Logger","text":"<ul> <li><code>LT_LOGGER</code> (1) - enable/disable LibreTuya logger globally; disabling this sets the loglevel to <code>LT_LEVEL_NONE</code> - the logger can't be enabled even by using <code>lt_log_set_port()</code></li> <li><code>LT_LOGLEVEL</code> - global LT loglevel:</li> <li><code>LT_LEVEL_VERBOSE</code></li> <li><code>LT_LEVEL_TRACE</code> - same as <code>LT_LEVEL_VERBOSE</code></li> <li><code>LT_LEVEL_DEBUG</code></li> <li><code>LT_LEVEL_INFO</code> - default</li> <li><code>LT_LEVEL_WARN</code></li> <li><code>LT_LEVEL_ERROR</code></li> <li><code>LT_LEVEL_FATAL</code></li> <li><code>LT_LEVEL_NONE</code> - disables everything</li> <li><code>LT_LOGGER_TIMESTAMP</code> (1) - print program runtime in printk-like format</li> <li><code>LT_LOGGER_CALLER</code> (1) - print calling method name</li> <li><code>LT_LOGGER_TASK</code> (1) - print calling FreeRTOS task (if available)</li> <li><code>LT_LOGGER_COLOR</code> (0) - output ANSI terminal colors</li> <li><code>LT_PRINTF_BROKEN</code> (0) - whether printf outputs \"0.\" for floats with value 0</li> <li><code>LT_LOG_HEAP</code> (0) - print free heap size using <code>LT_HEAP_I()</code>, and periodically every 1000 ms</li> <li><code>LT_LOG_ERRNO</code> (0) - print and clear errno value (if set) using <code>LT_ERRNO()</code></li> </ul>"},{"location":"docs/reference/config/#per-module-logging-debugging","title":"Per-module logging &amp; debugging","text":"<p>The following options enable library-specific logging output. They are effective for all loglevels - i.e. disabling <code>LT_DEBUG_WIFI</code> will disable WiFi debug messages, as well as errors.</p> <p>To see debug messages from i.e. OTA, loglevel must also be changed.</p> <ul> <li><code>LT_DEBUG_ALL</code> (0) - enable all following options by default (except for FDB and LWIP)</li> <li><code>LT_DEBUG_WIFI</code> (1) - WiFi (generic, STA, AP, scan, events, etc.)</li> <li><code>LT_DEBUG_CLIENT</code> (0) - TCP client</li> <li><code>LT_DEBUG_SERVER</code> (0) - TCP server</li> <li><code>LT_DEBUG_SSL</code> (0) - SSL clients</li> <li><code>LT_DEBUG_OTA</code> (1) - OTA updates (<code>Update</code> library)</li> <li><code>LT_DEBUG_FDB</code> (0) - FlashDB debugging (macros within the library)</li> <li><code>LT_DEBUG_MDNS</code> (0) - mDNS client library</li> <li><code>LT_DEBUG_LWIP</code> (0) - enables <code>LWIP_DEBUG</code>, provides <code>LWIP_PLATFORM_DIAG</code>; per-module options (i.e. <code>TCP_DEBUG</code>) are off by default and need to be enabled separately</li> <li><code>LT_DEBUG_LWIP_ASSERT</code> (0) - enables assertions within lwIP (doesn't need <code>LT_DEBUG_LWIP</code>)</li> </ul>  <p>Tip</p> <p>Enabling <code>LT_DEBUG_ALL</code> doesn't mean that every debugging message will be printed. If loglevel is i.e. <code>WARN</code>, debug messages won't be visible anyway.</p> <p>This can be used, for example, to enable only \"important\" messages: platformio.ini<pre><code>[env:my_board]\nbuild_flags =\n  -D LT_LOGLEVEL=LT_LEVEL_WARN\n  -D LT_DEBUG_ALL=1 # will print only warnings and errors from all modules\n</code></pre></p>"},{"location":"docs/reference/config/#serial-output","title":"Serial output","text":"<p>Options for controlling default UART log output.</p> <ul> <li><code>LT_UART_DEFAULT_PORT</code> (unset) - default output port for all messages (SDK, LT logger, Serial class); can be 0, 1 or 2</li> <li><code>LT_UART_DEFAULT_LOGGER</code> (unset) - override default output port for LT logger only</li> <li><code>LT_UART_DEFAULT_SERIAL</code> (unset) - override default output port for <code>Serial</code> class (without a number)</li> <li><code>LT_UART_SILENT_ENABLED</code> (1) - enable auto-silencing of SDK \"loggers\"; this makes the serial output much more readable, but can hide some error messages</li> <li><code>LT_UART_SILENT_ALL</code> (0) - disable all SDK output (LT output and logger still work)</li> </ul>  <p>Info</p> <p>Values 0, 1 and 2 correspond to physical UART port numbers (refer to board pinout for the available ports).</p> <p>Serial class instances (<code>Serial0</code>, <code>Serial1</code>, <code>Serial2</code>) use the respective port numbers for printing.</p> <p>If <code>LT_UART_DEFAULT_LOGGER</code> is not set, it is chosen by the family code - whichever port is most appropriate (i.e. LOG_UART (2) on Realtek, RX2/TX2 on Beken).</p>"},{"location":"docs/reference/config/#misc-options","title":"Misc options","text":"<ul> <li><code>LT_USE_TIME</code> (0) - enables implementation of <code>gettimeofday()</code> and <code>settimeofday()</code>; checks for <code>millis()</code> overflows periodically</li> <li><code>LT_MICROS_HIGH_RES</code> (1) - count runtime microseconds using a high-resolution timer; disable if your application doesn't need <code>micros()</code></li> <li><code>LT_AUTO_DOWNLOAD_REBOOT</code> (1) - automatically reboot into \"download mode\" after detecting a flashing protocol command; read more</li> </ul>"},{"location":"docs/reference/config/#family-feature-config","title":"Family feature config","text":"<p>Warning</p> <p>These options are not meant for end-users. They're provided here as a reference for developers.</p>  <p>These options are selectively set by all families, as part of the build process. They are used for enabling LT core API parts, if the family has support for it.</p> <p>The <code>LT_ARD_*</code> options are only used with Arduino frameworks.</p> <p>The meaning of most flags is as follows:</p> <ul> <li><code>LT_HAS_LWIP</code> - LwIP in SDK (any version)</li> <li><code>LT_HAS_LWIP2</code> - LwIP v2.0.0 or newer</li> <li><code>LT_HAS_FREERTOS</code> - FreeRTOS supported and used</li> <li><code>LT_HAS_MBEDTLS</code> - mbedTLS in SDK</li> <li><code>LT_ARD_HAS_MD5</code> - MD5 library implemented, <code>MD5Impl.h</code> available</li> <li><code>LT_ARD_HAS_WIFI</code> - WiFi library implemented, <code>WiFiData.h</code> available</li> <li><code>LT_ARD_HAS_SOFTSERIAL</code> - SoftwareSerial library implemented, <code>SoftwareSerial.h</code> available</li> <li><code>LT_HEAP_FUNC</code> - function name used to get available heap size (for <code>LT_HEAP_I()</code>)</li> </ul>"},{"location":"docs/reference/lt-api/","title":"LibreTuya API","text":""},{"location":"docs/reference/lt-api/#class-functions","title":"Class functions","text":"<p>Main LibreTuya API class.</p>   <p>This class contains all functions common amongst all families. Implementations of these methods may vary between families.</p> <p>The class is accessible using the <code>LT</code> global object (defined by the family). </p>      Type Name     const char * getBoard () Get board name.   const char * getChipCoreType () Get CPU core type name as string.   uint8_t getChipCores () Get CPU core count.   ChipFamily getChipFamily () Get CPU family ID.   const char * getChipFamilyName () Get CPU family name as string.   uint32_t getChipId () Get CPU unique ID. This may be based on MAC, eFuse, etc. Note: the number should be 24-bit (with most significant byte being zero).   const char * getChipModel () Get CPU model name as string.   ChipType getChipType () Get CPU model ID.   uint32_t getCpuFreq () Get CPU frequency in Hz.   uint32_t getCpuFreqMHz () Get CPU frequency in MHz.   uint32_t getCycleCount () Get CPU cycle count.   const char * getDeviceName () Get device friendly name in format \"LT-&lt;board&gt;-&lt;chip id&gt;\". Can be used as hostname.   FlashId getFlashChipId () Read flash chip ID and return a FlashId struct.   uint32_t getFlashChipSize ()    uint32_t getFreeHeap () Get free heap size.   uint32_t getHeapSize () Get total heap size.   uint32_t getMaxAllocHeap () Get largest block of heap that can be allocated at once.   uint32_t getMaxFreeBlockSize () Alias of getMaxAllocHeap() .   uint32_t getMinFreeHeap () Get lowest level of free heap memory.   uint32_t getRamSize () Get total RAM size.   ResetReason getResetReason () Get the reason of last chip reset.   const char * getResetReasonName (ResetReason reason=RESET_REASON_MAX) Get a textual representation of a reset reason.   const char * getVersion () Get LibreTuya version string.   void gpioRecover () Reconfigure GPIO pins used for debugging (SWD/JTAG), so that they can be used as normal I/O.   bool otaCanRollback () Check if OTA rollback is supported and available (there is another image to run).   uint8_t otaGetRunning () Get the currently running firmware OTA index.   uint8_t otaGetStoredIndex () Read the currently active OTA index, i.e. the one that will boot upon restart.   uint8_t otaGetTarget () Get the OTA index for updated firmware.   bool otaHasImage1 () Check if OTA1 image is valid.   bool otaHasImage2 () Check if OTA2 image is valid.   bool otaRollback () Perform OTA rollback: switch to the previous image, or abort current switched OTA update, if not rebooted yet.   bool otaSupportsDual () Check if the chip supports dual-OTA (i.e. OTA is flashed to a different partition).   bool otaSwitch (bool force=false) Try to switch OTA index to the other image.   void restart () Reboot the CPU.   void restartDownloadMode () Reboot the CPU and stay in download mode (if possible).   void wdtDisable () Disable the hardware watchdog.   bool wdtEnable (uint32_t timeout=10000) Enable the hardware watchdog.   void wdtFeed () Feed/reset the hardware watchdog timer."},{"location":"docs/reference/lt-api/#common-methods","title":"Common methods","text":"Type Name     void hexdump (const uint8_t * buf, size_t len, uint32_t offset=0, uint8_t width=16) Print data pointed to by buf in hexdump-like format (hex+ASCII).   String ipToString (const IPAddress &amp; ip)    void lt_rand_bytes (uint8_t * buf, size_t len) Generate random bytes using rand()."},{"location":"docs/reference/lt-api/#macros","title":"Macros","text":"Type Name     define LT_BANNER ()    define LT_BOARD  unknown   define LT_BOARD_STR  STRINGIFY_MACRO(LT_BOARD)   define LT_VERSION  1.0.0   define LT_VERSION_STR  STRINGIFY_MACRO(LT_VERSION)   define STRINGIFY (x) #x   define STRINGIFY_MACRO (x) STRINGIFY(x)"},{"location":"docs/reference/lt-api/#wiring-custom-methods","title":"Wiring custom methods","text":"Type Name     int analogRead (pin_size_t pinNumber) Read voltage from ADC and return a value between 0 and the current reading resolution.   uint16_t analogReadMaxVoltage (pin_size_t pinNumber) Get max reading voltage for the specified pin (millivolts).   void analogReadResolution (int res) Set resolution of values (in bits) returned by analogRead(). Defaults to 10 bit (0-1023).   uint16_t analogReadVoltage (pin_size_t pinNumber) Read voltage from analog input (in millivolts).   void analogWriteFrequency (int hz) Set PWM output frequency (in Hz). Defaults to 50 Hz (20,000 uS).   void analogWritePeriod (int us) Set PWM output frequency (cycle period) in microseconds. Defaults to 20,000 uS (50 Hz).   void analogWriteResolution (int res) Set resolution of values (in bits) expected by analogWrite(). Defaults to 8 bit (0-255).   void mainTask (const void * arg) Main setup() and loop() task. Not to be called directly.   bool pinEnabled (PinInfo * pin, uint32_t mask) Check if pin has all features represented by 'mask' enabled.   PinInfo * pinInfo (pin_size_t pinNumber) Get PinInfo struct for the specified number. Returns NULL if pin number is invalid.   bool pinInvalid (pin_size_t pinNumber) Check if pin is invalid (too low or too high).   bool pinIsInput (PinInfo * pin) Check if GPIO pin is configured as output.   bool pinIsOutput (PinInfo * pin) Check if GPIO pin is configured as output.   bool pinSupported (PinInfo * pin, uint32_t mask) Check if pin supports all features represented by 'mask'.   void runPeriodicTasks () Run periodic tasks, like printing free heap or checking millis() overflow.   bool startMainTask () Run mainTask &amp; start OS kernel (family-defined). Return false if an error occured; else do not return and and keep the OS kernel running."},{"location":"docs/reference/lt-api/#logger","title":"Logger","text":"Type Name     void lt_log (const uint8_t level, const char * format, ...)    void lt_log_disable () Disable LT logger. Enable it back using lt_log_set_port(LT_UART_DEFAULT_LOGGER).   void void lt_log_set_port (uint8_t port) Change log output port."},{"location":"docs/reference/lt-api/#macros_1","title":"Macros","text":"Type Name     define ESP_EARLY_LOGD (...) LT_D(__VA_ARGS__)   define ESP_EARLY_LOGE (...) LT_E(__VA_ARGS__)   define ESP_EARLY_LOGI (...) LT_I(__VA_ARGS__)   define ESP_EARLY_LOGV (...) LT_V(__VA_ARGS__)   define ESP_EARLY_LOGW (...) LT_W(__VA_ARGS__)   define ESP_LOGD (...) LT_D(__VA_ARGS__)   define ESP_LOGE (...) LT_E(__VA_ARGS__)   define ESP_LOGI (...) LT_I(__VA_ARGS__)   define ESP_LOGV (...) LT_V(__VA_ARGS__)   define ESP_LOGW (...) LT_W(__VA_ARGS__)   define ETS_PRINTF (...) LT_I(__VA_ARGS__)   define LT_D (...)    define LT_DM (...)    define LT_E (...) LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_EM (module, ...) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_ERRNO ()    define LT_ERRNO_LEZ (ret)    define LT_ERRNO_LZ (ret)    define LT_ERRNO_NZ (ret)    define LT_F (...) LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_FM (module, ...) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_HEAP_I ()    define LT_I (...) LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_IM (module, ...) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_LOG (level, caller, line, ...) lt_log(level, __VA_ARGS__)   define LT_LOGM (level, module, caller, line, ...)    define LT_RET (ret)    define LT_RET_LEZ (ret)    define LT_RET_LZ (ret)    define LT_RET_NZ (ret)    define LT_T (...)    define LT_TM (...)    define LT_V (...)    define LT_VM (...)    define LT_W (...) LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_WM (module, ...) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define ets_printf (...) LT_I(__VA_ARGS__)   define isr_log_d (...) LT_D(__VA_ARGS__)   define isr_log_e (...) LT_E(__VA_ARGS__)   define isr_log_i (...) LT_I(__VA_ARGS__)   define isr_log_n (...) LT_E(__VA_ARGS__)   define isr_log_v (...) LT_V(__VA_ARGS__)   define isr_log_w (...) LT_W(__VA_ARGS__)   define log_d (...) LT_D(__VA_ARGS__)   define log_e (...) LT_E(__VA_ARGS__)   define log_i (...) LT_I(__VA_ARGS__)   define log_n (...) LT_E(__VA_ARGS__)   define log_printf (...) LT_I(__VA_ARGS__)   define log_v (...) LT_V(__VA_ARGS__)   define log_w (...) LT_W(__VA_ARGS__)"},{"location":"docs/reference/project-structure/","title":"Project structure","text":"<pre><code>arduino/\n\u251c\u2500 &lt;family name&gt;/               Arduino Core for a specific SoC family\n\u2502  \u251c\u2500 cores/                        Wiring core files\n\u2502  \u251c\u2500 libraries/                    Supported built-in family libraries\n\u2502  \u251c\u2500 port/                     External library port units\n\u251c\u2500 libretuya/\n\u2502  \u251c\u2500 api/                      Library interfaces\n\u2502  \u251c\u2500 common/                   Units common to all families\n\u2502  \u251c\u2500 compat/                   Fixes for compatibility with ESP32 framework\n\u2502  \u251c\u2500 core/                     LibreTuya API for Arduino cores\n\u2502  \u251c\u2500 libraries/                Built-in family-independent libraries\n|  \u251c\u2500 port/                     External library port units\n|  \u251c\u2500 posix/                    POSIX-like C utility functions\nboards/\n\u251c\u2500 _base/                       Base board manifests\n\u251c\u2500 &lt;board name&gt;/                Board-specific code\n\u2502  \u251c\u2500 variant.cpp                   Arduino variant initialization\n\u2502  \u251c\u2500 variant.h                     Arduino variant pin configs\n\u251c\u2500 &lt;board name&gt;.json            PlatformIO board description\nbuilder/\n\u251c\u2500 frameworks/                  Framework builders for PlatformIO\n\u2502  \u251c\u2500 &lt;family name&gt;-sdk.py          Vanilla SDK build system\n\u2502  \u251c\u2500 &lt;family name&gt;-arduino.py      Arduino Core build system\n\u251c\u2500 libs/                        Builders for external libraries\n\u251c\u2500 utils/                       SCons utils used during the build\n\u251c\u2500 arduino-common.py            Builder to provide ArduinoCore-API and LibreTuya APIs\n\u251c\u2500 main.py                      Main PlatformIO builder\ndocs/                           Project documentation, guides, tips, etc.\nplatform/\n\u251c\u2500 &lt;family name&gt;/               Family-specific configurations\n\u2502  \u251c\u2500 bin/                          Binary blobs (bootloaders, etc.)\n\u2502  \u251c\u2500 fixups/                       Code fix-ups to replace SDK parts\n\u2502  \u251c\u2500 ld/                           Linker scripts\n\u2502  \u251c\u2500 openocd/                      OpenOCD configuration files\ntools/\n\u251c\u2500 &lt;tool name&gt;/                     Tools used during the build\n\u251c\u2500 util/                            Utilities used by CLI tools and the builders\nfamilies.json                   List of supported device families\nplatform.json                   PlatformIO manifest\nplatform.py                     Custom PlatformIO script\n</code></pre>"},{"location":"docs/resources/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Documents</li> <li>Tuya Pinout Config</li> <li>Beken Flash Chip List</li> </ul>"},{"location":"docs/resources/beken-flash/","title":"Beken Flash Chip List","text":"Chip ID Location Manufacturer Device Size SR Size Line Mode CMP Post Protect Post Protect Mask Protect All Protect None Protect Half Unprotect Last Block QE Bit Post QE Bit M Value Mode Sel Unprotect Protect cwMsk sb lb SR Read SR Write     <code>00 00 00</code> BDK na DEFAULT 4 MiB 2 2 0 2 0x1F 0x00 0x00 0x00 0x000 0 0 0x00 0x01          <code>0B 40 14</code> BDK xtx / XT 25F08B 1 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0C 0x101 9 1 0xA0 0x01          <code>0B 40 15</code> HDP,BDK xtx / XT 25F16B 2 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0D 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0B 40 16</code> HDP,BDK xtx / XT 25F32B 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0E 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0B 40 17</code> HDP,BDK xtx / XT 25F64B 8 MiB 2 2 14 2 0x1F 0x05 0x00 0x0E 0x109 9 1 0xA0 0x01 0x00 0x07 BIT(14)or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0B 60 17</code> HDP xtx / XT 25Q64B 8 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>0E 40 16</code> BDK xtx / FT 25H32 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0E 0x101 9 1 0xA0 0x01          <code>1C 31 13</code> HDP xtx / PN 25F04B 512 KiB 1             0x00 0x07 BFD(0x0f,2,4) 2 4 <code>05</code> <code>01</code>   <code>1C 41 16</code> HDP ESMT 25QH32A 4 MiB 1             0x00 0x07 BFD(0xf,2,5) 2 4 <code>05</code> <code>01</code>   <code>1C 70 15</code> HDP,BDK EN / ESMT 25QH16B 2 MiB 1 2 0 2 0x1F 0x1F 0x00 0x0d 0x0d 0 0 0xA5 0x01 0x00 0x07 BFD(0xf,2,5) 2 4 <code>05</code> <code>01</code>   <code>1C 70 16</code> BDK en 25QH32B 4 MiB 1 2 0 2 0x1F 0x1F 0x00 0x16 0x01B 0 0 0xA5 0x01          <code>20 40 16</code> BDK xmc 25QH32B 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0E 0x101 9 1 0xA0 0x01          <code>51 40 13</code> HDP GD 25D40 512 KiB 1             0x00 0x07 BFD(0x0f,2,3) 2 3 <code>05</code> <code>01</code>   <code>51 40 14</code> HDP GD 25D80 1 MiB 1             0x00 0x07 BFD(0x0f,2,3) 2 3 <code>05</code> <code>01</code>   <code>5E 40 14</code> HDP xtx / PN 25F08B 1 MiB 1             0x00 0x07 BFD(0x0f,2,4) 2 4 <code>05</code> <code>01</code>   <code>85 60 13</code> HDP Puya 25Q40 512 KiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>85 60 14</code> HDP Puya 25Q80 1 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>85 60 16</code> HDP Puya 25Q32H 4 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>85 60 17</code> HDP Puya 25Q64H 8 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C2 23 14</code> HDP WH 25V8035F 1 MiB 2             0x00 0x07 BIT(12) or BFD(0x1f,2,4) 2 5 <code>05 15</code> <code>01</code>   <code>C2 23 15</code> BDK mx 25V16B 2 MiB 1 2 0 2 0x0F 0x0F 0x00 0x0A 0x00E 6 1 0xA5 0x01          <code>C2 23 15</code> HDP WH 25V1635F 2 MiB 2             0x00 0x07 BIT(12) or BFD(0x1f,2,4) 2 5 <code>05 15</code> <code>01</code>   <code>C8 40 13</code> HDP GD 25Q41B 512 KiB 1             0x00 0x07 BIT(14) or BFD(0x1f,2,3) 2 3 <code>05 35</code> <code>01</code>   <code>C8 40 14</code> HDP GD 25D80 1 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 40 15</code> HDP,BDK GD 25Q16 2 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0D 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 40 16</code> HDP,BDK GD 25Q32 4 MiB 1 2 0 2 0x1F 0x1F 0x00 0x0E 0x00E 0 0 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 65 15</code> HDP GD 25WQ16E 2 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 65 16</code> HDP GD 25WQ32E 4 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>C8 65 17</code> HDP GD 25WQ64E 8 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>CD 60 14</code> HDP TH 25Q80HB 1 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>E0 40 13</code> HDP BY / PN 25Q40A 512 KiB 1             0x00 0x07 BIT(14) or BFD(0x1f,2,3) 2 3 <code>05 35</code> <code>01</code>   <code>E0 40 14</code> HDP BY / PN 25Q80A 1 MiB 1             0x00 0x07 BIT(14) or BFD(0x1f,2,3) 2 3 <code>05 35</code> <code>01</code>   <code>EB 60 15</code> HDP,BDK zg / TH 25Q16(H)B 2 MiB 2 2 14 2 0x1F 0x1F 0x00 0x0D 0x101 9 1 0xA0 0x01 0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>   <code>EF 40 16</code> BDK w 25Q32BFJ 4 MiB 2 2 14 2 0x1F 0x1F 0x00 0x00 0x101 9 1 0xA0 0x01          <code>EF 40 18</code> HDP WB 25Q128JV 16 MiB 2             0x00 0x07 BIT(14) or BFD(0x1f,2,5) 2 5 <code>05 35</code> <code>01</code>"},{"location":"docs/resources/documents/","title":"Documents","text":""},{"location":"docs/resources/documents/#realtek","title":"Realtek","text":"Code Name       From ambd_sdk   AN0004 Realtek low power wi-fi mp user guide   AN0011 Realtek wlan simple configuration   AN0012 Realtek secure socket layer(ssl)   AN0025 Realtek at command   AN0075 Realtek Ameba-all at command v2.0   AN0096 Realtek Ameba-all xmodem uart update firmware   AN0400 Ameba-D Application Note   UM0150 Realtek Ameba CoAP User Guide   UM0201 Ameba Common BT Application User Manual EN     Found elsewhere   AN0400 Ameba-D Application Note_v3_watermark   AN0500 Realtek Ameba-ZII application note     Realtek Ameba-ZII datasheet v0.8"},{"location":"docs/resources/tuya-pin-config/","title":"Tuya Pinout Config","text":"<p>Device configuration (<code>user_param_key</code>) can be extracted to JSON, using bk7231tools from a full firmware dump.</p> <p>Originally posted by @blakadder on Discord channel #resources, modified by me to include more keys and values.</p>    Key(s) Meaning Possible values     <code>crc</code>     <code>module</code>     <code>category</code>     <code>Jsonver</code><code>jv</code>     Common     <code>netled_pin</code><code>netled1_pin</code><code>wfst_pin</code> Status LED for WiFi    <code>netled_lv</code><code>netled1_lv</code><code>wfst_lv</code> Status LED Active Level 0 - Active low1 - Active high   <code>netled_reuse</code>     <code>reset_pin</code> + <code>reset_lv</code> Reset Button Pin + Active Level    <code>reset_t</code> Button press time to reset the device 3/5/6/9/10 seconds   <code>iicscl</code> I\u00b2C SCL Pin    <code>iicsda</code> I\u00b2C SDA Pin    <code>net_trig</code>     <code>net_type</code>     <code>wfcfg</code>  <code>spcl</code> / <code>spcl_auto</code> / <code>prod</code>   <code>wfct</code>     Lights/bulbs     <code>cmod</code> Color Mode <code>rgbcw</code> / <code>rgb</code> / <code>cw</code> / <code>c</code> / <code>rgbc</code>   <code>cwtype</code>     <code>brightmin</code>, <code>brightmax</code> Min/Max Brightness 0%-100%   <code>cwmin</code>, <code>cwmax</code> Cold-Warm Min/Max Brightness 0%-100%   <code>cwmaxp</code> Cold-Warm Max Power 0%-100%   <code>colormin</code>, <code>colormax</code> RGB Min/Max Brightness 0%-100%   <code>colormaxp</code> RGB Max Power 0%-100%   <code>brightstep</code><code>bristep</code> Brightness Step    <code>defbright</code> Default Brightness 0%-100%   <code>defcolor</code> Default Color <code>c</code> / <code>r</code>   <code>deftemp</code> Default Color Temperature    <code>gmkr</code>, <code>gmkg</code>, <code>gmkb</code>     <code>gmwr</code>, <code>gmwg</code>, <code>gmwb</code>     <code>hsvstep</code>     <code>rgbt</code>     <code>rstbr</code>     <code>rstcor</code>  <code>c</code>/<code>r</code>   <code>rsttemp</code>     PWM Lights     <code>r_pin</code> + <code>r_lv</code> Red Channel Pin + Active Level    <code>g_pin</code> + <code>g_lv</code> Green Channel Pin + Active Level    <code>b_pin</code> + <code>b_lv</code> Blue Channel Pin + Active Level    <code>c_pin</code> + <code>c_lv</code> Cool White Pin + Active Level    <code>w_pin</code> + <code>w_lv</code> Warm White Pin + Active Level    <code>pwmhz</code> PWM Operating Frequency (Hz)    I\u00b2C Lights     <code>dccur</code><code>ehccur</code><code>cjccur</code> Cold White Current    <code>dwcur</code><code>ehwcur</code><code>cjwcur</code> Warm White Current    <code>drgbcur</code> RGB Current    <code>campere</code>     <code>wampere</code>     <code>iicr</code> Red Channel Number 0-5   <code>iicg</code> Green Channel Number 0-5   <code>iicb</code> Blue Channel Number 0-5   <code>iicc</code> Cold White Channel Number 0-5   <code>iicw</code> Warm White Channel Number 0-5   <code>iicccur</code> Cold White Current 0   <code>iicwcur</code> Warm White Current 5   Sockets/switches     <code>btX_pin</code> + <code>btX_lv</code> Button X Pin + Active Level    <code>btX_type</code><code>bt_type</code> Button X Trigger Type 0 - level_trig1 - edge_trig   <code>rlX_pin</code> + <code>rlX_lv</code> Relay X Pin + Active Level    <code>rlX_type</code><code>rl_type</code> Relay X Type 0 - Electric holding relay1 - Magnetic holding relay   <code>rl_onX_pin</code> + <code>rl_onX_lv</code> Relay ON Pin + Active Level    <code>rl_offX_pin</code> + <code>rl_offX_lv</code> Relay OFF Pin + Active Level    <code>rl1_dr_type</code>     <code>rl_drvtime</code>     <code>total_bt_pin</code> + <code>total_bt_lv</code>     Power monitoring     <code>ele_fun_en</code> Power Monitoring Enabled 1   <code>chip_type</code> Power Monitoring Chip Type 0 - BL09371 - HLW80122 - HLW80324 - BL0942   <code>ele_pin</code> CF Pin    <code>vi_pin</code> CF1 Pin    <code>sel_pin_pin</code> + <code>sel_pin_lv</code> SEL Pin + Active Level Active level is usually 1   <code>lose_vol</code> Under voltage threshold in V    <code>over_cur</code> Overcurrent threshold in mA    <code>over_vol</code> Overvoltage threshold in V    <code>sample_resistor</code> Current shunt resistor value 1 - 1m\u03a92 - 2m\u03a9   <code>vol_def</code> Socket operating voltage 0 - 220V1 - 110V   <code>work_voltage</code> Socket operating voltage    Infrared     <code>irfunc</code> IR Function 0, 1   <code>infre</code> IR Transmitter Pin    <code>infrr</code><code>ir</code> IR Receiver Pin    <code>irkXfun</code> + <code>irkXval</code> IR Key X Function + Value X in 1..30   <code>irnightt</code>     <code>irstep</code>     <code>wgmod</code>, <code>swgmod</code>, <code>scgmod</code>     PIR     <code>pirmod</code>     <code>pirfreq</code>     <code>pirlduty</code>     <code>pirmduty</code>     <code>pirhduty</code>     <code>pirin_pin</code> + <code>pirin_lv</code>     <code>pirsense_pin</code> + <code>pirsense_lv</code>     <code>pirrange</code>     <code>pirwarn</code>     Key-controlled     <code>key_pin</code> + <code>key_lv</code> Key Pin + Active Level    <code>kXpin_pin</code> + <code>kXpin_lv</code>     <code>kXdfunc</code>, <code>kXlfunc</code>, <code>kXsfunc</code>     <code>kXldir</code>, <code>kXsdir</code>     <code>keyccfg1</code>, <code>keyccfg2</code>     <code>keyfunc</code>, <code>keyglobefunc</code>     <code>keylt</code>, <code>keynumber</code>     Other     <code>buzzer_pwm</code> Buzzer working PWM frequency    <code>ismusic</code>  0, 1   <code>ledX_pin</code> + <code>ledX_lv</code> LED X Pin + Active Level    <code>led_pin</code> + <code>led_lv</code> LED Pin + Active Level    Unknown     <code>0err</code>     <code>1err</code>     <code>adclimit</code>     <code>aging</code>     <code>alarm1_time</code>     <code>alarm_t1</code>     <code>backlit_dp</code>     <code>backlit_select</code>     <code>bitseq</code>     <code>bleonoff</code>     <code>blindt</code>     <code>buzzer</code>     <code>cagt</code>     <code>cctseg</code>     <code>cd_flag2</code>     <code>cdsval</code>     <code>ch1_stat</code>     <code>ch_cddpidX</code>  X in 1..4   <code>ch_dpidX</code>  X in 1..4   <code>ch_flagX</code>  X in 1..4   <code>ch_num</code>     <code>clean_t</code>     <code>cntdown1</code>     <code>colorpfun</code>     <code>ctrl_lv</code>     <code>ctrl_pin</code>     <code>customcode</code>     <code>cyc_dpid</code>     <code>day</code>     <code>dctrl_select</code>     <code>dimmod</code>     <code>dimt</code>     <code>dimval</code>     <code>dmod</code>     <code>door1_magt_lv</code>     <code>door1_magt_pin</code>     <code>door_alarm_st1</code>     <code>door_mag1</code>     <code>dusk</code>     <code>evenfall</code>     <code>evening</code>     <code>ffc_select</code>     <code>inch_dp</code>     <code>indep_cfgbt</code>     <code>init_conf</code>     <code>knum</code>     <code>ktime</code>     <code>leaderr</code>     <code>led_dp</code>     <code>lfunc</code>     <code>light_status_select</code>     <code>lock_dp</code>     <code>lockt</code>     <code>micpin</code>     <code>mixway</code>     <code>mutex</code>     <code>mxcl_led_m</code>     <code>netn_led</code>     <code>netnc</code>     <code>nety_led</code>     <code>netyc</code>     <code>night</code>     <code>nightbrig</code>     <code>nightcct</code>     <code>nightled</code>     <code>notdisturb</code>     <code>on_off_cnt</code>     <code>onoff1</code>     <code>onoff_clear_t</code>     <code>onoff_n</code>     <code>onoff_rst_m</code>     <code>onoff_rst_type</code>     <code>onoff_type</code>     <code>onoffmode</code>     <code>onofftime</code>     <code>owm</code>     <code>pairt</code>     <code>pmemory</code>     <code>preheatt</code>     <code>prodagain</code>     <code>rand_dpid</code>     <code>remdmode</code>     <code>remote_add_dp</code>     <code>remote_list_dp</code>     <code>remote_select</code>     <code>resistor</code>     <code>reuse_led_m</code>     <code>rsthold</code>     <code>rstmode</code>     <code>rstnum</code>     <code>scenespct</code>     <code>series_ctrl</code>     <code>sfunc</code>     <code>standtime</code>     <code>starterr</code>     <code>step_rate</code>     <code>switch1</code>     <code>tempmix</code>     <code>tempstep</code>     <code>title20</code>     <code>total_stat</code>     <code>tracetime1</code>     <code>trigdelay</code>     <code>trigmod</code>     <code>trl1_time</code>     <code>voice_ctrl1</code>     <code>voice_ctrl_set1</code>     <code>whiteseg</code>     <code>wt</code>     <code>zero_select</code>"},{"location":"docs/status/arduino/","title":"Implementation status","text":"<p>Note: this list will probably change with each functionality update.</p>      <code>realtek-ambz</code> <code>beken-72xx</code>     Core functions \u2714\ufe0f \u2714\ufe0f   GPIO/PWM/IRQ \u2714\ufe0f/\u2714\ufe0f/\u2714\ufe0f \u2714\ufe0f/\u2714\ufe0f/\u2714\ufe0f   Analog input (ADC) \u2714\ufe0f \u2714\ufe0f   Serial \u2714\ufe0f \u2714\ufe0f   Serial (extra) 0, 1, 2 1, 2   Flash I/O \u2714\ufe0f \u2714\ufe0f   CORE LIBRARIES     SoftwareSerial \u2714\ufe0f \u274c   SPI \u274c \u274c   Wire \u2757 \u274c   OTHER LIBRARIES     Wi-Fi STA/AP/Mixed \u2714\ufe0f \u2714\ufe0f   Wi-Fi Events \u2714\ufe0f \u2714\ufe0f   TCP Client (SSL) \u2714\ufe0f (\u2714\ufe0f) \u2714\ufe0f (\u2757)   TCP Server \u2714\ufe0f \u2714\ufe0f   IPv6 \u274c \u274c   HTTP Client (SSL) \u2714\ufe0f (\u2714\ufe0f) \u2753   HTTP Server \u2714\ufe0f \u2714\ufe0f   NVS / Preferences \u274c \u274c   SPIFFS \u274c \u274c   BLE - \u274c   NTP \u274c \u274c   OTA \u2714\ufe0f \u2714\ufe0f   MDNS \u2714\ufe0f \u2714\ufe0f   MQTT \u2705 \u274c   SD \u274c \u274c    <p>Symbols:</p> <ul> <li>\u2714\ufe0f working</li> <li>\u2705 tested, external library</li> <li>\u2753 untested</li> <li>\u2757 broken</li> <li>\u274c not implemented (yet?)</li> <li>- not applicable</li> </ul> <p>Names:</p> <ul> <li>Core functions - stuff like delay(), millis(), yield(), etc.</li> <li>CORE LIBRARIES - included normally in all Arduino cores</li> <li>OTHER LIBRARIES - included in ESP32 core or downloadable</li> </ul>"},{"location":"docs/status/supported/","title":"Supported boards, modules and CPUs","text":""},{"location":"docs/status/supported/#board-list","title":"Board list","text":"Name MCU Flash RAM Pins* Wi-Fi BLE ZigBee Family name     Generic           BK7231N (Tuya QFN32) BK7231N 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   BK7231T (Tuya QFN32) BK7231T 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   BK7252 BK7252 4 MiB 512 KiB 38 (38 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7251</code>   RTL8710BN (2M/468k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BN (2M/788k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BX (4M/980k) RTL8710BX 4 MiB 256 KiB 17 (17 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8720CF (2M/992k) RTL8720CF 2 MiB 256 KiB 20 (20 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   Ai-Thinker Co., Ltd.           BW12 RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   BW15 RTL8720CF 2 MiB 256 KiB 16 (13 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   Tuya Inc.           CB2L BK7231N 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB2S BK7231N 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3L BK7231N 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3S BK7231N 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3SE BK7231N 2 MiB 256 KiB 22 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   WB2L BK7231T 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WB2S BK7231T 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WB3L BK7231T 2 MiB 256 KiB 21 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WB3S BK7231T 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WR2 RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2E RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3 RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3E RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3N RTL8710BN 2 MiB 256 KiB 16 (10 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2L RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2LE RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3L RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3LE RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   Unknown           LSC LMA35 BK7231N 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   LSC LMA35 T BK7231T 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   N/A           Native NATIVE 4 MiB 4 MiB - \u2714\ufe0f \u274c \u274c <code>host-native</code>     <p>* I/O count includes GPIOs, ADCs, PWM outputs and UART, but doesn't count CEN/RST and power pins.</p>"},{"location":"docs/status/supported/#cpu-list","title":"CPU list","text":"<p>Chips currently supported by the project:</p>   <ul> <li>BK7231N</li> <li>BK7231S</li> <li>BK7231T</li> <li>BK7231U</li> <li>BK7251</li> <li>BK7252</li> <li>BL2028N</li> <li>NATIVE</li> <li>RTL8710BN</li> <li>RTL8710BX</li> <li>RTL8720CF</li> </ul>  <p>This list is not exhaustive, i.e. a similar chip (but different package) might work just fine, but there's no board definition for it yet. If you have an unsupported chip, feel free to reach out using Issues or on the Discord server.</p>"},{"location":"docs/status/supported/#families","title":"Families","text":"<p>A list of chip families currently supported by this project.</p>  <p>Note</p> <p>The term family was chosen over platform, in order to reduce possible confusion between LibreTuya supported \"platforms\" and PlatformIO's \"platform\", as an entire package. Family is also more compatible with the UF2 term.</p>  <p>The following list corresponds to UF2 OTA format family names, and is also available as JSON. The IDs are also present in ChipType.h.</p>      Title Name (parent) Code Short name &amp; ID Arduino Core Source SDK     Realtek Ameba1 <code>-</code> <code>-</code> <code>RTL8710A</code> (0x9FFFD543) \u274c -   Realtek AmebaZ <code>realtek-ambz</code> (<code>realtek-amb</code>) <code>ambz</code> (<code>amb</code>) <code>RTL8710B</code> (0x22E0D6FC) \u2714\ufe0f <code>framework-realtek-amb1</code> (amb1_sdk)   Realtek AmebaZ2 <code>realtek-ambz2</code> (<code>realtek-amb</code>) <code>ambz2</code> (<code>amb</code>) <code>RTL8720C</code> (0xE08F7564) \u274c <code>framework-realtek-ambz2</code> (ambz2_sdk)   Realtek AmebaD <code>-</code> <code>-</code> <code>RTL8720D</code> (0x3379CFE2) \u274c -   Beken 7231U/7231T <code>beken-7231u</code> (<code>beken-72xx</code>) <code>bk7231u</code> (<code>bk72xx</code>) <code>BK7231U</code> (0x675A40B0) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Beken 7231N <code>beken-7231n</code> (<code>beken-72xx</code>) <code>bk7231n</code> (<code>bk72xx</code>) <code>BK7231N</code> (0x7B3EF230) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Beken 7251/7252 <code>beken-7251</code> (<code>beken-72xx</code>) <code>bk7251</code> (<code>bk72xx</code>) <code>BK7251</code> (0x6A82CC42) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Boufallo 602 <code>-</code> <code>-</code> <code>BL602</code> (0xDE1270B7) \u274c -   Xradiotech 809 <code>-</code> <code>-</code> <code>XR809</code> (0x51E903A8) \u274c -   Native host architecture <code>host-native</code> <code>native</code> <code>NATIVE</code> (0xDEADBEEF) \u274c -"},{"location":"docs/status/supported/#unsupported-boards","title":"Unsupported boards","text":""},{"location":"docs/status/supported/#tuya-inc","title":"Tuya Inc.","text":"<p>Note</p> <p>Only modules featuring at least Wi-Fi are included in the table. (TY)JW, (TY)WE and (TY)LC Series are omitted, as they contain Espressif chips.</p>       Name MCU Flash RAM Pins Wi-Fi BLE ZigBee     AXY Series          AXY2S ECR6600 2 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3L ECR6600 2 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3S ECR6600 2 MiB 512 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   AXYU ECR6600 2 MiB 512 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   CB Series          CB1S BK7231N 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   CB8P BK7231N 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   CBLC5 BK7231N 2 MiB 256 KiB 15 \u2714\ufe0f \u2714\ufe0f \u274c   CBLC9 BK7231N 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   CBU BK7231N 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   CR Series          CR2S RTL8720CM 4 MiB 4 MiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   CR3L RTL8720CM 4 MiB 4 MiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   CRG1 RTL8720CM 4 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   WB Series          WB1S BK7231T 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WB8P BK7231T 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   WBLC5 BK7231T 2 MiB 256 KiB 15 \u2714\ufe0f \u2714\ufe0f \u274c   WBLC9 BK7231T 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   WBR Series          WBR1 RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2 RTL8720CF 2 MiB 256 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2L RTL8720CF 2 MiB 256 KiB 7 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3 RTL8720CF 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3L RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3S RTL8720CF 2 MiB 256 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   WBRU RTL8720CF 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3N RTL8720CS 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBRG1 RTL8720CSM 8 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   WBR1D RTL8720DN 4 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2D RTL8720DN 4 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3D RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3T RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WL Series          WL2H-U LN882H ? 296 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WR Series          WR1 RTL8710BN 1 MiB 256 KiB 18 \u2714\ufe0f \u274c \u274c   WR1E RTL8710BN 2 MiB 256 KiB 18 \u2714\ufe0f \u274c \u274c   WR4 RTL8710BN 1 MiB 256 KiB 16 \u2714\ufe0f \u274c \u274c   WR5E RTL8710BN 2 MiB 256 KiB 15 \u2714\ufe0f \u274c \u274c   WR6 RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WR6-H RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WRG1 RTL8711AM 4 MiB 2 MiB 25 \u2714\ufe0f \u274c \u274c   WT Series          WT3 T2 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   XR Series          XR1 XR809 2 MiB 384 KiB 18 \u2714\ufe0f \u274c \u274c   XR3 XR809 2 MiB 384 KiB 16 \u2714\ufe0f \u274c \u274c"},{"location":"docs/status/supported_boards/","title":"Supported boards","text":"Name MCU Flash RAM Pins* Wi-Fi BLE ZigBee Family name     Generic           BK7231N (Tuya QFN32) BK7231N 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   BK7231T (Tuya QFN32) BK7231T 2 MiB 256 KiB 19 (19 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   BK7252 BK7252 4 MiB 512 KiB 38 (38 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7251</code>   RTL8710BN (2M/468k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BN (2M/788k) RTL8710BN 2 MiB 256 KiB 18 (18 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8710BX (4M/980k) RTL8710BX 4 MiB 256 KiB 17 (17 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   RTL8720CF (2M/992k) RTL8720CF 2 MiB 256 KiB 20 (20 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   Ai-Thinker Co., Ltd.           BW12 RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   BW15 RTL8720CF 2 MiB 256 KiB 16 (13 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>realtek-ambz2</code>   Tuya Inc.           CB2L BK7231N 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB2S BK7231N 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3L BK7231N 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3S BK7231N 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   CB3SE BK7231N 2 MiB 256 KiB 22 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   WB2L BK7231T 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WB2S BK7231T 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WB3L BK7231T 2 MiB 256 KiB 21 (17 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WB3S BK7231T 2 MiB 256 KiB 22 (16 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   WR2 RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2E RTL8710BN 2 MiB 256 KiB 11 (8 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3 RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3E RTL8710BN 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3N RTL8710BN 2 MiB 256 KiB 16 (10 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2L RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR2LE RTL8710BX 2 MiB 256 KiB 7 (5 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3L RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   WR3LE RTL8710BX 2 MiB 256 KiB 16 (12 I/O) \u2714\ufe0f \u274c \u274c <code>realtek-ambz</code>   Unknown           LSC LMA35 BK7231N 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231n</code>   LSC LMA35 T BK7231T 2 MiB 256 KiB 22 (15 I/O) \u2714\ufe0f \u2714\ufe0f \u274c <code>beken-7231u</code>   N/A           Native NATIVE 4 MiB 4 MiB - \u2714\ufe0f \u274c \u274c <code>host-native</code>"},{"location":"docs/status/supported_chips/","title":"Supported chips","text":"<ul> <li>BK7231N</li> <li>BK7231S</li> <li>BK7231T</li> <li>BK7231U</li> <li>BK7251</li> <li>BK7252</li> <li>BL2028N</li> <li>NATIVE</li> <li>RTL8710BN</li> <li>RTL8710BX</li> <li>RTL8720CF</li> </ul>"},{"location":"docs/status/supported_families/","title":"Supported families","text":"Title Name (parent) Code Short name &amp; ID Arduino Core Source SDK     Realtek Ameba1 <code>-</code> <code>-</code> <code>RTL8710A</code> (0x9FFFD543) \u274c -   Realtek AmebaZ <code>realtek-ambz</code> (<code>realtek-amb</code>) <code>ambz</code> (<code>amb</code>) <code>RTL8710B</code> (0x22E0D6FC) \u2714\ufe0f <code>framework-realtek-amb1</code> (amb1_sdk)   Realtek AmebaZ2 <code>realtek-ambz2</code> (<code>realtek-amb</code>) <code>ambz2</code> (<code>amb</code>) <code>RTL8720C</code> (0xE08F7564) \u274c <code>framework-realtek-ambz2</code> (ambz2_sdk)   Realtek AmebaD <code>-</code> <code>-</code> <code>RTL8720D</code> (0x3379CFE2) \u274c -   Beken 7231U/7231T <code>beken-7231u</code> (<code>beken-72xx</code>) <code>bk7231u</code> (<code>bk72xx</code>) <code>BK7231U</code> (0x675A40B0) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Beken 7231N <code>beken-7231n</code> (<code>beken-72xx</code>) <code>bk7231n</code> (<code>bk72xx</code>) <code>BK7231N</code> (0x7B3EF230) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Beken 7251/7252 <code>beken-7251</code> (<code>beken-72xx</code>) <code>bk7251</code> (<code>bk72xx</code>) <code>BK7251</code> (0x6A82CC42) \u2714\ufe0f <code>framework-beken-bdk</code> (bdk_freertos)   Boufallo 602 <code>-</code> <code>-</code> <code>BL602</code> (0xDE1270B7) \u274c -   Xradiotech 809 <code>-</code> <code>-</code> <code>XR809</code> (0x51E903A8) \u274c -   Native host architecture <code>host-native</code> <code>native</code> <code>NATIVE</code> (0xDEADBEEF) \u274c -"},{"location":"docs/status/unsupported_boards_tuya_all/","title":"Unsupported boards tuya all","text":"Name MCU Flash RAM Pins Wi-Fi BLE ZigBee     AXY Series          AXY2S ECR6600 2 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3L ECR6600 2 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   AXY3S ECR6600 2 MiB 512 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   AXYU ECR6600 2 MiB 512 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   CB Series          CB1S BK7231N 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   CB8P BK7231N 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   CBLC5 BK7231N 2 MiB 256 KiB 15 \u2714\ufe0f \u2714\ufe0f \u274c   CBLC9 BK7231N 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   CBU BK7231N 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   CR Series          CR2S RTL8720CM 4 MiB 4 MiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   CR3L RTL8720CM 4 MiB 4 MiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   CRG1 RTL8720CM 4 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   WB Series          WB1S BK7231T 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WB8P BK7231T 2 MiB 256 KiB 10 \u2714\ufe0f \u2714\ufe0f \u274c   WBLC5 BK7231T 2 MiB 256 KiB 15 \u2714\ufe0f \u2714\ufe0f \u274c   WBLC9 BK7231T 2 MiB 256 KiB 8 \u2714\ufe0f \u2714\ufe0f \u274c   WBR Series          WBR1 RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2 RTL8720CF 2 MiB 256 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2L RTL8720CF 2 MiB 256 KiB 7 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3 RTL8720CF 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3L RTL8720CF 2 MiB 256 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3S RTL8720CF 2 MiB 256 KiB 22 \u2714\ufe0f \u2714\ufe0f \u274c   WBRU RTL8720CF 2 MiB 256 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3N RTL8720CS 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBRG1 RTL8720CSM 8 MiB 4 MiB 25 \u2714\ufe0f \u2714\ufe0f \u274c   WBR1D RTL8720DN 4 MiB 512 KiB 18 \u2714\ufe0f \u2714\ufe0f \u274c   WBR2D RTL8720DN 4 MiB 512 KiB 11 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3D RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WBR3T RTL8720DN 4 MiB 512 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   WL Series          WL2H-U LN882H ? 296 KiB 21 \u2714\ufe0f \u2714\ufe0f \u274c   WR Series          WR1 RTL8710BN 1 MiB 256 KiB 18 \u2714\ufe0f \u274c \u274c   WR1E RTL8710BN 2 MiB 256 KiB 18 \u2714\ufe0f \u274c \u274c   WR4 RTL8710BN 1 MiB 256 KiB 16 \u2714\ufe0f \u274c \u274c   WR5E RTL8710BN 2 MiB 256 KiB 15 \u2714\ufe0f \u274c \u274c   WR6 RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WR6-H RTL8710BN 2 MiB 256 KiB 14 \u2714\ufe0f \u274c \u274c   WRG1 RTL8711AM 4 MiB 2 MiB 25 \u2714\ufe0f \u274c \u274c   WT Series          WT3 T2 2 MiB 256 KiB 16 \u2714\ufe0f \u2714\ufe0f \u274c   XR Series          XR1 XR809 2 MiB 384 KiB 18 \u2714\ufe0f \u274c \u274c   XR3 XR809 2 MiB 384 KiB 16 \u2714\ufe0f \u274c \u274c"},{"location":"examples/SUMMARY/","title":"Examples","text":"<ul> <li>PinScan</li> </ul>"},{"location":"examples/PinScan/","title":"PinScan","text":"<p>This example allows to quickly check all digital/analog pins of an IoT device.</p> <p>By using a simple TUI (text user interface), you can check which I/O pins correspond to i.e. button presses, as well as write to one of the pins to see which LED lights up.</p>  <p>Warning</p> <p>Messing with pins in a device can potentially damage some parts of it. Be careful when writing voltages to digital and PWM pins.</p>  <p>Uploading the example and opening up a terminal (e.g. PuTTY) presents this menu: <pre><code>LibreTuya v0.8.0, PinScan v1.0\nBoard: cb2s\nI/O count: 11\nDigital I/O count: 11\nAnalog input count: 1\n-------- UART2 --------\nCommands:\n        d - Check digital pins\n        a - Check analog pins\n        s - Select UART port\n        t - Toggle ANSI control codes\n        r - Reboot (for uploading)\n        q - Go back to menu, at any time\n        ? - Print help text, also for subcommands\n</code></pre></p> <p>The interface expects one-letter commands, without confirmation by <code>Enter</code>. The only part which expects an <code>Enter</code> keypress is inputting pin numbers and UART port numbers.</p> <p>Pressing <code>q</code> at any time goes back to the main menu, terminating the current process.</p>  <p>Note</p> <p>PinScan works best with a terminal supporting ANSI escape codes (PuTTY does), but this behavior can be disabled using <code>t</code>.</p>  <p>Switching to another UART port is possible (for example if the default port is on the pins you want to check) using <code>s</code> command. Do not change the port after using any I/O commands, as it won't work; reboot it using <code>r</code> before.</p> <p>By setting <code>USE_WIFI</code> in <code>main.h</code> to 1, a Telnet server is enabled on port 23. This allows to test I/O pins without having physical, wired access to the device (i.e. using OTA). Make sure to specify correct WiFi credentials.</p>  <p>Tip</p> <p>If your board isn't supported by LT yet, use one of the generic boards.</p> <p>If your board doesn't even have a known pinout, use <code>d</code>/<code>s</code> commands of PinScan to ease the mapping of all board pins.</p>"},{"location":"examples/PinScan/#digital-pins","title":"Digital pins","text":"<pre><code>Digital I/O\n-------- UART2 --------\nCommands:\n        r - Realtime readout of all pins\n        o - Read one pin continuously\n        s - Manual Scan - toggle each pin\n        h - Write HIGH to a pin\n        l - Write LOW to a pin\n        p - Output using pull up/down (default)\n        w - Output using write low/high (less safe)\n</code></pre>"},{"location":"examples/PinScan/#realtime-readout-of-all-pins","title":"Realtime readout of all pins","text":"<pre><code> D0  D1  D2  D3  D4  D5  D6  D7  D8  D9 D10\n LO  LO  HI  HI  HI  HI  LO  LO  --  --  LO\n</code></pre> <p>Screen contents will update when voltage on one of the pins changes. Pins marked with <code>--</code> mean the currently used UART port (which can be changed using <code>s</code> command; after reboot).</p>  <p>TL;DR</p> <p>Try pressing a button to see which pin changes.</p>"},{"location":"examples/PinScan/#read-one-pin-continuously","title":"Read one pin continuously","text":"<p>Enter the pin number, it will be probed until you press <code>q</code>.</p>"},{"location":"examples/PinScan/#manual-scan-toggle-each-pin","title":"Manual Scan - toggle each pin","text":"<pre><code> D0  D1  D2  D3  D4  D5  D6  D7  D8  D9 D10\n HI  LO  LO  LO  LO  LO  LO  LO  --  --  LO\n</code></pre> <p>A pin will be toggled every 500ms, starting with D0. Type <code>n</code> to move to the next pin.</p>  <p>TL;DR</p> <p>Go through the pins to see which lights up an LED.</p>"},{"location":"examples/PinScan/#write-highlow-to-a-pin","title":"Write HIGH/LOW to a pin","text":"<p>Self-explanatory.</p>"},{"location":"examples/PinScan/#output-using-pullwrite","title":"Output using pull/write","text":"<p>Outputs can be toggled by using internal pull-up/pull-down resistors, or by simply writing a voltage. Writing is more current-efficient, but is also less safe if something else supplies different voltage to the pin.</p> <p>This affects scan and write high/low commands.</p>  <p>TL;DR</p> <p>Use <code>write</code> output mode (carefully) if there's an LED which doesn't light up with default pull mode.</p>"},{"location":"examples/PinScan/#analog-pins","title":"Analog pins","text":"<pre><code>Analog inputs\n-------- UART2 --------\nCommands:\n        r - Realtime readout of all pins\n        o - Read one pin once\n</code></pre>"},{"location":"examples/PinScan/#realtime-readout-of-all-pins_1","title":"Realtime readout of all pins","text":"<p>Read voltage (in millivolts) on all available analog pins, until <code>q</code> is pressed.</p>"},{"location":"examples/PinScan/#read-one-pin-once","title":"Read one pin once","text":"<p>No need to explain.</p>"},{"location":"platform/realtek-ambz/fixups/lib_rtlstd_patch/","title":"lib_rtlstd_patch.a","text":"<pre><code>arm-none-eabi-gcc-ar xo lib_rtlstd.a\nrm rtl_eabi_cast_ram.o\narm-none-eabi-objcopy --strip-debug --strip-unneeded ram_libc.o\narm-none-eabi-objcopy --strip-debug --strip-unneeded ram_libgloss_retarget.o\narm-none-eabi-objcopy --strip-debug --strip-unneeded rtl_math_ram.o\narm-none-eabi-gcc-ar qs lib_rtlstd_patch.a *.o\n</code></pre>"},{"location":"src/mkdoxy/","title":"MkDoxy","text":""},{"location":"src/mkdoxy/#mkdoxy-mkdocs-doxygen-easy-documentation-with-code-snippets","title":"MkDoxy -&gt; MkDocs + Doxygen. Easy documentation with code snippets.","text":""},{"location":"src/mkdoxy/#based-on-matusnovakdoxybook","title":"Based on  matusnovak/doxybook","text":"<p>This python tool is extension for MkDocs. Extension will take your programme source code and runs Doxygen. Than converts exported XML into markdown and create new folder with full generated documentation.  Next usage is by snippets inside documentation markdown.</p>"},{"location":"src/mkdoxy/#example-usage","title":"Example usage","text":"<ol> <li> <p>Generate class with name <code>rb::MotorChangeBuilder</code> <pre><code>::: doxy.Class\n    name: rb::MotorChangeBuilder\n</code></pre></p> </li> <li> <p>Generate method <code>brake (MotorId id, uint16_t brakingPower)</code> from class with name <code>rb::MotorChangeBuilderA</code> <pre><code>::: doxy.Class.Method\n    name: rb::MotorChangeBuilder\n    method: brake (MotorId id, uint16_t brakingPower)\n</code></pre></p> </li> <li> <p>Generate function with name <code>readUltra (bool async)</code> <pre><code>::: doxy.Function\n    name: readUltra (bool async)\n</code></pre></p> </li> <li> <p>Generate code snippet from file <code>RBCXLeds.cpp</code> <pre><code>::: doxy.Code\n    file: RBCXLeds.cpp\n    start: 21\n    end: 35\n</code></pre></p> </li> </ol>"},{"location":"src/mkdoxy/#requirements","title":"Requirements","text":""},{"location":"src/mkdoxy/#apt","title":"Apt","text":"<ul> <li>python 3.6 or newer -&gt; <code>sudo apt install python3</code> </li> <li>Pip -&gt; <code>sudo apt install python3-pip</code></li> <li>Git -&gt; <code>sudo apt install git</code></li> <li>Doxygen -&gt; <code>sudo apt install doxygen</code></li> </ul>"},{"location":"src/mkdoxy/#pip","title":"Pip","text":"<ul> <li>Jinja2 -&gt; <code>pip install jinja2</code></li> <li>Mkdocs -&gt; <code>pip install mkdocs</code></li> <li>ruamel.yaml -&gt; <code>pip install ruamel.yaml</code></li> </ul>"},{"location":"src/mkdoxy/#optional","title":"Optional:","text":"<ul> <li>mkdocs-material -&gt; <code>pip install mkdocs-material</code></li> </ul>"},{"location":"src/mkdoxy/#installation","title":"Installation","text":"<p>Install using Python Pip: https://pypi.org/project/mkdocs-doxygen-snippets-plugin/</p> <pre><code>pip install mkdocs-doxygen-snippets-plugin\n</code></pre> <p>Or Install manually:</p> <pre><code>git clone https://github.com/JakubAndrysek/mkdocs-doxygen-snippets-plugin.git\ncd mkdocs-doxygen-snippets-plugin\npython setup.py install\n</code></pre>"},{"location":"src/mkdoxy/#license","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2021 Kuba Andr\u00fdsek\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/","title":"Snippets example","text":"Error: Did not exist project with name: esp <pre><code>::: doxy.esp.Function\n    name: int testFnc(float a, char b)\n    details: True\n    implements: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Function\n    name: testFnc(float a, char b)\n    details: True\n    implements: True\n</code></pre>    <pre><code>::: doxy.esp.Class\n    name: rb::MotorChangeBuilder\n    description: True\n    include: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_1","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class\n    name: rb::MotorChangeBuilder\n    description: True\n    include: True\n</code></pre>    <pre><code>::: doxy.esp.Class.Method\n    name: rb::MotorChangeBuilder\n    method: brake (MotorId id, uint16_t brakingPower)\n    details: False\n    include: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_2","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class.Method\n    name: rb::MotorChangeBuilder\n    method: brake (MotorId id, uint16_t brakingPower)\n    details: False\n    include: True\n</code></pre>    <pre><code>::: doxy.esp.Class.list\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_3","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class.list\n</code></pre>    <pre><code>::: doxy.esp.Class.index          \n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_4","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Class.index\n</code></pre>    <pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_5","title":"Source codeError: Did not exist project with name: esp","text":"<pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n</code></pre>    <pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n    start: 21\n    end: 35\n    header: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/docs/#source-code_6","title":"Source code","text":"<pre><code>::: doxy.esp.Code\n    file: RBCXLeds.cpp\n    start: 21\n    end: 35\n    header: True\n</code></pre>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/","title":"Markdown test","text":"<p>I highly do not recommend to use markdown through Doxygen! The source markdown file will go through Doxygen to xml and then from xml through doxybook back into markdown. If you REALLY need to use markdown through Doxygen, it is here, but limited. IMHO, just write a simple shell script to copy the necessary markdown files into GitBook directly. Anyway, the markdown below is copied from here: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet and most of it works through doxybook.</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#headers","title":"Headers","text":"<pre><code># H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\n\nAlternatively, for H1 and H2, an underline-ish style:\n\nAlt-H1\n======\n\nAlt-H2\n------\n</code></pre>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h1","title":"H1","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h2","title":"H2","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h3","title":"H3","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h4","title":"H4","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h5","title":"H5","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#h6","title":"H6","text":"<p>Alternatively, for H1 and H2, an underline-ish style:</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#alt-h1","title":"Alt-H1","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#alt-h2","title":"Alt-H2","text":""},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#emphasis","title":"Emphasis","text":"<pre><code>Emphasis, aka italics, with *asterisks* or _underscores_.\n\nStrong emphasis, aka bold, with **asterisks** or __underscores__.\n\nCombined emphasis with **asterisks and _underscores_**.\n\nStrikethrough uses two tildes. ~~Scratch this.~~\n</code></pre> <p>Emphasis, aka italics, with asterisks or underscores.</p> <p>Strong emphasis, aka bold, with asterisks or underscores.</p> <p>Combined emphasis with asterisks and underscores.</p> <p>Strikethrough uses two tildes. ~~Scratch this.~~</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#lists","title":"Lists","text":"<pre><code>1. First ordered list item\n2. Another item\n  * Unordered sub-list. \n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n4. And another item.\n\n   You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).\n\n   To have a line break without a paragraph, you will need to use two trailing spaces.\n   Note that this line is separate, but within the same paragraph.\n   (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)\n\n* Unordered list can use asterisks\n- Or minuses\n+ Or pluses\n</code></pre> <ol> <li>First ordered list item</li> <li>Another item</li> <li>Unordered sub-list. </li> <li>Actual numbers don't matter, just that it's a number</li> <li>Ordered sub-list</li> <li>And another item.</li> </ol> <p>You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).</p> <p>To have a line break without a paragraph, you will need to use two trailing spaces.    Note that this line is separate, but within the same paragraph.    (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</p> <ul> <li>Unordered list can use asterisks</li> <li>Or minuses</li> <li>Or pluses</li> </ul>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#links","title":"Links","text":"<pre><code>[I'm an inline-style link](https://www.google.com)\n\n[I'm an inline-style link with title](https://www.google.com \"Google's Homepage\")\n\n[I'm a reference-style link][Arbitrary case-insensitive reference text]\n\n[I'm a relative reference to a repository file](../blob/master/LICENSE)\n\n[You can use numbers for reference-style link definitions][1]\n\nOr leave it empty and use the [link text itself].\n\nURLs and URLs in angle brackets will automatically get turned into links. \nhttp://www.example.com or &lt;http://www.example.com&gt; and sometimes \nexample.com (but not on Github, for example).\n\nSome text to show that the reference links can follow later.\n\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\n[1]: http://slashdot.org\n[link text itself]: http://www.reddit.com\n</code></pre> <p>I'm an inline-style link</p> <p>I'm an inline-style link with title</p> <p>I'm a reference-style link</p> <p>I'm a relative reference to a repository file</p> <p>You can use numbers for reference-style link definitions</p> <p>Or leave it empty and use the link text itself.</p> <p>URLs and URLs in angle brackets will automatically get turned into links.  http://www.example.com or http://www.example.com and sometimes  example.com (but not on Github, for example).</p> <p>Some text to show that the reference links can follow later.</p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#images","title":"Images","text":"<pre><code>Here's our logo (hover to see the title text):\n\nInline-style: \n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\n\nReference-style: \n![alt text][logo]\n\n[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 2\"\n</code></pre> <p>Here's our logo (hover to see the title text):</p> <p>Inline-style:  </p> <p>Reference-style:  </p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#tables","title":"Tables","text":"<pre><code>Colons can be used to align columns.\n\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\nThere must be at least 3 dashes separating each header cell.\nThe outer pipes (|) are optional, and you don't need to make the \nraw Markdown line up prettily. You can also use inline Markdown.\n\nMarkdown | Less | Pretty\n--- | --- | ---\n*Still* | `renders` | **nicely**\n1 | 2 | 3\n</code></pre> <p>Colons can be used to align columns.</p>    Tables Are Cool     col 3 is right-aligned $1600   col 2 is centered $12   zebra stripes are neat $1    <p>There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the  raw Markdown line up prettily. You can also use inline Markdown.</p>    Markdown Less Pretty     Still <code>renders</code> nicely   1 2 3"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#blockquotes","title":"Blockquotes","text":"<pre><code>&gt; Blockquotes are very handy in email to emulate reply text.\n&gt; This line is part of the same quote.\n\nQuote break.\n\n&gt; This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. \n</code></pre>  <p>Blockquotes are very handy in email to emulate reply text. This line is part of the same quote.</p>  <p>Quote break.</p>  <p>This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. </p>"},{"location":"src/mkdoxy/tests/files/src-animal/markdown-demo/#inline-html","title":"Inline HTML","text":"<pre><code>&lt;dl&gt;\n  &lt;dt&gt;Definition list&lt;/dt&gt;\n  &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt;\n\n  &lt;dt&gt;Markdown in HTML&lt;/dt&gt;\n  &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre>  Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags."},{"location":"ltapi/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct Cookie </li> <li>struct EventHandler_s </li> <li>class FlashClass </li> <li>struct FlashId Flash chip ID structure. </li> <li>class FunctionRequestHandler </li> <li>class HTTPClient </li> <li>struct RequestArgument </li> <li>struct HTTPUpload </li> <li>class IPreferences </li> <li>class ITwoWire </li> <li>class IWiFiClient </li> <li>class IWiFiClientSecure </li> <li>class IWiFiServer </li> <li>class IWiFiUDP </li> <li>class LibreTuya Main LibreTuya API class. </li> <li>class LwIPClient </li> <li>class LwIPRxBuffer </li> <li>class LwIPServer </li> <li>class LwIPUDP </li> <li>class MbedTLSClient </li> <li>struct PinInfo </li> <li>class RequestHandler </li> <li>class StaticRequestHandler </li> <li>class StreamString </li> <li>class UpdateClass </li> <li>class Uri </li> <li>class UriBraces </li> <li>class UriGlob </li> <li>class UriRegex </li> <li>class WebServer </li> <li>struct RequestArgument </li> <li>class WiFiClass </li> <li>struct WiFiMacAddr </li> <li>class WiFiMulti </li> <li>struct WiFiScanAP </li> <li>struct WiFiScanData </li> <li>struct WifiAPlist_t </li> <li>namespace arduino </li> <li>class IPv6Address </li> <li>union arduino_event_info_t </li> <li>struct arduino_event_t </li> <li>class base64 </li> <li>struct base64_decodestate </li> <li>struct base64_encodestate </li> <li>class cbuf </li> <li>struct esp_ip4_addr </li> <li>struct esp_ip6_addr </li> <li>struct esp_netif_ip6_info_t IPV6 IP address information. </li> <li>struct esp_netif_ip_info_t </li> <li>namespace fs </li> <li>class FS </li> <li>class FSImpl </li> <li>class File </li> <li>class FileImpl </li> <li>struct ip_event_ap_staipassigned_t </li> <li>struct ip_event_got_ip6_t </li> <li>struct ip_event_got_ip_t </li> <li>class mDNS </li> <li>namespace mime </li> <li>struct Entry </li> <li>struct wifi_event_action_tx_status_t </li> <li>struct wifi_event_ap_probe_req_rx_t </li> <li>struct wifi_event_ap_staconnected_t </li> <li>struct wifi_event_ap_stadisconnected_t </li> <li>struct wifi_event_ftm_report_t </li> <li>struct wifi_event_roc_done_t </li> <li>struct wifi_event_sta_authmode_change_t </li> <li>struct wifi_event_sta_connected_t </li> <li>struct wifi_event_sta_disconnected_t </li> <li>struct wifi_event_sta_scan_done_t </li> <li>struct wifi_event_sta_wps_er_pin_t </li> <li>struct wifi_event_sta_wps_er_success_t </li> <li>struct wifi_ftm_report_entry_t </li> </ul>"},{"location":"ltapi/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir arduino </li> <li>dir libretuya <ul> <li>dir api </li> <li>file Events.cpp </li> <li>file Events.h </li> <li>file FS.cpp </li> <li>file FS.h </li> <li>file Preferences.h </li> <li>file SoftwareSerial.cpp </li> <li>file SoftwareSerial.h </li> <li>file WiFiClient.h </li> <li>file WiFiClientSecure.h </li> <li>file WiFiServer.h </li> <li>file WiFiUdp.h </li> <li>file Wire.h </li> <li>dir WiFi <ul> <li>file WiFi.cpp </li> <li>file WiFi.h </li> <li>file WiFiAP.cpp </li> <li>file WiFiEvents.cpp </li> <li>file WiFiEvents.h </li> <li>file WiFiGeneric.cpp </li> <li>file WiFiSTA.cpp </li> <li>file WiFiScan.cpp </li> <li>file WiFiType.h </li> </ul> </li> <li>dir common </li> <li>file WMath.cpp </li> <li>file abi.cpp </li> <li>file dtostrf.c </li> <li>file hooks.c </li> <li>file itoa.c </li> <li>file serial_event.cpp </li> <li>file wiring_shift.c </li> <li>dir compat </li> <li>file FS.h </li> <li>file FSImpl.h </li> <li>file WiFiAP.h </li> <li>file md5.h </li> <li>file pgmspace.h </li> <li>file vfs_api.h </li> <li>dir core </li> <li>file ChipType.h </li> <li>file LibreTuyaAPI.cpp </li> <li>file LibreTuyaAPI.h </li> <li>file LibreTuyaClass.cpp </li> <li>file LibreTuyaClass.h </li> <li>file LibreTuyaCompat.cpp </li> <li>file LibreTuyaCompat.h </li> <li>file LibreTuyaConfig.h </li> <li>file LibreTuyaCustom.c </li> <li>file LibreTuyaCustom.h </li> <li>file SerialExtern.h </li> <li>file lt_logger.c </li> <li>file lt_logger.h </li> <li>file main.cpp </li> <li>dir libraries </li> <li>dir Flash <ul> <li>file Flash.cpp </li> <li>file Flash.h </li> </ul> </li> <li>dir HTTPClient <ul> <li>file HTTPClient.cpp </li> <li>file HTTPClient.h </li> <li>dir strptime </li> <li>file strptime.c </li> <li>file strptime.h </li> </ul> </li> <li>dir MD5 <ul> <li>file MD5.h </li> <li>file MD5HostapdImpl.h </li> <li>file MD5MbedTLSImpl.cpp </li> <li>file MD5MbedTLSImpl.h </li> <li>file MD5PolarSSLImpl.cpp </li> <li>file MD5PolarSSLImpl.h </li> </ul> </li> <li>dir NetUtils <ul> <li>file IPv6Address.cpp </li> <li>file IPv6Address.h </li> <li>dir api </li> <li>file IPv6Address.h </li> <li>dir lwip </li> <li>file LwIPClient.cpp </li> <li>file LwIPClient.h </li> <li>file LwIPRxBuffer.cpp </li> <li>file LwIPRxBuffer.h </li> <li>file LwIPServer.cpp </li> <li>file LwIPServer.h </li> <li>file LwIPUdp.cpp </li> <li>file LwIPUdp.h </li> <li>dir ssl </li> <li>file MbedTLSClient.cpp </li> <li>file MbedTLSClient.h </li> </ul> </li> <li>dir StreamString <ul> <li>file StreamString.cpp </li> <li>file StreamString.h </li> </ul> </li> <li>dir Update <ul> <li>file Update.cpp </li> <li>file Update.h </li> <li>file UpdateUtil.cpp </li> </ul> </li> <li>dir WebServer <ul> <li>file HTTP_Method.h </li> <li>file Parsing.cpp </li> <li>file Uri.h </li> <li>file WebServer.cpp </li> <li>file WebServer.h </li> <li>dir detail </li> <li>file RequestHandler.h </li> <li>file RequestHandlersImpl.h </li> <li>file mimetable.cpp </li> <li>file mimetable.h </li> <li>dir uri </li> <li>file UriBraces.h </li> <li>file UriGlob.h </li> <li>file UriRegex.h </li> </ul> </li> <li>dir WiFiMulti <ul> <li>file WiFiMulti.cpp </li> <li>file WiFiMulti.h </li> </ul> </li> <li>dir base64 <ul> <li>dir libb64 </li> <li>file cdecode.c </li> <li>file cdecode.h </li> <li>file cencode.c </li> <li>file cencode.h </li> <li>file base64.cpp </li> <li>file base64.h </li> </ul> </li> <li>dir cbuf <ul> <li>file cbuf.cpp </li> <li>file cbuf.h </li> </ul> </li> <li>dir mDNS <ul> <li>file ESPmDNS.h </li> <li>file LwIPmDNS.cpp </li> <li>file mDNS.cpp </li> <li>file mDNS.h </li> </ul> </li> <li>dir port </li> <li>dir flashdb <ul> <li>file fal_cfg.h </li> <li>file fdb_cfg.h </li> </ul> </li> <li>dir printf <ul> <li>file printf_config.h </li> <li>file putchar.c </li> <li>file puts.c </li> </ul> </li> <li>dir posix </li> <li>file lt_posix_api.h </li> <li>file strcasecmp.c </li> <li>file strdup.c </li> <li>file time.c </li> </ul> </li> </ul>"},{"location":"ltapi/struct_cookie/","title":"Struct Cookie","text":"<p>ClassList &gt; Cookie</p>"},{"location":"ltapi/struct_cookie/#public-attributes","title":"Public Attributes","text":"Type Name     time_t date   = = 0   String domain    time_t duration   = = 0   struct Cookie::@1 expires    String host    bool http_only   = = false   struct Cookie::@2 max_age    String name    String path   = = \"\"   bool secure   = = false   bool valid   = = false   String value"},{"location":"ltapi/struct_cookie/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_cookie/#variable-date","title":"variable date","text":"<pre><code>time_t Cookie::date;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-domain","title":"variable domain","text":"<pre><code>String Cookie::domain;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-duration","title":"variable duration","text":"<pre><code>time_t Cookie::duration;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-expires","title":"variable expires","text":"<pre><code>struct Cookie::@1 Cookie::expires;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-host","title":"variable host","text":"<pre><code>String Cookie::host;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-http_only","title":"variable http_only","text":"<pre><code>bool Cookie::http_only;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-max_age","title":"variable max_age","text":"<pre><code>struct Cookie::@2 Cookie::max_age;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-name","title":"variable name","text":"<pre><code>String Cookie::name;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-path","title":"variable path","text":"<pre><code>String Cookie::path;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-secure","title":"variable secure","text":"<pre><code>bool Cookie::secure;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-valid","title":"variable valid","text":"<pre><code>bool Cookie::valid;\n</code></pre>"},{"location":"ltapi/struct_cookie/#variable-value","title":"variable value","text":"<pre><code>String Cookie::value;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/struct_event_handler__s/","title":"Struct EventHandler_s","text":"<p>ClassList &gt; EventHandler_s</p>"},{"location":"ltapi/struct_event_handler__s/#public-attributes","title":"Public Attributes","text":"Type Name     EventCb cb    EventId eventId    EventFuncCb fcb    uint16_t id    EventSysCb scb"},{"location":"ltapi/struct_event_handler__s/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     uint16_t lastId   = = 1"},{"location":"ltapi/struct_event_handler__s/#public-functions","title":"Public Functions","text":"Type Name      EventHandler_s ()"},{"location":"ltapi/struct_event_handler__s/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_event_handler__s/#variable-cb","title":"variable cb","text":"<pre><code>EventCb EventHandler_s::cb;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-eventid","title":"variable eventId","text":"<pre><code>EventId EventHandler_s::eventId;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-fcb","title":"variable fcb","text":"<pre><code>EventFuncCb EventHandler_s::fcb;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-id","title":"variable id","text":"<pre><code>uint16_t EventHandler_s::id;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#variable-scb","title":"variable scb","text":"<pre><code>EventSysCb EventHandler_s::scb;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/struct_event_handler__s/#variable-lastid","title":"variable lastId","text":"<pre><code>uint16_t EventHandler_s::lastId;\n</code></pre>"},{"location":"ltapi/struct_event_handler__s/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/struct_event_handler__s/#function-eventhandler_s","title":"function EventHandler_s","text":"<pre><code>inline EventHandler_s::EventHandler_s () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Events.h</code></p>"},{"location":"ltapi/class_flash_class/","title":"Class FlashClass","text":"<p>ClassList &gt; FlashClass</p>"},{"location":"ltapi/class_flash_class/#public-functions","title":"Public Functions","text":"Type Name     bool eraseSector (uint32_t offset)    FlashId getChipId ()    uint32_t getSize ()    bool readBlock (uint32_t offset, uint8_t * data, size_t size)    bool writeBlock (uint32_t offset, uint8_t * data, size_t size)"},{"location":"ltapi/class_flash_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_flash_class/#function-erasesector","title":"function eraseSector","text":"<pre><code>bool FlashClass::eraseSector (\n    uint32_t offset\n) \n</code></pre>"},{"location":"ltapi/class_flash_class/#function-getchipid","title":"function getChipId","text":"<pre><code>FlashId FlashClass::getChipId () \n</code></pre>"},{"location":"ltapi/class_flash_class/#function-getsize","title":"function getSize","text":"<pre><code>uint32_t FlashClass::getSize () \n</code></pre>"},{"location":"ltapi/class_flash_class/#function-readblock","title":"function readBlock","text":"<pre><code>bool FlashClass::readBlock (\n    uint32_t offset,\n    uint8_t * data,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_flash_class/#function-writeblock","title":"function writeBlock","text":"<pre><code>bool FlashClass::writeBlock (\n    uint32_t offset,\n    uint8_t * data,\n    size_t size\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Flash/Flash.h</code></p>"},{"location":"ltapi/struct_flash_id/","title":"Struct FlashId","text":"<p>ClassList &gt; FlashId</p> <p>Flash chip ID structure. </p> <ul> <li><code>#include &lt;LibreTuyaClass.h&gt;</code></li> </ul>"},{"location":"ltapi/struct_flash_id/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t chipId    uint8_t chipSizeId    uint8_t manufacturerId"},{"location":"ltapi/struct_flash_id/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_flash_id/#variable-chipid","title":"variable chipId","text":"<pre><code>uint8_t FlashId::chipId;\n</code></pre>"},{"location":"ltapi/struct_flash_id/#variable-chipsizeid","title":"variable chipSizeId","text":"<pre><code>uint8_t FlashId::chipSizeId;\n</code></pre>"},{"location":"ltapi/struct_flash_id/#variable-manufacturerid","title":"variable manufacturerId","text":"<pre><code>uint8_t FlashId::manufacturerId;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaClass.h</code></p>"},{"location":"ltapi/class_function_request_handler/","title":"Class FunctionRequestHandler","text":"<p>ClassList &gt; FunctionRequestHandler</p> <p>Inherits the following classes: RequestHandler</p>"},{"location":"ltapi/class_function_request_handler/#public-functions","title":"Public Functions","text":"Type Name      FunctionRequestHandler (WebServer::THandlerFunction fn, WebServer::THandlerFunction ufn, const Uri &amp; uri, HTTPMethod method)    virtual bool canHandle (HTTPMethod requestMethod, String requestUri) override   virtual bool canUpload (String requestUri) override   virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri) override   virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload) override    ~FunctionRequestHandler ()"},{"location":"ltapi/class_function_request_handler/#public-functions-inherited-from-requesthandler","title":"Public Functions inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     virtual bool canHandle (HTTPMethod method, String uri)    virtual bool canUpload (String uri)    virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri)    RequestHandler * next ()    void next (RequestHandler * r)    const String &amp; pathArg (unsigned int i)    virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload)    virtual ~RequestHandler ()"},{"location":"ltapi/class_function_request_handler/#protected-attributes","title":"Protected Attributes","text":"Type Name     WebServer::THandlerFunction _fn    HTTPMethod _method    WebServer::THandlerFunction _ufn    Uri * _uri"},{"location":"ltapi/class_function_request_handler/#protected-attributes-inherited-from-requesthandler","title":"Protected Attributes inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     std::vector&lt; String &gt; pathArgs"},{"location":"ltapi/class_function_request_handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_function_request_handler/#function-functionrequesthandler","title":"function FunctionRequestHandler","text":"<pre><code>inline FunctionRequestHandler::FunctionRequestHandler (\n    WebServer::THandlerFunction fn,\n    WebServer::THandlerFunction ufn,\n    const Uri &amp; uri,\n    HTTPMethod method\n) \n</code></pre>"},{"location":"ltapi/class_function_request_handler/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool FunctionRequestHandler::canHandle (\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::canHandle</p>"},{"location":"ltapi/class_function_request_handler/#function-canupload","title":"function canUpload","text":"<pre><code>inline virtual bool FunctionRequestHandler::canUpload (\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::canUpload</p>"},{"location":"ltapi/class_function_request_handler/#function-handle","title":"function handle","text":"<pre><code>inline virtual bool FunctionRequestHandler::handle (\n    WebServer &amp; server,\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::handle</p>"},{"location":"ltapi/class_function_request_handler/#function-upload","title":"function upload","text":"<pre><code>inline virtual void FunctionRequestHandler::upload (\n    WebServer &amp; server,\n    String requestUri,\n    HTTPUpload &amp; upload\n) override\n</code></pre> <p>Implements RequestHandler::upload</p>"},{"location":"ltapi/class_function_request_handler/#function-functionrequesthandler_1","title":"function ~FunctionRequestHandler","text":"<pre><code>inline FunctionRequestHandler::~FunctionRequestHandler () \n</code></pre>"},{"location":"ltapi/class_function_request_handler/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_function_request_handler/#variable-_fn","title":"variable _fn","text":"<pre><code>WebServer::THandlerFunction FunctionRequestHandler::_fn;\n</code></pre>"},{"location":"ltapi/class_function_request_handler/#variable-_method","title":"variable _method","text":"<pre><code>HTTPMethod FunctionRequestHandler::_method;\n</code></pre>"},{"location":"ltapi/class_function_request_handler/#variable-_ufn","title":"variable _ufn","text":"<pre><code>WebServer::THandlerFunction FunctionRequestHandler::_ufn;\n</code></pre>"},{"location":"ltapi/class_function_request_handler/#variable-_uri","title":"variable _uri","text":"<pre><code>Uri* FunctionRequestHandler::_uri;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/RequestHandlersImpl.h</code></p>"},{"location":"ltapi/class_h_t_t_p_client/","title":"Class HTTPClient","text":"<p>ClassList &gt; HTTPClient</p>"},{"location":"ltapi/class_h_t_t_p_client/#public-functions","title":"Public Functions","text":"Type Name     int GET () request handling    HTTPClient ()    int PATCH (uint8_t * payload, size_t size)    int PATCH (String payload)    int POST (uint8_t * payload, size_t size)    int POST (String payload)    int PUT (uint8_t * payload, size_t size)    int PUT (String payload)    void addHeader (const String &amp; name, const String &amp; value, bool first=false, bool replace=true)    bool begin (WiFiClient &amp; client, String url)    bool begin (WiFiClient &amp; client, String host, uint16_t port, String uri=\"/\", bool https=false)    bool begin (String url)    bool begin (String url, const char * CAcert)    bool begin (String host, uint16_t port, String uri=\"/\")    bool begin (String host, uint16_t port, String uri, const char * CAcert)    bool begin (String host, uint16_t port, String uri, const char * CAcert, const char * cli_cert, const char * cli_key)    void clearAllCookies ()    void collectHeaders (const char * headerKeys, const size_t headerKeysCount) Response handling.   bool connected (void)    void end (void)    const String &amp; getLocation (void)    int getSize (void)    WiFiClient &amp; getStream (void)    WiFiClient * getStreamPtr (void)    bool hasHeader (const char * name)    String header (const char * name)    String header (size_t i)    String headerName (size_t i)    int headers ()    void resetCookieJar ()    int sendRequest (const char * type, String payload)    int sendRequest (const char * type, uint8_t * payload=NULL, size_t size=0)    int sendRequest (const char * type, Stream * stream, size_t size=0)    void setAuthorization (const char * user, const char * password)    void setAuthorization (const char * auth)    void setAuthorizationType (const char * authType)    void setConnectTimeout (int32_t connectTimeout)    void setCookieJar (CookieJar * cookieJar) Cookie jar support.   void setFollowRedirects (followRedirects_t follow)    void setRedirectLimit (uint16_t limit)    void setReuse (bool reuse)    void setTimeout (uint16_t timeout)    bool setURL (const String &amp; url)    void setUserAgent (const String &amp; userAgent) keep-alive   void useHTTP10 (bool usehttp10=true)    int writeToStream (Stream * stream)     ~HTTPClient ()"},{"location":"ltapi/class_h_t_t_p_client/#public-static-functions","title":"Public Static Functions","text":"Type Name     String errorToString (int error)"},{"location":"ltapi/class_h_t_t_p_client/#protected-attributes","title":"Protected Attributes","text":"Type Name     String _authorizationType   = = \"Basic\"   String _base64Authorization    bool _canReuse   = = false   WiFiClient * _client   = = nullptr   int32_t _connectTimeout   = = -1   CookieJar * _cookieJar   = = nullptrCookie jar support.   RequestArgument * _currentHeaders   = = nullptrResponse handling.   followRedirects_t _followRedirects   = = HTTPC_DISABLE_FOLLOW_REDIRECTS   size_t _headerKeysCount   = = 0   String _headers    String _host request handling   String _location    uint16_t _port   = = 0   String _protocol    uint16_t _redirectLimit   = = 10   int _returnCode   = = 0   bool _reuse   = = true   bool _secure   = = false   int _size   = = -1   std::unique_ptr&lt; WiFiClient &gt; _tcpDeprecated    uint16_t _tcpTimeout   = = HTTPCLIENT_DEFAULT_TCP_TIMEOUT   transferEncoding_t _transferEncoding   = = HTTPC_TE_IDENTITY   TransportTraitsPtr _transportTraits    String _uri    bool _useHTTP10   = = false   String _userAgent   = = \"ESP32HTTPClient\""},{"location":"ltapi/class_h_t_t_p_client/#protected-functions","title":"Protected Functions","text":"Type Name     bool beginInternal (String url, const char * expectedProtocol)    void clear ()    bool connect (void)    void disconnect (bool preserveClient=false)    bool generateCookieString (String * cookieString)    int handleHeaderResponse ()    int returnError (int error)    bool sendHeader (const char * type)    void setCookie (String date, String headerValue) Cookie jar support.   int writeToStreamDataBlock (Stream * stream, int len)"},{"location":"ltapi/class_h_t_t_p_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#function-get","title":"function GET","text":"<pre><code>int HTTPClient::GET () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-httpclient","title":"function HTTPClient","text":"<pre><code>HTTPClient::HTTPClient () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-patch-12","title":"function PATCH [1/2]","text":"<pre><code>int HTTPClient::PATCH (\n    uint8_t * payload,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-patch-22","title":"function PATCH [2/2]","text":"<pre><code>int HTTPClient::PATCH (\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-post-12","title":"function POST [1/2]","text":"<pre><code>int HTTPClient::POST (\n    uint8_t * payload,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-post-22","title":"function POST [2/2]","text":"<pre><code>int HTTPClient::POST (\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-put-12","title":"function PUT [1/2]","text":"<pre><code>int HTTPClient::PUT (\n    uint8_t * payload,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-put-22","title":"function PUT [2/2]","text":"<pre><code>int HTTPClient::PUT (\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-addheader","title":"function addHeader","text":"<pre><code>void HTTPClient::addHeader (\n    const String &amp; name,\n    const String &amp; value,\n    bool first=false,\n    bool replace=true\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-17","title":"function begin [1/7]","text":"<pre><code>bool HTTPClient::begin (\n    WiFiClient &amp; client,\n    String url\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-27","title":"function begin [2/7]","text":"<pre><code>bool HTTPClient::begin (\n    WiFiClient &amp; client,\n    String host,\n    uint16_t port,\n    String uri=\"/\",\n    bool https=false\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-37","title":"function begin [3/7]","text":"<pre><code>bool HTTPClient::begin (\n    String url\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-47","title":"function begin [4/7]","text":"<pre><code>bool HTTPClient::begin (\n    String url,\n    const char * CAcert\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-57","title":"function begin [5/7]","text":"<pre><code>bool HTTPClient::begin (\n    String host,\n    uint16_t port,\n    String uri=\"/\"\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-67","title":"function begin [6/7]","text":"<pre><code>bool HTTPClient::begin (\n    String host,\n    uint16_t port,\n    String uri,\n    const char * CAcert\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-begin-77","title":"function begin [7/7]","text":"<pre><code>bool HTTPClient::begin (\n    String host,\n    uint16_t port,\n    String uri,\n    const char * CAcert,\n    const char * cli_cert,\n    const char * cli_key\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-clearallcookies","title":"function clearAllCookies","text":"<pre><code>void HTTPClient::clearAllCookies () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-collectheaders","title":"function collectHeaders","text":"<pre><code>void HTTPClient::collectHeaders (\n    const char * headerKeys,\n    const size_t headerKeysCount\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-connected","title":"function connected","text":"<pre><code>bool HTTPClient::connected (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-end","title":"function end","text":"<pre><code>void HTTPClient::end (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getlocation","title":"function getLocation","text":"<pre><code>const String &amp; HTTPClient::getLocation (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getsize","title":"function getSize","text":"<pre><code>int HTTPClient::getSize (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getstream","title":"function getStream","text":"<pre><code>WiFiClient &amp; HTTPClient::getStream (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-getstreamptr","title":"function getStreamPtr","text":"<pre><code>WiFiClient * HTTPClient::getStreamPtr (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-hasheader","title":"function hasHeader","text":"<pre><code>bool HTTPClient::hasHeader (\n    const char * name\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-header-12","title":"function header [1/2]","text":"<pre><code>String HTTPClient::header (\n    const char * name\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-header-22","title":"function header [2/2]","text":"<pre><code>String HTTPClient::header (\n    size_t i\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-headername","title":"function headerName","text":"<pre><code>String HTTPClient::headerName (\n    size_t i\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-headers","title":"function headers","text":"<pre><code>int HTTPClient::headers () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-resetcookiejar","title":"function resetCookieJar","text":"<pre><code>void HTTPClient::resetCookieJar () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendrequest-13","title":"function sendRequest [1/3]","text":"<pre><code>int HTTPClient::sendRequest (\n    const char * type,\n    String payload\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendrequest-23","title":"function sendRequest [2/3]","text":"<pre><code>int HTTPClient::sendRequest (\n    const char * type,\n    uint8_t * payload=NULL,\n    size_t size=0\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendrequest-33","title":"function sendRequest [3/3]","text":"<pre><code>int HTTPClient::sendRequest (\n    const char * type,\n    Stream * stream,\n    size_t size=0\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setauthorization-12","title":"function setAuthorization [1/2]","text":"<pre><code>void HTTPClient::setAuthorization (\n    const char * user,\n    const char * password\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setauthorization-22","title":"function setAuthorization [2/2]","text":"<pre><code>void HTTPClient::setAuthorization (\n    const char * auth\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setauthorizationtype","title":"function setAuthorizationType","text":"<pre><code>void HTTPClient::setAuthorizationType (\n    const char * authType\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setconnecttimeout","title":"function setConnectTimeout","text":"<pre><code>void HTTPClient::setConnectTimeout (\n    int32_t connectTimeout\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setcookiejar","title":"function setCookieJar","text":"<pre><code>void HTTPClient::setCookieJar (\n    CookieJar * cookieJar\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setfollowredirects","title":"function setFollowRedirects","text":"<pre><code>void HTTPClient::setFollowRedirects (\n    followRedirects_t follow\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setredirectlimit","title":"function setRedirectLimit","text":"<pre><code>void HTTPClient::setRedirectLimit (\n    uint16_t limit\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setreuse","title":"function setReuse","text":"<pre><code>void HTTPClient::setReuse (\n    bool reuse\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-settimeout","title":"function setTimeout","text":"<pre><code>void HTTPClient::setTimeout (\n    uint16_t timeout\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-seturl","title":"function setURL","text":"<pre><code>bool HTTPClient::setURL (\n    const String &amp; url\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setuseragent","title":"function setUserAgent","text":"<pre><code>void HTTPClient::setUserAgent (\n    const String &amp; userAgent\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-usehttp10","title":"function useHTTP10","text":"<pre><code>void HTTPClient::useHTTP10 (\n    bool usehttp10=true\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-writetostream","title":"function writeToStream","text":"<pre><code>int HTTPClient::writeToStream (\n    Stream * stream\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-httpclient_1","title":"function ~HTTPClient","text":"<pre><code>HTTPClient::~HTTPClient () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#function-errortostring","title":"function errorToString","text":"<pre><code>static String HTTPClient::errorToString (\n    int error\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#variable-_authorizationtype","title":"variable _authorizationType","text":"<pre><code>String HTTPClient::_authorizationType;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_base64authorization","title":"variable _base64Authorization","text":"<pre><code>String HTTPClient::_base64Authorization;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_canreuse","title":"variable _canReuse","text":"<pre><code>bool HTTPClient::_canReuse;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_client","title":"variable _client","text":"<pre><code>WiFiClient* HTTPClient::_client;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_connecttimeout","title":"variable _connectTimeout","text":"<pre><code>int32_t HTTPClient::_connectTimeout;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_cookiejar","title":"variable _cookieJar","text":"<pre><code>CookieJar* HTTPClient::_cookieJar;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_currentheaders","title":"variable _currentHeaders","text":"<pre><code>RequestArgument* HTTPClient::_currentHeaders;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_followredirects","title":"variable _followRedirects","text":"<pre><code>followRedirects_t HTTPClient::_followRedirects;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_headerkeyscount","title":"variable _headerKeysCount","text":"<pre><code>size_t HTTPClient::_headerKeysCount;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_headers","title":"variable _headers","text":"<pre><code>String HTTPClient::_headers;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_host","title":"variable _host","text":"<pre><code>String HTTPClient::_host;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_location","title":"variable _location","text":"<pre><code>String HTTPClient::_location;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_port","title":"variable _port","text":"<pre><code>uint16_t HTTPClient::_port;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_protocol","title":"variable _protocol","text":"<pre><code>String HTTPClient::_protocol;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_redirectlimit","title":"variable _redirectLimit","text":"<pre><code>uint16_t HTTPClient::_redirectLimit;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_returncode","title":"variable _returnCode","text":"<pre><code>int HTTPClient::_returnCode;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_reuse","title":"variable _reuse","text":"<pre><code>bool HTTPClient::_reuse;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_secure","title":"variable _secure","text":"<pre><code>bool HTTPClient::_secure;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_size","title":"variable _size","text":"<pre><code>int HTTPClient::_size;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_tcpdeprecated","title":"variable _tcpDeprecated","text":"<pre><code>std::unique_ptr&lt;WiFiClient&gt; HTTPClient::_tcpDeprecated;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_tcptimeout","title":"variable _tcpTimeout","text":"<pre><code>uint16_t HTTPClient::_tcpTimeout;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_transferencoding","title":"variable _transferEncoding","text":"<pre><code>transferEncoding_t HTTPClient::_transferEncoding;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_transporttraits","title":"variable _transportTraits","text":"<pre><code>TransportTraitsPtr HTTPClient::_transportTraits;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_uri","title":"variable _uri","text":"<pre><code>String HTTPClient::_uri;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_usehttp10","title":"variable _useHTTP10","text":"<pre><code>bool HTTPClient::_useHTTP10;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#variable-_useragent","title":"variable _userAgent","text":"<pre><code>String HTTPClient::_userAgent;\n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"ltapi/class_h_t_t_p_client/#function-begininternal","title":"function beginInternal","text":"<pre><code>bool HTTPClient::beginInternal (\n    String url,\n    const char * expectedProtocol\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-clear","title":"function clear","text":"<pre><code>void HTTPClient::clear () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-connect","title":"function connect","text":"<pre><code>bool HTTPClient::connect (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-disconnect","title":"function disconnect","text":"<pre><code>void HTTPClient::disconnect (\n    bool preserveClient=false\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-generatecookiestring","title":"function generateCookieString","text":"<pre><code>bool HTTPClient::generateCookieString (\n    String * cookieString\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-handleheaderresponse","title":"function handleHeaderResponse","text":"<pre><code>int HTTPClient::handleHeaderResponse () \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-returnerror","title":"function returnError","text":"<pre><code>int HTTPClient::returnError (\n    int error\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-sendheader","title":"function sendHeader","text":"<pre><code>bool HTTPClient::sendHeader (\n    const char * type\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-setcookie","title":"function setCookie","text":"<pre><code>void HTTPClient::setCookie (\n    String date,\n    String headerValue\n) \n</code></pre>"},{"location":"ltapi/class_h_t_t_p_client/#function-writetostreamdatablock","title":"function writeToStreamDataBlock","text":"<pre><code>int HTTPClient::writeToStreamDataBlock (\n    Stream * stream,\n    int len\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/","title":"Struct HTTPClient::RequestArgument","text":"<p>ClassList &gt; HTTPClient &gt; RequestArgument</p>"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#public-attributes","title":"Public Attributes","text":"Type Name     String key    String value"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#variable-key","title":"variable key","text":"<pre><code>String HTTPClient::RequestArgument::key;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_client_1_1_request_argument/#variable-value","title":"variable value","text":"<pre><code>String HTTPClient::RequestArgument::value;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/struct_h_t_t_p_upload/","title":"Struct HTTPUpload","text":"<p>ClassList &gt; HTTPUpload</p>"},{"location":"ltapi/struct_h_t_t_p_upload/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t buf    size_t currentSize    String filename    String name    HTTPUploadStatus status    size_t totalSize    String type"},{"location":"ltapi/struct_h_t_t_p_upload/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_h_t_t_p_upload/#variable-buf","title":"variable buf","text":"<pre><code>uint8_t HTTPUpload::buf[HTTP_UPLOAD_BUFLEN];\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-currentsize","title":"variable currentSize","text":"<pre><code>size_t HTTPUpload::currentSize;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-filename","title":"variable filename","text":"<pre><code>String HTTPUpload::filename;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-name","title":"variable name","text":"<pre><code>String HTTPUpload::name;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-status","title":"variable status","text":"<pre><code>HTTPUploadStatus HTTPUpload::status;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-totalsize","title":"variable totalSize","text":"<pre><code>size_t HTTPUpload::totalSize;\n</code></pre>"},{"location":"ltapi/struct_h_t_t_p_upload/#variable-type","title":"variable type","text":"<pre><code>String HTTPUpload::type;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/WebServer.h</code></p>"},{"location":"ltapi/class_i_preferences/","title":"Class IPreferences","text":"<p>ClassList &gt; IPreferences</p>"},{"location":"ltapi/class_i_preferences/#public-functions","title":"Public Functions","text":"Type Name      IPreferences ()    bool begin (const char * name, bool readOnly=false, const char * partition_label=NULL)    bool clear ()    void end ()    size_t freeEntries ()    bool getBool (const char * key, bool defaultValue=false)    size_t getBytes (const char * key, void * buf, size_t maxLen)    size_t getBytesLength (const char * key)    int8_t getChar (const char * key, int8_t defaultValue=0)    double_t getDouble (const char * key, double_t defaultValue=NAN)    float_t getFloat (const char * key, float_t defaultValue=NAN)    int32_t getInt (const char * key, int32_t defaultValue=0)    int32_t getLong (const char * key, int32_t defaultValue=0)    int64_t getLong64 (const char * key, int64_t defaultValue=0)    int16_t getShort (const char * key, int16_t defaultValue=0)    size_t getString (const char * key, char * value, size_t maxLen)    String getString (const char * key, String defaultValue=String())    PreferenceType getType (const char * key)    uint8_t getUChar (const char * key, uint8_t defaultValue=0)    uint32_t getUInt (const char * key, uint32_t defaultValue=0)    uint32_t getULong (const char * key, uint32_t defaultValue=0)    uint64_t getULong64 (const char * key, uint64_t defaultValue=0)    uint16_t getUShort (const char * key, uint16_t defaultValue=0)    bool isKey (const char * key)    size_t putBool (const char * key, bool value)    size_t putBytes (const char * key, const void * value, size_t len)    size_t putChar (const char * key, int8_t value)    size_t putDouble (const char * key, double_t value)    size_t putFloat (const char * key, float_t value)    size_t putInt (const char * key, int32_t value)    size_t putLong (const char * key, int32_t value)    size_t putLong64 (const char * key, int64_t value)    size_t putShort (const char * key, int16_t value)    size_t putString (const char * key, const char * value)    size_t putString (const char * key, String value)    size_t putUChar (const char * key, uint8_t value)    size_t putUInt (const char * key, uint32_t value)    size_t putULong (const char * key, uint32_t value)    size_t putULong64 (const char * key, uint64_t value)    size_t putUShort (const char * key, uint16_t value)    bool remove (const char * key)     ~IPreferences ()"},{"location":"ltapi/class_i_preferences/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_preferences/#function-ipreferences","title":"function IPreferences","text":"<pre><code>inline IPreferences::IPreferences () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-begin","title":"function begin","text":"<pre><code>bool IPreferences::begin (\n    const char * name,\n    bool readOnly=false,\n    const char * partition_label=NULL\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-clear","title":"function clear","text":"<pre><code>bool IPreferences::clear () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-end","title":"function end","text":"<pre><code>void IPreferences::end () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-freeentries","title":"function freeEntries","text":"<pre><code>size_t IPreferences::freeEntries () \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getbool","title":"function getBool","text":"<pre><code>bool IPreferences::getBool (\n    const char * key,\n    bool defaultValue=false\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getbytes","title":"function getBytes","text":"<pre><code>size_t IPreferences::getBytes (\n    const char * key,\n    void * buf,\n    size_t maxLen\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getbyteslength","title":"function getBytesLength","text":"<pre><code>size_t IPreferences::getBytesLength (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getchar","title":"function getChar","text":"<pre><code>int8_t IPreferences::getChar (\n    const char * key,\n    int8_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getdouble","title":"function getDouble","text":"<pre><code>double_t IPreferences::getDouble (\n    const char * key,\n    double_t defaultValue=NAN\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getfloat","title":"function getFloat","text":"<pre><code>float_t IPreferences::getFloat (\n    const char * key,\n    float_t defaultValue=NAN\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getint","title":"function getInt","text":"<pre><code>int32_t IPreferences::getInt (\n    const char * key,\n    int32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getlong","title":"function getLong","text":"<pre><code>int32_t IPreferences::getLong (\n    const char * key,\n    int32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getlong64","title":"function getLong64","text":"<pre><code>int64_t IPreferences::getLong64 (\n    const char * key,\n    int64_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getshort","title":"function getShort","text":"<pre><code>int16_t IPreferences::getShort (\n    const char * key,\n    int16_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getstring-12","title":"function getString [1/2]","text":"<pre><code>size_t IPreferences::getString (\n    const char * key,\n    char * value,\n    size_t maxLen\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getstring-22","title":"function getString [2/2]","text":"<pre><code>String IPreferences::getString (\n    const char * key,\n    String defaultValue=String()\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-gettype","title":"function getType","text":"<pre><code>PreferenceType IPreferences::getType (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getuchar","title":"function getUChar","text":"<pre><code>uint8_t IPreferences::getUChar (\n    const char * key,\n    uint8_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getuint","title":"function getUInt","text":"<pre><code>uint32_t IPreferences::getUInt (\n    const char * key,\n    uint32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getulong","title":"function getULong","text":"<pre><code>uint32_t IPreferences::getULong (\n    const char * key,\n    uint32_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getulong64","title":"function getULong64","text":"<pre><code>uint64_t IPreferences::getULong64 (\n    const char * key,\n    uint64_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-getushort","title":"function getUShort","text":"<pre><code>uint16_t IPreferences::getUShort (\n    const char * key,\n    uint16_t defaultValue=0\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-iskey","title":"function isKey","text":"<pre><code>bool IPreferences::isKey (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putbool","title":"function putBool","text":"<pre><code>size_t IPreferences::putBool (\n    const char * key,\n    bool value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putbytes","title":"function putBytes","text":"<pre><code>size_t IPreferences::putBytes (\n    const char * key,\n    const void * value,\n    size_t len\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putchar","title":"function putChar","text":"<pre><code>size_t IPreferences::putChar (\n    const char * key,\n    int8_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putdouble","title":"function putDouble","text":"<pre><code>size_t IPreferences::putDouble (\n    const char * key,\n    double_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putfloat","title":"function putFloat","text":"<pre><code>size_t IPreferences::putFloat (\n    const char * key,\n    float_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putint","title":"function putInt","text":"<pre><code>size_t IPreferences::putInt (\n    const char * key,\n    int32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putlong","title":"function putLong","text":"<pre><code>size_t IPreferences::putLong (\n    const char * key,\n    int32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putlong64","title":"function putLong64","text":"<pre><code>size_t IPreferences::putLong64 (\n    const char * key,\n    int64_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putshort","title":"function putShort","text":"<pre><code>size_t IPreferences::putShort (\n    const char * key,\n    int16_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putstring-12","title":"function putString [1/2]","text":"<pre><code>size_t IPreferences::putString (\n    const char * key,\n    const char * value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putstring-22","title":"function putString [2/2]","text":"<pre><code>size_t IPreferences::putString (\n    const char * key,\n    String value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putuchar","title":"function putUChar","text":"<pre><code>size_t IPreferences::putUChar (\n    const char * key,\n    uint8_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putuint","title":"function putUInt","text":"<pre><code>size_t IPreferences::putUInt (\n    const char * key,\n    uint32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putulong","title":"function putULong","text":"<pre><code>size_t IPreferences::putULong (\n    const char * key,\n    uint32_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putulong64","title":"function putULong64","text":"<pre><code>size_t IPreferences::putULong64 (\n    const char * key,\n    uint64_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-putushort","title":"function putUShort","text":"<pre><code>size_t IPreferences::putUShort (\n    const char * key,\n    uint16_t value\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-remove","title":"function remove","text":"<pre><code>bool IPreferences::remove (\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/class_i_preferences/#function-ipreferences_1","title":"function ~IPreferences","text":"<pre><code>inline IPreferences::~IPreferences () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Preferences.h</code></p>"},{"location":"ltapi/class_i_two_wire/","title":"Class ITwoWire","text":"<p>ClassList &gt; ITwoWire</p> <p>Inherits the following classes: Stream</p>"},{"location":"ltapi/class_i_two_wire/#public-functions","title":"Public Functions","text":"Type Name     virtual int available () = 0   bool begin ()    bool begin (uint8_t address)    virtual bool begin (int8_t sda, int8_t scl, uint32_t frequency=0) = 0   virtual bool begin (uint8_t address, int8_t sda, int8_t scl, uint32_t frequency=0) = 0   virtual void beginTransmission (uint8_t address) = 0   virtual bool end () = 0   virtual uint8_t endTransmission (bool stopBit) = 0   uint8_t endTransmission ()    virtual void flush () = 0   uint32_t getClock ()    void onReceive (void(*)(int) cb)    void onRequest (void(*)(void) cb)    virtual int peek () = 0   virtual int read () = 0   virtual size_t requestFrom (uint8_t address, size_t len, bool stopBit) = 0   size_t requestFrom (uint8_t address, size_t len)    virtual bool setClock (uint32_t freq) = 0   virtual bool setPins (int8_t sda, int8_t scl) = 0   virtual size_t write (const uint8_t * data, size_t len) = 0   virtual size_t write (uint8_t data)"},{"location":"ltapi/class_i_two_wire/#protected-attributes","title":"Protected Attributes","text":"Type Name     uint32_t _freq   = = 0   int8_t _scl   = = -1   int8_t _sda   = = -1   void(* onReceiveCallback    void(* onRequestCallback"},{"location":"ltapi/class_i_two_wire/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_two_wire/#function-available","title":"function available","text":"<pre><code>virtual int ITwoWire::available () = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-begin-14","title":"function begin [1/4]","text":"<pre><code>inline bool ITwoWire::begin () \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-begin-24","title":"function begin [2/4]","text":"<pre><code>inline bool ITwoWire::begin (\n    uint8_t address\n) \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-begin-34","title":"function begin [3/4]","text":"<pre><code>virtual bool ITwoWire::begin (\n    int8_t sda,\n    int8_t scl,\n    uint32_t frequency=0\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-begin-44","title":"function begin [4/4]","text":"<pre><code>virtual bool ITwoWire::begin (\n    uint8_t address,\n    int8_t sda,\n    int8_t scl,\n    uint32_t frequency=0\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-begintransmission","title":"function beginTransmission","text":"<pre><code>virtual void ITwoWire::beginTransmission (\n    uint8_t address\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-end","title":"function end","text":"<pre><code>virtual bool ITwoWire::end () = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-endtransmission-12","title":"function endTransmission [1/2]","text":"<pre><code>virtual uint8_t ITwoWire::endTransmission (\n    bool stopBit\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-endtransmission-22","title":"function endTransmission [2/2]","text":"<pre><code>inline uint8_t ITwoWire::endTransmission () \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-flush","title":"function flush","text":"<pre><code>virtual void ITwoWire::flush () = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-getclock","title":"function getClock","text":"<pre><code>inline uint32_t ITwoWire::getClock () \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-onreceive","title":"function onReceive","text":"<pre><code>inline void ITwoWire::onReceive (\n    void(*)(int) cb\n) \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-onrequest","title":"function onRequest","text":"<pre><code>inline void ITwoWire::onRequest (\n    void(*)(void) cb\n) \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-peek","title":"function peek","text":"<pre><code>virtual int ITwoWire::peek () = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-read","title":"function read","text":"<pre><code>virtual int ITwoWire::read () = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-requestfrom-12","title":"function requestFrom [1/2]","text":"<pre><code>virtual size_t ITwoWire::requestFrom (\n    uint8_t address,\n    size_t len,\n    bool stopBit\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-requestfrom-22","title":"function requestFrom [2/2]","text":"<pre><code>inline size_t ITwoWire::requestFrom (\n    uint8_t address,\n    size_t len\n) \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-setclock","title":"function setClock","text":"<pre><code>virtual bool ITwoWire::setClock (\n    uint32_t freq\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-setpins","title":"function setPins","text":"<pre><code>virtual bool ITwoWire::setPins (\n    int8_t sda,\n    int8_t scl\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-write-12","title":"function write [1/2]","text":"<pre><code>virtual size_t ITwoWire::write (\n    const uint8_t * data,\n    size_t len\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#function-write-22","title":"function write [2/2]","text":"<pre><code>inline virtual size_t ITwoWire::write (\n    uint8_t data\n) \n</code></pre>"},{"location":"ltapi/class_i_two_wire/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_i_two_wire/#variable-_freq","title":"variable _freq","text":"<pre><code>uint32_t ITwoWire::_freq;\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#variable-_scl","title":"variable _scl","text":"<pre><code>int8_t ITwoWire::_scl;\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#variable-_sda","title":"variable _sda","text":"<pre><code>int8_t ITwoWire::_sda;\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#variable-onreceivecallback","title":"variable onReceiveCallback","text":"<pre><code>void(* ITwoWire::onReceiveCallback) (int);\n</code></pre>"},{"location":"ltapi/class_i_two_wire/#variable-onrequestcallback","title":"variable onRequestCallback","text":"<pre><code>void(* ITwoWire::onRequestCallback) (void);\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Wire.h</code></p>"},{"location":"ltapi/class_i_wi_fi_client/","title":"Class IWiFiClient","text":"<p>ClassList &gt; IWiFiClient</p> <p>Inherits the following classes: Client</p> <p>Inherited by the following classes: LwIPClient</p>"},{"location":"ltapi/class_i_wi_fi_client/#public-functions","title":"Public Functions","text":"Type Name      IWiFiClient ()     IWiFiClient (int sock)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout) = 0   virtual int connect (const char * host, uint16_t port, int32_t timeout) = 0   virtual int fd () const = 0   virtual IPAddress localIP () const = 0   virtual IPAddress localIP (int sock) const = 0   virtual uint16_t localPort () const = 0   virtual uint16_t localPort (int sock) const = 0    operator bool ()    virtual bool operator!= (const bool value)    virtual bool operator!= (const IWiFiClient &amp; other)    bool operator== (const IWiFiClient &amp; other) const   virtual bool operator== (const bool value)    virtual IPAddress remoteIP () const = 0   virtual IPAddress remoteIP (int sock) const = 0   virtual uint16_t remotePort () const = 0   virtual uint16_t remotePort (int sock) const = 0   virtual int setTimeout (uint32_t seconds) = 0   virtual int socket () = 0   virtual size_t write (Stream &amp; stream) = 0   size_t write_P (PGM_P buffer, size_t size)     ~IWiFiClient ()"},{"location":"ltapi/class_i_wi_fi_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_client/#function-iwificlient-12","title":"function IWiFiClient [1/2]","text":"<pre><code>inline IWiFiClient::IWiFiClient () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-iwificlient-22","title":"function IWiFiClient [2/2]","text":"<pre><code>inline IWiFiClient::IWiFiClient (\n    int sock\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-connect-12","title":"function connect [1/2]","text":"<pre><code>virtual int IWiFiClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-connect-22","title":"function connect [2/2]","text":"<pre><code>virtual int IWiFiClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-fd","title":"function fd","text":"<pre><code>virtual int IWiFiClient::fd () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localip-12","title":"function localIP [1/2]","text":"<pre><code>virtual IPAddress IWiFiClient::localIP () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localip-22","title":"function localIP [2/2]","text":"<pre><code>virtual IPAddress IWiFiClient::localIP (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localport-12","title":"function localPort [1/2]","text":"<pre><code>virtual uint16_t IWiFiClient::localPort () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-localport-22","title":"function localPort [2/2]","text":"<pre><code>virtual uint16_t IWiFiClient::localPort (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline IWiFiClient::operator bool () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator","title":"function operator!=","text":"<pre><code>inline virtual bool IWiFiClient::operator!= (\n    const bool value\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator_1","title":"function operator!=","text":"<pre><code>inline virtual bool IWiFiClient::operator!= (\n    const IWiFiClient &amp; other\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator_2","title":"function operator==","text":"<pre><code>bool IWiFiClient::operator== (\n    const IWiFiClient &amp; other\n) const\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-operator_3","title":"function operator==","text":"<pre><code>inline virtual bool IWiFiClient::operator== (\n    const bool value\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteip-12","title":"function remoteIP [1/2]","text":"<pre><code>virtual IPAddress IWiFiClient::remoteIP () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteip-22","title":"function remoteIP [2/2]","text":"<pre><code>virtual IPAddress IWiFiClient::remoteIP (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteport-12","title":"function remotePort [1/2]","text":"<pre><code>virtual uint16_t IWiFiClient::remotePort () const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-remoteport-22","title":"function remotePort [2/2]","text":"<pre><code>virtual uint16_t IWiFiClient::remotePort (\n    int sock\n) const = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int IWiFiClient::setTimeout (\n    uint32_t seconds\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-socket","title":"function socket","text":"<pre><code>virtual int IWiFiClient::socket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-write","title":"function write","text":"<pre><code>virtual size_t IWiFiClient::write (\n    Stream &amp; stream\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-write_p","title":"function write_P","text":"<pre><code>inline size_t IWiFiClient::write_P (\n    PGM_P buffer,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client/#function-iwificlient","title":"function ~IWiFiClient","text":"<pre><code>inline IWiFiClient::~IWiFiClient () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiClient.h</code></p>"},{"location":"ltapi/class_i_wi_fi_client_secure/","title":"Class IWiFiClientSecure","text":"<p>ClassList &gt; IWiFiClientSecure</p> <p>Inherited by the following classes: MbedTLSClient</p>"},{"location":"ltapi/class_i_wi_fi_client_secure/#public-functions","title":"Public Functions","text":"Type Name     virtual int connect (IPAddress ip, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (const char * host, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (IPAddress ip, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual int connect (const char * host, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual bool getFingerprintSHA256 (uint8_t result) = 0   virtual int lastError (char * buf, const size_t size) = 0   virtual bool loadCACert (Stream &amp; stream, size_t size) = 0   virtual bool loadCertificate (Stream &amp; stream, size_t size) = 0   virtual bool loadPrivateKey (Stream &amp; stream, size_t size) = 0   virtual void setAlpnProtocols (const char ** alpnProtocols) = 0   virtual void setCACert (const char * rootCA) = 0   virtual void setCertificate (const char * clientCA) = 0   virtual void setHandshakeTimeout (unsigned long handshakeTimeout) = 0   virtual void setInsecure () = 0   virtual void setPreSharedKey (const char * pskIdent, const char * psk) = 0   virtual void setPrivateKey (const char * privateKey) = 0   virtual bool verify (const char * fingerprint, const char * domainName) = 0"},{"location":"ltapi/class_i_wi_fi_client_secure/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-14","title":"function connect [1/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-24","title":"function connect [2/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    const char * host,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-34","title":"function connect [3/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-connect-44","title":"function connect [4/4]","text":"<pre><code>virtual int IWiFiClientSecure::connect (\n    const char * host,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-getfingerprintsha256","title":"function getFingerprintSHA256","text":"<pre><code>virtual bool IWiFiClientSecure::getFingerprintSHA256 (\n    uint8_t result\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-lasterror","title":"function lastError","text":"<pre><code>virtual int IWiFiClientSecure::lastError (\n    char * buf,\n    const size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-loadcacert","title":"function loadCACert","text":"<pre><code>virtual bool IWiFiClientSecure::loadCACert (\n    Stream &amp; stream,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-loadcertificate","title":"function loadCertificate","text":"<pre><code>virtual bool IWiFiClientSecure::loadCertificate (\n    Stream &amp; stream,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-loadprivatekey","title":"function loadPrivateKey","text":"<pre><code>virtual bool IWiFiClientSecure::loadPrivateKey (\n    Stream &amp; stream,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setalpnprotocols","title":"function setAlpnProtocols","text":"<pre><code>virtual void IWiFiClientSecure::setAlpnProtocols (\n    const char ** alpnProtocols\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setcacert","title":"function setCACert","text":"<pre><code>virtual void IWiFiClientSecure::setCACert (\n    const char * rootCA\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setcertificate","title":"function setCertificate","text":"<pre><code>virtual void IWiFiClientSecure::setCertificate (\n    const char * clientCA\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-sethandshaketimeout","title":"function setHandshakeTimeout","text":"<pre><code>virtual void IWiFiClientSecure::setHandshakeTimeout (\n    unsigned long handshakeTimeout\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setinsecure","title":"function setInsecure","text":"<pre><code>virtual void IWiFiClientSecure::setInsecure () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setpresharedkey","title":"function setPreSharedKey","text":"<pre><code>virtual void IWiFiClientSecure::setPreSharedKey (\n    const char * pskIdent,\n    const char * psk\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-setprivatekey","title":"function setPrivateKey","text":"<pre><code>virtual void IWiFiClientSecure::setPrivateKey (\n    const char * privateKey\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_client_secure/#function-verify","title":"function verify","text":"<pre><code>virtual bool IWiFiClientSecure::verify (\n    const char * fingerprint,\n    const char * domainName\n) = 0\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiClientSecure.h</code></p>"},{"location":"ltapi/class_i_wi_fi_server/","title":"Class IWiFiServer","text":"<p>template &lt;typename TWiFiClient typename TWiFiClient, typename typename&gt;</p> <p>ClassList &gt; IWiFiServer</p> <p>Inherits the following classes: Print</p>"},{"location":"ltapi/class_i_wi_fi_server/#public-functions","title":"Public Functions","text":"Type Name      IWiFiServer (uint16_t port=80, uint8_t maxClients=4)     IWiFiServer (const IPAddress &amp; addr, uint16_t port=80, uint8_t maxClients=4)    virtual TWiFiClient accept () = 0   TWiFiClient available ()    virtual bool begin (uint16_t port=0, bool reuseAddr=true) = 0   void close ()    virtual void end () = 0   virtual bool getNoDelay () = 0   virtual bool hasClient () = 0   void listenOnLocalhost ()    virtual operator bool () = 0   virtual void setNoDelay (bool noDelay) = 0   virtual int setTimeout (uint32_t seconds) = 0   void stop ()    virtual void stopAll () = 0   size_t write (uint8_t data)     ~IWiFiServer ()"},{"location":"ltapi/class_i_wi_fi_server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_server/#function-iwifiserver-12","title":"function IWiFiServer [1/2]","text":"<pre><code>inline IWiFiServer::IWiFiServer (\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-iwifiserver-22","title":"function IWiFiServer [2/2]","text":"<pre><code>inline IWiFiServer::IWiFiServer (\n    const IPAddress &amp; addr,\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-accept","title":"function accept","text":"<pre><code>virtual TWiFiClient IWiFiServer::accept () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-available","title":"function available","text":"<pre><code>inline TWiFiClient IWiFiServer::available () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-begin","title":"function begin","text":"<pre><code>virtual bool IWiFiServer::begin (\n    uint16_t port=0,\n    bool reuseAddr=true\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-close","title":"function close","text":"<pre><code>inline void IWiFiServer::close () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-end","title":"function end","text":"<pre><code>virtual void IWiFiServer::end () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-getnodelay","title":"function getNoDelay","text":"<pre><code>virtual bool IWiFiServer::getNoDelay () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-hasclient","title":"function hasClient","text":"<pre><code>virtual bool IWiFiServer::hasClient () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-listenonlocalhost","title":"function listenOnLocalhost","text":"<pre><code>inline void IWiFiServer::listenOnLocalhost () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-operator-bool","title":"function operator bool","text":"<pre><code>virtual IWiFiServer::operator bool () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-setnodelay","title":"function setNoDelay","text":"<pre><code>virtual void IWiFiServer::setNoDelay (\n    bool noDelay\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int IWiFiServer::setTimeout (\n    uint32_t seconds\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-stop","title":"function stop","text":"<pre><code>inline void IWiFiServer::stop () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-stopall","title":"function stopAll","text":"<pre><code>virtual void IWiFiServer::stopAll () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-write","title":"function write","text":"<pre><code>inline size_t IWiFiServer::write (\n    uint8_t data\n) \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_server/#function-iwifiserver","title":"function ~IWiFiServer","text":"<pre><code>inline IWiFiServer::~IWiFiServer () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiServer.h</code></p>"},{"location":"ltapi/class_i_wi_fi_u_d_p/","title":"Class IWiFiUDP","text":"<p>ClassList &gt; IWiFiUDP</p> <p>Inherits the following classes: UDP</p> <p>Inherited by the following classes: LwIPUDP</p>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#public-functions","title":"Public Functions","text":"Type Name      IWiFiUDP ()    virtual int available () = 0   virtual uint8_t begin (IPAddress ip, uint16_t port) = 0   virtual uint8_t begin (uint16_t port) = 0   virtual uint8_t beginMulticast (IPAddress ip, uint16_t port) = 0   virtual int beginMulticastPacket () = 0   virtual int beginPacket () = 0   virtual int beginPacket (IPAddress ip, uint16_t port) = 0   virtual int beginPacket (const char * host, uint16_t port) = 0   virtual int endPacket () = 0   virtual void flush () = 0   virtual int parsePacket () = 0   virtual int peek () = 0   virtual int read () = 0   virtual int read (unsigned char * buffer, size_t len) = 0   virtual int read (char * buffer, size_t len) = 0   virtual IPAddress remoteIP () = 0   virtual uint16_t remotePort () = 0   virtual void stop () = 0   virtual size_t write (uint8_t) = 0   virtual size_t write (const uint8_t * buffer, size_t size) = 0    ~IWiFiUDP ()"},{"location":"ltapi/class_i_wi_fi_u_d_p/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-iwifiudp","title":"function IWiFiUDP","text":"<pre><code>inline IWiFiUDP::IWiFiUDP () \n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-available","title":"function available","text":"<pre><code>virtual int IWiFiUDP::available () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>virtual uint8_t IWiFiUDP::begin (\n    IPAddress ip,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>virtual uint8_t IWiFiUDP::begin (\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginmulticast","title":"function beginMulticast","text":"<pre><code>virtual uint8_t IWiFiUDP::beginMulticast (\n    IPAddress ip,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginmulticastpacket","title":"function beginMulticastPacket","text":"<pre><code>virtual int IWiFiUDP::beginMulticastPacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginpacket-13","title":"function beginPacket [1/3]","text":"<pre><code>virtual int IWiFiUDP::beginPacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginpacket-23","title":"function beginPacket [2/3]","text":"<pre><code>virtual int IWiFiUDP::beginPacket (\n    IPAddress ip,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-beginpacket-33","title":"function beginPacket [3/3]","text":"<pre><code>virtual int IWiFiUDP::beginPacket (\n    const char * host,\n    uint16_t port\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-endpacket","title":"function endPacket","text":"<pre><code>virtual int IWiFiUDP::endPacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-flush","title":"function flush","text":"<pre><code>virtual void IWiFiUDP::flush () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-parsepacket","title":"function parsePacket","text":"<pre><code>virtual int IWiFiUDP::parsePacket () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-peek","title":"function peek","text":"<pre><code>virtual int IWiFiUDP::peek () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-read-13","title":"function read [1/3]","text":"<pre><code>virtual int IWiFiUDP::read () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-read-23","title":"function read [2/3]","text":"<pre><code>virtual int IWiFiUDP::read (\n    unsigned char * buffer,\n    size_t len\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-read-33","title":"function read [3/3]","text":"<pre><code>virtual int IWiFiUDP::read (\n    char * buffer,\n    size_t len\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-remoteip","title":"function remoteIP","text":"<pre><code>virtual IPAddress IWiFiUDP::remoteIP () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-remoteport","title":"function remotePort","text":"<pre><code>virtual uint16_t IWiFiUDP::remotePort () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-stop","title":"function stop","text":"<pre><code>virtual void IWiFiUDP::stop () = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-write-12","title":"function write [1/2]","text":"<pre><code>virtual size_t IWiFiUDP::write (\n    uint8_t\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-write-22","title":"function write [2/2]","text":"<pre><code>virtual size_t IWiFiUDP::write (\n    const uint8_t * buffer,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/class_i_wi_fi_u_d_p/#function-iwifiudp_1","title":"function ~IWiFiUDP","text":"<pre><code>inline IWiFiUDP::~IWiFiUDP () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiUdp.h</code></p>"},{"location":"ltapi/class_libre_tuya/","title":"Class LibreTuya","text":"<p>ClassList &gt; LibreTuya</p> <p>Main LibreTuya API class.More...</p> <ul> <li><code>#include &lt;LibreTuyaClass.h&gt;</code></li> </ul>"},{"location":"ltapi/class_libre_tuya/#public-functions","title":"Public Functions","text":"Type Name     const char * getBoard () Get board name.   const char * getChipCoreType () Get CPU core type name as string.   uint8_t getChipCores () Get CPU core count.   ChipFamily getChipFamily () Get CPU family ID.   const char * getChipFamilyName () Get CPU family name as string.   uint32_t getChipId () Get CPU unique ID. This may be based on MAC, eFuse, etc. Note: the number should be 24-bit (with most significant byte being zero).   const char * getChipModel () Get CPU model name as string.   ChipType getChipType () Get CPU model ID.   uint32_t getCpuFreq () Get CPU frequency in Hz.   uint32_t getCpuFreqMHz () Get CPU frequency in MHz.   uint32_t getCycleCount () Get CPU cycle count.   const char * getDeviceName () Get device friendly name in format \"LT-&lt;board&gt;-&lt;chip id&gt;\". Can be used as hostname.   FlashId getFlashChipId () Read flash chip ID and return a FlashId struct.   uint32_t getFlashChipSize ()    uint32_t getFreeHeap () Get free heap size.   uint32_t getHeapSize () Get total heap size.   uint32_t getMaxAllocHeap () Get largest block of heap that can be allocated at once.   uint32_t getMaxFreeBlockSize () Alias of getMaxAllocHeap() .   uint32_t getMinFreeHeap () Get lowest level of free heap memory.   uint32_t getRamSize () Get total RAM size.   ResetReason getResetReason () Get the reason of last chip reset.   const char * getResetReasonName (ResetReason reason=RESET_REASON_MAX) Get a textual representation of a reset reason.   const char * getVersion () Get LibreTuya version string.   void gpioRecover () Reconfigure GPIO pins used for debugging (SWD/JTAG), so that they can be used as normal I/O.   bool otaCanRollback () Check if OTA rollback is supported and available (there is another image to run).   uint8_t otaGetRunning () Get the currently running firmware OTA index.   uint8_t otaGetStoredIndex () Read the currently active OTA index, i.e. the one that will boot upon restart.   uint8_t otaGetTarget () Get the OTA index for updated firmware.   bool otaHasImage1 () Check if OTA1 image is valid.   bool otaHasImage2 () Check if OTA2 image is valid.   bool otaRollback () Perform OTA rollback: switch to the previous image, or abort current switched OTA update, if not rebooted yet.   bool otaSupportsDual () Check if the chip supports dual-OTA (i.e. OTA is flashed to a different partition).   bool otaSwitch (bool force=false) Try to switch OTA index to the other image.   void restart () Reboot the CPU.   void restartDownloadMode () Reboot the CPU and stay in download mode (if possible).   void wdtDisable () Disable the hardware watchdog.   bool wdtEnable (uint32_t timeout=10000) Enable the hardware watchdog.   void wdtFeed () Feed/reset the hardware watchdog timer."},{"location":"ltapi/class_libre_tuya/#detailed-description","title":"Detailed Description","text":"<p>This class contains all functions common amongst all families. Implementations of these methods may vary between families.</p> <p>The class is accessible using the <code>LT</code> global object (defined by the family). </p>"},{"location":"ltapi/class_libre_tuya/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_libre_tuya/#function-getboard","title":"function getBoard","text":"<pre><code>const char * LibreTuya::getBoard () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchipcoretype","title":"function getChipCoreType","text":"<pre><code>const char * LibreTuya::getChipCoreType () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchipcores","title":"function getChipCores","text":"<pre><code>uint8_t LibreTuya::getChipCores () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchipfamily","title":"function getChipFamily","text":"<pre><code>ChipFamily LibreTuya::getChipFamily () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchipfamilyname","title":"function getChipFamilyName","text":"<pre><code>const char * LibreTuya::getChipFamilyName () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchipid","title":"function getChipId","text":"<pre><code>uint32_t LibreTuya::getChipId () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchipmodel","title":"function getChipModel","text":"<pre><code>const char * LibreTuya::getChipModel () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getchiptype","title":"function getChipType","text":"<pre><code>ChipType LibreTuya::getChipType () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getcpufreq","title":"function getCpuFreq","text":"<pre><code>uint32_t LibreTuya::getCpuFreq () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getcpufreqmhz","title":"function getCpuFreqMHz","text":"<pre><code>uint32_t LibreTuya::getCpuFreqMHz () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getcyclecount","title":"function getCycleCount","text":"<pre><code>uint32_t LibreTuya::getCycleCount () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getdevicename","title":"function getDeviceName","text":"<pre><code>const char * LibreTuya::getDeviceName () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getflashchipid","title":"function getFlashChipId","text":"<pre><code>FlashId LibreTuya::getFlashChipId () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getflashchipsize","title":"function getFlashChipSize","text":"<pre><code>uint32_t LibreTuya::getFlashChipSize () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getfreeheap","title":"function getFreeHeap","text":"<pre><code>uint32_t LibreTuya::getFreeHeap () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getheapsize","title":"function getHeapSize","text":"<pre><code>uint32_t LibreTuya::getHeapSize () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getmaxallocheap","title":"function getMaxAllocHeap","text":"<pre><code>uint32_t LibreTuya::getMaxAllocHeap () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getmaxfreeblocksize","title":"function getMaxFreeBlockSize","text":"<pre><code>inline uint32_t LibreTuya::getMaxFreeBlockSize () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getminfreeheap","title":"function getMinFreeHeap","text":"<pre><code>uint32_t LibreTuya::getMinFreeHeap () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getramsize","title":"function getRamSize","text":"<pre><code>uint32_t LibreTuya::getRamSize () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getresetreason","title":"function getResetReason","text":"<pre><code>ResetReason LibreTuya::getResetReason () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-getresetreasonname","title":"function getResetReasonName","text":"<p>Get a textual representation of a reset reason. <pre><code>const char * LibreTuya::getResetReasonName (\n    ResetReason reason=RESET_REASON_MAX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>reason</code> value to convert to text, uses getResetReason() by default </li> </ul>"},{"location":"ltapi/class_libre_tuya/#function-getversion","title":"function getVersion","text":"<pre><code>const char * LibreTuya::getVersion () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-gpiorecover","title":"function gpioRecover","text":"<pre><code>void LibreTuya::gpioRecover () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-otacanrollback","title":"function otaCanRollback","text":"<p>Check if OTA rollback is supported and available (there is another image to run). <pre><code>bool LibreTuya::otaCanRollback () \n</code></pre></p> <p>Returns:</p> <p>false if no second image to run or dual-OTA not supported </p>"},{"location":"ltapi/class_libre_tuya/#function-otagetrunning","title":"function otaGetRunning","text":"<pre><code>uint8_t LibreTuya::otaGetRunning () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-otagetstoredindex","title":"function otaGetStoredIndex","text":"<pre><code>uint8_t LibreTuya::otaGetStoredIndex () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-otagettarget","title":"function otaGetTarget","text":"<p>Get the OTA index for updated firmware. <pre><code>uint8_t LibreTuya::otaGetTarget () \n</code></pre></p> <p>Note: returns 1 for chips without dual-OTA. </p>"},{"location":"ltapi/class_libre_tuya/#function-otahasimage1","title":"function otaHasImage1","text":"<pre><code>bool LibreTuya::otaHasImage1 () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-otahasimage2","title":"function otaHasImage2","text":"<pre><code>bool LibreTuya::otaHasImage2 () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-otarollback","title":"function otaRollback","text":"<p>Perform OTA rollback: switch to the previous image, or abort current switched OTA update, if not rebooted yet. <pre><code>bool LibreTuya::otaRollback () \n</code></pre></p> <p>Returns:</p> <p>false if no second image to run, writing failed or dual-OTA not supported </p>"},{"location":"ltapi/class_libre_tuya/#function-otasupportsdual","title":"function otaSupportsDual","text":"<p>Check if the chip supports dual-OTA (i.e. OTA is flashed to a different partition). <pre><code>bool LibreTuya::otaSupportsDual () \n</code></pre></p> <p>TODO: make this work for actual dual-OTA chips; remove checking this in otaGetTarget() etc. </p>"},{"location":"ltapi/class_libre_tuya/#function-otaswitch","title":"function otaSwitch","text":"<p>Try to switch OTA index to the other image. <pre><code>bool LibreTuya::otaSwitch (\n    bool force=false\n) \n</code></pre></p> <p>Note: should return true for chips without dual-OTA. Should return false if one of two images is not valid.</p> <p>Parameters:</p> <ul> <li><code>force</code> switch even if other image already marked as active </li> </ul> <p>Returns:</p> <p>false if writing failed; true otherwise </p>"},{"location":"ltapi/class_libre_tuya/#function-restart","title":"function restart","text":"<pre><code>void LibreTuya::restart () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-restartdownloadmode","title":"function restartDownloadMode","text":"<pre><code>void LibreTuya::restartDownloadMode () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-wdtdisable","title":"function wdtDisable","text":"<pre><code>void LibreTuya::wdtDisable () \n</code></pre>"},{"location":"ltapi/class_libre_tuya/#function-wdtenable","title":"function wdtEnable","text":"<p>Enable the hardware watchdog. <pre><code>bool LibreTuya::wdtEnable (\n    uint32_t timeout=10000\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> watchdog timeout, milliseconds (defaults to 10s) </li> </ul> <p>Returns:</p> <p>whether the chip has a hardware watchdog </p>"},{"location":"ltapi/class_libre_tuya/#function-wdtfeed","title":"function wdtFeed","text":"<pre><code>void LibreTuya::wdtFeed () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaClass.h</code></p>"},{"location":"ltapi/class_lw_i_p_client/","title":"Class LwIPClient","text":"<p>ClassList &gt; LwIPClient</p> <p>Inherits the following classes: IWiFiClient</p>"},{"location":"ltapi/class_lw_i_p_client/#public-functions","title":"Public Functions","text":"Type Name      LwIPClient ()     LwIPClient (int sock)    int available ()    int connect (IPAddress ip, uint16_t port)    int connect (const char * host, uint16_t port)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout)    virtual int connect (const char * host, uint16_t port, int32_t timeout)    uint8_t connected ()    virtual int fd () const   void flush ()    virtual IPAddress localIP () const   virtual IPAddress localIP (int sock) const   virtual uint16_t localPort () const   virtual uint16_t localPort (int sock) const   LwIPClient &amp; operator= (const LwIPClient &amp; other)    int peek ()    int read ()    int read (uint8_t * buf, size_t size)    virtual IPAddress remoteIP () const   virtual IPAddress remoteIP (int sock) const   virtual uint16_t remotePort () const   virtual uint16_t remotePort (int sock) const   virtual int setTimeout (uint32_t seconds)    virtual int socket ()    void stop ()    size_t write (uint8_t data)    size_t write (const uint8_t * buf, size_t size)    virtual size_t write (Stream &amp; stream)     ~LwIPClient ()"},{"location":"ltapi/class_lw_i_p_client/#public-functions-inherited-from-iwificlient","title":"Public Functions inherited from IWiFiClient","text":"<p>See IWiFiClient</p>    Type Name      IWiFiClient ()     IWiFiClient (int sock)    virtual int connect (IPAddress ip, uint16_t port, int32_t timeout) = 0   virtual int connect (const char * host, uint16_t port, int32_t timeout) = 0   virtual int fd () const = 0   virtual IPAddress localIP () const = 0   virtual IPAddress localIP (int sock) const = 0   virtual uint16_t localPort () const = 0   virtual uint16_t localPort (int sock) const = 0    operator bool ()    virtual bool operator!= (const bool value)    virtual bool operator!= (const IWiFiClient &amp; other)    bool operator== (const IWiFiClient &amp; other) const   virtual bool operator== (const bool value)    virtual IPAddress remoteIP () const = 0   virtual IPAddress remoteIP (int sock) const = 0   virtual uint16_t remotePort () const = 0   virtual uint16_t remotePort (int sock) const = 0   virtual int setTimeout (uint32_t seconds) = 0   virtual int socket () = 0   virtual size_t write (Stream &amp; stream) = 0   size_t write_P (PGM_P buffer, size_t size)     ~IWiFiClient ()"},{"location":"ltapi/class_lw_i_p_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_client/#function-lwipclient-12","title":"function LwIPClient [1/2]","text":"<pre><code>LwIPClient::LwIPClient () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-lwipclient-22","title":"function LwIPClient [2/2]","text":"<pre><code>LwIPClient::LwIPClient (\n    int sock\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-available","title":"function available","text":"<pre><code>int LwIPClient::available () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-14","title":"function connect [1/4]","text":"<pre><code>int LwIPClient::connect (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-24","title":"function connect [2/4]","text":"<pre><code>int LwIPClient::connect (\n    const char * host,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-34","title":"function connect [3/4]","text":"<pre><code>virtual int LwIPClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements IWiFiClient::connect</p>"},{"location":"ltapi/class_lw_i_p_client/#function-connect-44","title":"function connect [4/4]","text":"<pre><code>virtual int LwIPClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre> <p>Implements IWiFiClient::connect</p>"},{"location":"ltapi/class_lw_i_p_client/#function-connected","title":"function connected","text":"<pre><code>uint8_t LwIPClient::connected () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-fd","title":"function fd","text":"<pre><code>virtual int LwIPClient::fd () const\n</code></pre> <p>Implements IWiFiClient::fd</p>"},{"location":"ltapi/class_lw_i_p_client/#function-flush","title":"function flush","text":"<pre><code>void LwIPClient::flush () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-localip-12","title":"function localIP [1/2]","text":"<pre><code>virtual IPAddress LwIPClient::localIP () const\n</code></pre> <p>Implements IWiFiClient::localIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-localip-22","title":"function localIP [2/2]","text":"<pre><code>virtual IPAddress LwIPClient::localIP (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::localIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-localport-12","title":"function localPort [1/2]","text":"<pre><code>virtual uint16_t LwIPClient::localPort () const\n</code></pre> <p>Implements IWiFiClient::localPort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-localport-22","title":"function localPort [2/2]","text":"<pre><code>virtual uint16_t LwIPClient::localPort (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::localPort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-operator","title":"function operator=","text":"<pre><code>LwIPClient &amp; LwIPClient::operator= (\n    const LwIPClient &amp; other\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-peek","title":"function peek","text":"<pre><code>int LwIPClient::peek () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-read-12","title":"function read [1/2]","text":"<pre><code>int LwIPClient::read () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-read-22","title":"function read [2/2]","text":"<pre><code>int LwIPClient::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteip-12","title":"function remoteIP [1/2]","text":"<pre><code>virtual IPAddress LwIPClient::remoteIP () const\n</code></pre> <p>Implements IWiFiClient::remoteIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteip-22","title":"function remoteIP [2/2]","text":"<pre><code>virtual IPAddress LwIPClient::remoteIP (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::remoteIP</p>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteport-12","title":"function remotePort [1/2]","text":"<pre><code>virtual uint16_t LwIPClient::remotePort () const\n</code></pre> <p>Implements IWiFiClient::remotePort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-remoteport-22","title":"function remotePort [2/2]","text":"<pre><code>virtual uint16_t LwIPClient::remotePort (\n    int sock\n) const\n</code></pre> <p>Implements IWiFiClient::remotePort</p>"},{"location":"ltapi/class_lw_i_p_client/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int LwIPClient::setTimeout (\n    uint32_t seconds\n) \n</code></pre> <p>Implements IWiFiClient::setTimeout</p>"},{"location":"ltapi/class_lw_i_p_client/#function-socket","title":"function socket","text":"<pre><code>virtual int LwIPClient::socket () \n</code></pre> <p>Implements IWiFiClient::socket</p>"},{"location":"ltapi/class_lw_i_p_client/#function-stop","title":"function stop","text":"<pre><code>void LwIPClient::stop () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-write-13","title":"function write [1/3]","text":"<pre><code>size_t LwIPClient::write (\n    uint8_t data\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-write-23","title":"function write [2/3]","text":"<pre><code>size_t LwIPClient::write (\n    const uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_client/#function-write-33","title":"function write [3/3]","text":"<pre><code>virtual size_t LwIPClient::write (\n    Stream &amp; stream\n) \n</code></pre> <p>Implements IWiFiClient::write</p>"},{"location":"ltapi/class_lw_i_p_client/#function-lwipclient","title":"function ~LwIPClient","text":"<pre><code>LwIPClient::~LwIPClient () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPClient.h</code></p>"},{"location":"ltapi/class_lw_i_p_rx_buffer/","title":"Class LwIPRxBuffer","text":"<p>ClassList &gt; LwIPRxBuffer</p>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#public-functions","title":"Public Functions","text":"Type Name      LwIPRxBuffer (int sock, size_t size=1436)    size_t available ()    bool failed ()    int peek ()    int read (uint8_t * dst, size_t len)     ~LwIPRxBuffer ()"},{"location":"ltapi/class_lw_i_p_rx_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-lwiprxbuffer","title":"function LwIPRxBuffer","text":"<pre><code>LwIPRxBuffer::LwIPRxBuffer (\n    int sock,\n    size_t size=1436\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-available","title":"function available","text":"<pre><code>size_t LwIPRxBuffer::available () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-failed","title":"function failed","text":"<pre><code>bool LwIPRxBuffer::failed () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-peek","title":"function peek","text":"<pre><code>int LwIPRxBuffer::peek () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-read","title":"function read","text":"<pre><code>int LwIPRxBuffer::read (\n    uint8_t * dst,\n    size_t len\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_rx_buffer/#function-lwiprxbuffer_1","title":"function ~LwIPRxBuffer","text":"<pre><code>LwIPRxBuffer::~LwIPRxBuffer () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPRxBuffer.h</code></p>"},{"location":"ltapi/class_lw_i_p_server/","title":"Class LwIPServer","text":"<p>ClassList &gt; LwIPServer</p> <p>Inherits the following classes: IWiFiServer</p>"},{"location":"ltapi/class_lw_i_p_server/#public-functions","title":"Public Functions","text":"Type Name      LwIPServer (uint16_t port=80, uint8_t maxClients=4)     LwIPServer (int port=80, uint8_t maxClients=4)     LwIPServer (const IPAddress &amp; addr, uint16_t port=80, uint8_t maxClients=4)    virtual WiFiClient accept ()    virtual bool begin (uint16_t port=0, bool reuseAddr=true)    virtual void end ()    virtual bool getNoDelay ()    virtual bool hasClient ()    virtual operator bool ()    virtual void setNoDelay (bool noDelay)    virtual int setTimeout (uint32_t seconds)    virtual void stopAll ()    size_t write (const uint8_t * buffer, size_t size)"},{"location":"ltapi/class_lw_i_p_server/#public-functions-inherited-from-iwifiserver","title":"Public Functions inherited from IWiFiServer","text":"<p>See IWiFiServer</p>    Type Name      IWiFiServer (uint16_t port=80, uint8_t maxClients=4)     IWiFiServer (const IPAddress &amp; addr, uint16_t port=80, uint8_t maxClients=4)    virtual TWiFiClient accept () = 0   TWiFiClient available ()    virtual bool begin (uint16_t port=0, bool reuseAddr=true) = 0   void close ()    virtual void end () = 0   virtual bool getNoDelay () = 0   virtual bool hasClient () = 0   void listenOnLocalhost ()    virtual operator bool () = 0   virtual void setNoDelay (bool noDelay) = 0   virtual int setTimeout (uint32_t seconds) = 0   void stop ()    virtual void stopAll () = 0   size_t write (uint8_t data)     ~IWiFiServer ()"},{"location":"ltapi/class_lw_i_p_server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_server/#function-lwipserver-24","title":"function LwIPServer [2/4]","text":"<pre><code>inline LwIPServer::LwIPServer (\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_server/#function-lwipserver-34","title":"function LwIPServer [3/4]","text":"<pre><code>inline LwIPServer::LwIPServer (\n    int port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_server/#function-lwipserver-44","title":"function LwIPServer [4/4]","text":"<pre><code>inline LwIPServer::LwIPServer (\n    const IPAddress &amp; addr,\n    uint16_t port=80,\n    uint8_t maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_lw_i_p_server/#function-accept","title":"function accept","text":"<pre><code>virtual WiFiClient LwIPServer::accept () \n</code></pre> <p>Implements IWiFiServer::accept</p>"},{"location":"ltapi/class_lw_i_p_server/#function-begin","title":"function begin","text":"<pre><code>virtual bool LwIPServer::begin (\n    uint16_t port=0,\n    bool reuseAddr=true\n) \n</code></pre> <p>Implements IWiFiServer::begin</p>"},{"location":"ltapi/class_lw_i_p_server/#function-end","title":"function end","text":"<pre><code>virtual void LwIPServer::end () \n</code></pre> <p>Implements IWiFiServer::end</p>"},{"location":"ltapi/class_lw_i_p_server/#function-getnodelay","title":"function getNoDelay","text":"<pre><code>virtual bool LwIPServer::getNoDelay () \n</code></pre> <p>Implements IWiFiServer::getNoDelay</p>"},{"location":"ltapi/class_lw_i_p_server/#function-hasclient","title":"function hasClient","text":"<pre><code>virtual bool LwIPServer::hasClient () \n</code></pre> <p>Implements IWiFiServer::hasClient</p>"},{"location":"ltapi/class_lw_i_p_server/#function-operator-bool","title":"function operator bool","text":"<pre><code>virtual LwIPServer::operator bool () \n</code></pre> <p>Implements IWiFiServer::operator bool</p>"},{"location":"ltapi/class_lw_i_p_server/#function-setnodelay","title":"function setNoDelay","text":"<pre><code>virtual void LwIPServer::setNoDelay (\n    bool noDelay\n) \n</code></pre> <p>Implements IWiFiServer::setNoDelay</p>"},{"location":"ltapi/class_lw_i_p_server/#function-settimeout","title":"function setTimeout","text":"<pre><code>virtual int LwIPServer::setTimeout (\n    uint32_t seconds\n) \n</code></pre> <p>Implements IWiFiServer::setTimeout</p>"},{"location":"ltapi/class_lw_i_p_server/#function-stopall","title":"function stopAll","text":"<pre><code>inline virtual void LwIPServer::stopAll () \n</code></pre> <p>Implements IWiFiServer::stopAll</p>"},{"location":"ltapi/class_lw_i_p_server/#function-write","title":"function write","text":"<pre><code>inline size_t LwIPServer::write (\n    const uint8_t * buffer,\n    size_t size\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPServer.h</code></p>"},{"location":"ltapi/class_lw_i_p_u_d_p/","title":"Class LwIPUDP","text":"<p>ClassList &gt; LwIPUDP</p> <p>Inherits the following classes: IWiFiUDP</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#public-functions","title":"Public Functions","text":"Type Name      LwIPUDP ()    virtual int available ()    virtual uint8_t begin (IPAddress ip, uint16_t port)    virtual uint8_t begin (uint16_t port)    virtual uint8_t beginMulticast (IPAddress ip, uint16_t port)    virtual int beginMulticastPacket ()    virtual int beginPacket ()    virtual int beginPacket (IPAddress ip, uint16_t port)    virtual int beginPacket (const char * host, uint16_t port)    virtual int endPacket ()    virtual void flush ()    virtual int parsePacket ()    virtual int peek ()    virtual int read ()    virtual int read (unsigned char * buffer, size_t len)    virtual int read (char * buffer, size_t len)    virtual IPAddress remoteIP ()    virtual uint16_t remotePort ()    virtual void stop ()    virtual size_t write (uint8_t)    virtual size_t write (const uint8_t * buffer, size_t size)     ~LwIPUDP ()"},{"location":"ltapi/class_lw_i_p_u_d_p/#public-functions-inherited-from-iwifiudp","title":"Public Functions inherited from IWiFiUDP","text":"<p>See IWiFiUDP</p>    Type Name      IWiFiUDP ()    virtual int available () = 0   virtual uint8_t begin (IPAddress ip, uint16_t port) = 0   virtual uint8_t begin (uint16_t port) = 0   virtual uint8_t beginMulticast (IPAddress ip, uint16_t port) = 0   virtual int beginMulticastPacket () = 0   virtual int beginPacket () = 0   virtual int beginPacket (IPAddress ip, uint16_t port) = 0   virtual int beginPacket (const char * host, uint16_t port) = 0   virtual int endPacket () = 0   virtual void flush () = 0   virtual int parsePacket () = 0   virtual int peek () = 0   virtual int read () = 0   virtual int read (unsigned char * buffer, size_t len) = 0   virtual int read (char * buffer, size_t len) = 0   virtual IPAddress remoteIP () = 0   virtual uint16_t remotePort () = 0   virtual void stop () = 0   virtual size_t write (uint8_t) = 0   virtual size_t write (const uint8_t * buffer, size_t size) = 0    ~IWiFiUDP ()"},{"location":"ltapi/class_lw_i_p_u_d_p/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_lw_i_p_u_d_p/#function-lwipudp","title":"function LwIPUDP","text":"<pre><code>LwIPUDP::LwIPUDP () \n</code></pre>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-available","title":"function available","text":"<pre><code>virtual int LwIPUDP::available () \n</code></pre> <p>Implements IWiFiUDP::available</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>virtual uint8_t LwIPUDP::begin (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::begin</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>virtual uint8_t LwIPUDP::begin (\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::begin</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginmulticast","title":"function beginMulticast","text":"<pre><code>virtual uint8_t LwIPUDP::beginMulticast (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::beginMulticast</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginmulticastpacket","title":"function beginMulticastPacket","text":"<pre><code>virtual int LwIPUDP::beginMulticastPacket () \n</code></pre> <p>Implements IWiFiUDP::beginMulticastPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginpacket-13","title":"function beginPacket [1/3]","text":"<pre><code>virtual int LwIPUDP::beginPacket () \n</code></pre> <p>Implements IWiFiUDP::beginPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginpacket-23","title":"function beginPacket [2/3]","text":"<pre><code>virtual int LwIPUDP::beginPacket (\n    IPAddress ip,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::beginPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-beginpacket-33","title":"function beginPacket [3/3]","text":"<pre><code>virtual int LwIPUDP::beginPacket (\n    const char * host,\n    uint16_t port\n) \n</code></pre> <p>Implements IWiFiUDP::beginPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-endpacket","title":"function endPacket","text":"<pre><code>virtual int LwIPUDP::endPacket () \n</code></pre> <p>Implements IWiFiUDP::endPacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-flush","title":"function flush","text":"<pre><code>virtual void LwIPUDP::flush () \n</code></pre> <p>Implements IWiFiUDP::flush</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-parsepacket","title":"function parsePacket","text":"<pre><code>virtual int LwIPUDP::parsePacket () \n</code></pre> <p>Implements IWiFiUDP::parsePacket</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-peek","title":"function peek","text":"<pre><code>virtual int LwIPUDP::peek () \n</code></pre> <p>Implements IWiFiUDP::peek</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-read-13","title":"function read [1/3]","text":"<pre><code>virtual int LwIPUDP::read () \n</code></pre> <p>Implements IWiFiUDP::read</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-read-23","title":"function read [2/3]","text":"<pre><code>virtual int LwIPUDP::read (\n    unsigned char * buffer,\n    size_t len\n) \n</code></pre> <p>Implements IWiFiUDP::read</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-read-33","title":"function read [3/3]","text":"<pre><code>virtual int LwIPUDP::read (\n    char * buffer,\n    size_t len\n) \n</code></pre> <p>Implements IWiFiUDP::read</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-remoteip","title":"function remoteIP","text":"<pre><code>virtual IPAddress LwIPUDP::remoteIP () \n</code></pre> <p>Implements IWiFiUDP::remoteIP</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-remoteport","title":"function remotePort","text":"<pre><code>virtual uint16_t LwIPUDP::remotePort () \n</code></pre> <p>Implements IWiFiUDP::remotePort</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-stop","title":"function stop","text":"<pre><code>virtual void LwIPUDP::stop () \n</code></pre> <p>Implements IWiFiUDP::stop</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-write-12","title":"function write [1/2]","text":"<pre><code>virtual size_t LwIPUDP::write (\n    uint8_t\n) \n</code></pre> <p>Implements IWiFiUDP::write</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-write-22","title":"function write [2/2]","text":"<pre><code>virtual size_t LwIPUDP::write (\n    const uint8_t * buffer,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiUDP::write</p>"},{"location":"ltapi/class_lw_i_p_u_d_p/#function-lwipudp_1","title":"function ~LwIPUDP","text":"<pre><code>LwIPUDP::~LwIPUDP () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPUdp.h</code></p>"},{"location":"ltapi/class_mbed_t_l_s_client/","title":"Class MbedTLSClient","text":"<p>ClassList &gt; MbedTLSClient</p> <p>Inherits the following classes: WiFiClient,  IWiFiClientSecure</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions","title":"Public Functions","text":"Type Name      MbedTLSClient ()     MbedTLSClient (int sock)    int available ()    int connect (IPAddress ip, uint16_t port, int32_t timeout)    int connect (const char * host, uint16_t port, int32_t timeout)    virtual int connect (IPAddress ip, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey)    virtual int connect (const char * host, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey)    virtual int connect (IPAddress ip, uint16_t port, const char * pskIdent, const char * psk)    virtual int connect (const char * host, uint16_t port, const char * pskIdent, const char * psk)    void flush ()    virtual bool getFingerprintSHA256 (uint8_t result)    virtual int lastError (char * buf, const size_t size)    virtual bool loadCACert (Stream &amp; stream, size_t size)    virtual bool loadCertificate (Stream &amp; stream, size_t size)    virtual bool loadPrivateKey (Stream &amp; stream, size_t size)    int peek ()    int read (uint8_t * buf, size_t size)    virtual void setAlpnProtocols (const char ** alpnProtocols)    virtual void setCACert (const char * rootCA)    virtual void setCertificate (const char * clientCA)    virtual void setHandshakeTimeout (unsigned long handshakeTimeout)    virtual void setInsecure ()    virtual void setPreSharedKey (const char * pskIdent, const char * psk)    virtual void setPrivateKey (const char * privateKey)    void stop ()    virtual bool verify (const char * fingerprint, const char * domainName)    size_t write (const uint8_t * buf, size_t size)     ~MbedTLSClient ()"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions-inherited-from-iwificlientsecure","title":"Public Functions inherited from IWiFiClientSecure","text":"<p>See IWiFiClientSecure</p>    Type Name     virtual int connect (IPAddress ip, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (const char * host, uint16_t port, const char * rootCABuf, const char * clientCert, const char * clientKey) = 0   virtual int connect (IPAddress ip, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual int connect (const char * host, uint16_t port, const char * pskIdent, const char * psk) = 0   virtual bool getFingerprintSHA256 (uint8_t result) = 0   virtual int lastError (char * buf, const size_t size) = 0   virtual bool loadCACert (Stream &amp; stream, size_t size) = 0   virtual bool loadCertificate (Stream &amp; stream, size_t size) = 0   virtual bool loadPrivateKey (Stream &amp; stream, size_t size) = 0   virtual void setAlpnProtocols (const char ** alpnProtocols) = 0   virtual void setCACert (const char * rootCA) = 0   virtual void setCertificate (const char * clientCA) = 0   virtual void setHandshakeTimeout (unsigned long handshakeTimeout) = 0   virtual void setInsecure () = 0   virtual void setPreSharedKey (const char * pskIdent, const char * psk) = 0   virtual void setPrivateKey (const char * privateKey) = 0   virtual bool verify (const char * fingerprint, const char * domainName) = 0"},{"location":"ltapi/class_mbed_t_l_s_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_mbed_t_l_s_client/#function-mbedtlsclient-12","title":"function MbedTLSClient [1/2]","text":"<pre><code>MbedTLSClient::MbedTLSClient () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-mbedtlsclient-22","title":"function MbedTLSClient [2/2]","text":"<pre><code>MbedTLSClient::MbedTLSClient (\n    int sock\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-available","title":"function available","text":"<pre><code>int MbedTLSClient::available () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-27","title":"function connect [2/7]","text":"<pre><code>int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-37","title":"function connect [3/7]","text":"<pre><code>int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    int32_t timeout\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-47","title":"function connect [4/7]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-57","title":"function connect [5/7]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    const char * rootCABuf,\n    const char * clientCert,\n    const char * clientKey\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-67","title":"function connect [6/7]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    IPAddress ip,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-connect-77","title":"function connect [7/7]","text":"<pre><code>virtual int MbedTLSClient::connect (\n    const char * host,\n    uint16_t port,\n    const char * pskIdent,\n    const char * psk\n) \n</code></pre> <p>Implements IWiFiClientSecure::connect</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-flush","title":"function flush","text":"<pre><code>void MbedTLSClient::flush () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-getfingerprintsha256","title":"function getFingerprintSHA256","text":"<pre><code>virtual bool MbedTLSClient::getFingerprintSHA256 (\n    uint8_t result\n) \n</code></pre> <p>Implements IWiFiClientSecure::getFingerprintSHA256</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-lasterror","title":"function lastError","text":"<pre><code>virtual int MbedTLSClient::lastError (\n    char * buf,\n    const size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::lastError</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-loadcacert","title":"function loadCACert","text":"<pre><code>virtual bool MbedTLSClient::loadCACert (\n    Stream &amp; stream,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::loadCACert</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-loadcertificate","title":"function loadCertificate","text":"<pre><code>virtual bool MbedTLSClient::loadCertificate (\n    Stream &amp; stream,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::loadCertificate</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-loadprivatekey","title":"function loadPrivateKey","text":"<pre><code>virtual bool MbedTLSClient::loadPrivateKey (\n    Stream &amp; stream,\n    size_t size\n) \n</code></pre> <p>Implements IWiFiClientSecure::loadPrivateKey</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-peek","title":"function peek","text":"<pre><code>int MbedTLSClient::peek () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-read","title":"function read","text":"<pre><code>int MbedTLSClient::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setalpnprotocols","title":"function setAlpnProtocols","text":"<pre><code>virtual void MbedTLSClient::setAlpnProtocols (\n    const char ** alpnProtocols\n) \n</code></pre> <p>Implements IWiFiClientSecure::setAlpnProtocols</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setcacert","title":"function setCACert","text":"<pre><code>virtual void MbedTLSClient::setCACert (\n    const char * rootCA\n) \n</code></pre> <p>Implements IWiFiClientSecure::setCACert</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setcertificate","title":"function setCertificate","text":"<pre><code>virtual void MbedTLSClient::setCertificate (\n    const char * clientCA\n) \n</code></pre> <p>Implements IWiFiClientSecure::setCertificate</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-sethandshaketimeout","title":"function setHandshakeTimeout","text":"<pre><code>virtual void MbedTLSClient::setHandshakeTimeout (\n    unsigned long handshakeTimeout\n) \n</code></pre> <p>Implements IWiFiClientSecure::setHandshakeTimeout</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setinsecure","title":"function setInsecure","text":"<pre><code>virtual void MbedTLSClient::setInsecure () \n</code></pre> <p>Implements IWiFiClientSecure::setInsecure</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setpresharedkey","title":"function setPreSharedKey","text":"<pre><code>virtual void MbedTLSClient::setPreSharedKey (\n    const char * pskIdent,\n    const char * psk\n) \n</code></pre> <p>Implements IWiFiClientSecure::setPreSharedKey</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-setprivatekey","title":"function setPrivateKey","text":"<pre><code>virtual void MbedTLSClient::setPrivateKey (\n    const char * privateKey\n) \n</code></pre> <p>Implements IWiFiClientSecure::setPrivateKey</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-stop","title":"function stop","text":"<pre><code>void MbedTLSClient::stop () \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-verify","title":"function verify","text":"<pre><code>virtual bool MbedTLSClient::verify (\n    const char * fingerprint,\n    const char * domainName\n) \n</code></pre> <p>Implements IWiFiClientSecure::verify</p>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-write","title":"function write","text":"<pre><code>size_t MbedTLSClient::write (\n    const uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_mbed_t_l_s_client/#function-mbedtlsclient","title":"function ~MbedTLSClient","text":"<pre><code>MbedTLSClient::~MbedTLSClient () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/ssl/MbedTLSClient.h</code></p>"},{"location":"ltapi/struct_pin_info/","title":"Struct PinInfo","text":"<p>ClassList &gt; PinInfo</p>"},{"location":"ltapi/struct_pin_info/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t enabled Enabled pin functions. Used values are family-specific.   uint32_t gpio GPIO name in the family SDK.   uint32_t mode Pin mode (direction, IRQ level, etc.).   uint32_t supported Supported pin functions."},{"location":"ltapi/struct_pin_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_pin_info/#variable-enabled","title":"variable enabled","text":"<pre><code>uint32_t PinInfo::enabled;\n</code></pre>"},{"location":"ltapi/struct_pin_info/#variable-gpio","title":"variable gpio","text":"<pre><code>uint32_t PinInfo::gpio;\n</code></pre>"},{"location":"ltapi/struct_pin_info/#variable-mode","title":"variable mode","text":"<pre><code>uint32_t PinInfo::mode;\n</code></pre>"},{"location":"ltapi/struct_pin_info/#variable-supported","title":"variable supported","text":"<pre><code>uint32_t PinInfo::supported;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaCustom.h</code></p>"},{"location":"ltapi/class_request_handler/","title":"Class RequestHandler","text":"<p>ClassList &gt; RequestHandler</p> <p>Inherited by the following classes: FunctionRequestHandler,  StaticRequestHandler</p>"},{"location":"ltapi/class_request_handler/#public-functions","title":"Public Functions","text":"Type Name     virtual bool canHandle (HTTPMethod method, String uri)    virtual bool canUpload (String uri)    virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri)    RequestHandler * next ()    void next (RequestHandler * r)    const String &amp; pathArg (unsigned int i)    virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload)    virtual ~RequestHandler ()"},{"location":"ltapi/class_request_handler/#protected-attributes","title":"Protected Attributes","text":"Type Name     std::vector&lt; String &gt; pathArgs"},{"location":"ltapi/class_request_handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_request_handler/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool RequestHandler::canHandle (\n    HTTPMethod method,\n    String uri\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-canupload","title":"function canUpload","text":"<pre><code>inline virtual bool RequestHandler::canUpload (\n    String uri\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-handle","title":"function handle","text":"<pre><code>inline virtual bool RequestHandler::handle (\n    WebServer &amp; server,\n    HTTPMethod requestMethod,\n    String requestUri\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-next-12","title":"function next [1/2]","text":"<pre><code>inline RequestHandler * RequestHandler::next () \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-next-22","title":"function next [2/2]","text":"<pre><code>inline void RequestHandler::next (\n    RequestHandler * r\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-patharg","title":"function pathArg","text":"<pre><code>inline const String &amp; RequestHandler::pathArg (\n    unsigned int i\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-upload","title":"function upload","text":"<pre><code>inline virtual void RequestHandler::upload (\n    WebServer &amp; server,\n    String requestUri,\n    HTTPUpload &amp; upload\n) \n</code></pre>"},{"location":"ltapi/class_request_handler/#function-requesthandler","title":"function ~RequestHandler","text":"<pre><code>inline virtual RequestHandler::~RequestHandler () \n</code></pre>"},{"location":"ltapi/class_request_handler/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_request_handler/#variable-pathargs","title":"variable pathArgs","text":"<pre><code>std::vector&lt;String&gt; RequestHandler::pathArgs;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/RequestHandler.h</code></p>"},{"location":"ltapi/class_static_request_handler/","title":"Class StaticRequestHandler","text":"<p>ClassList &gt; StaticRequestHandler</p> <p>Inherits the following classes: RequestHandler</p>"},{"location":"ltapi/class_static_request_handler/#public-functions","title":"Public Functions","text":"Type Name      StaticRequestHandler (FS &amp; fs, const char * path, const char * uri, const char * cache_header)    virtual bool canHandle (HTTPMethod requestMethod, String requestUri) override   virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri) override"},{"location":"ltapi/class_static_request_handler/#public-functions-inherited-from-requesthandler","title":"Public Functions inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     virtual bool canHandle (HTTPMethod method, String uri)    virtual bool canUpload (String uri)    virtual bool handle (WebServer &amp; server, HTTPMethod requestMethod, String requestUri)    RequestHandler * next ()    void next (RequestHandler * r)    const String &amp; pathArg (unsigned int i)    virtual void upload (WebServer &amp; server, String requestUri, HTTPUpload &amp; upload)    virtual ~RequestHandler ()"},{"location":"ltapi/class_static_request_handler/#public-static-functions","title":"Public Static Functions","text":"Type Name     String getContentType (const String &amp; path)"},{"location":"ltapi/class_static_request_handler/#protected-attributes","title":"Protected Attributes","text":"Type Name     size_t _baseUriLength    String _cache_header    FS _fs    bool _isFile    String _path    String _uri"},{"location":"ltapi/class_static_request_handler/#protected-attributes-inherited-from-requesthandler","title":"Protected Attributes inherited from RequestHandler","text":"<p>See RequestHandler</p>    Type Name     std::vector&lt; String &gt; pathArgs"},{"location":"ltapi/class_static_request_handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_static_request_handler/#function-staticrequesthandler","title":"function StaticRequestHandler","text":"<pre><code>inline StaticRequestHandler::StaticRequestHandler (\n    FS &amp; fs,\n    const char * path,\n    const char * uri,\n    const char * cache_header\n) \n</code></pre>"},{"location":"ltapi/class_static_request_handler/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool StaticRequestHandler::canHandle (\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::canHandle</p>"},{"location":"ltapi/class_static_request_handler/#function-handle","title":"function handle","text":"<pre><code>inline virtual bool StaticRequestHandler::handle (\n    WebServer &amp; server,\n    HTTPMethod requestMethod,\n    String requestUri\n) override\n</code></pre> <p>Implements RequestHandler::handle</p>"},{"location":"ltapi/class_static_request_handler/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_static_request_handler/#function-getcontenttype","title":"function getContentType","text":"<pre><code>static inline String StaticRequestHandler::getContentType (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/class_static_request_handler/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_static_request_handler/#variable-_baseurilength","title":"variable _baseUriLength","text":"<pre><code>size_t StaticRequestHandler::_baseUriLength;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_cache_header","title":"variable _cache_header","text":"<pre><code>String StaticRequestHandler::_cache_header;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_fs","title":"variable _fs","text":"<pre><code>FS StaticRequestHandler::_fs;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_isfile","title":"variable _isFile","text":"<pre><code>bool StaticRequestHandler::_isFile;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_path","title":"variable _path","text":"<pre><code>String StaticRequestHandler::_path;\n</code></pre>"},{"location":"ltapi/class_static_request_handler/#variable-_uri","title":"variable _uri","text":"<pre><code>String StaticRequestHandler::_uri;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/RequestHandlersImpl.h</code></p>"},{"location":"ltapi/class_stream_string/","title":"Class StreamString","text":"<p>ClassList &gt; StreamString</p> <p>More...</p> <ul> <li><code>#include &lt;StreamString.h&gt;</code></li> </ul> <p>Inherits the following classes: Stream,  String</p>"},{"location":"ltapi/class_stream_string/#public-functions","title":"Public Functions","text":"Type Name     int available () override   void flush () override   int peek () override   int read () override   size_t write (const uint8_t * buffer, size_t size) override   size_t write (uint8_t data) override"},{"location":"ltapi/class_stream_string/#detailed-description","title":"Detailed Description","text":"<p>StreamString.h</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>"},{"location":"ltapi/class_stream_string/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_stream_string/#function-available","title":"function available","text":"<pre><code>int StreamString::available () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-flush","title":"function flush","text":"<pre><code>void StreamString::flush () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-peek","title":"function peek","text":"<pre><code>int StreamString::peek () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-read","title":"function read","text":"<pre><code>int StreamString::read () override\n</code></pre>"},{"location":"ltapi/class_stream_string/#function-write-12","title":"function write [1/2]","text":"<pre><code>size_t StreamString::write (\n    const uint8_t * buffer,\n    size_t size\n) override\n</code></pre> <p>StreamString.cpp</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the esp8266 core for Arduino environment.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>"},{"location":"ltapi/class_stream_string/#function-write-22","title":"function write [2/2]","text":"<pre><code>size_t StreamString::write (\n    uint8_t data\n) override\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/StreamString/StreamString.h</code></p>"},{"location":"ltapi/class_update_class/","title":"Class UpdateClass","text":"<p>ClassList &gt; UpdateClass</p>"},{"location":"ltapi/class_update_class/#public-types","title":"Public Types","text":"Type Name     typedef std::function&lt; void(size_t, size_t)&gt; THandlerFunction_Progress"},{"location":"ltapi/class_update_class/#public-functions","title":"Public Functions","text":"Type Name      UpdateClass ()    void abort () Abort the update with UPDATE_ERROR_ABORT reason.   bool begin (size_t size=UPDATE_SIZE_UNKNOWN, int command=U_FLASH, int unused2=-1, uint8_t unused3=LOW, const char * unused4=NULL) Initialize the update process.   bool canRollBack () See LT.otaCanRollback() for more info.   void clearError ()    bool end (bool evenIfRemaining=false) Finalize the update process. Check for errors and update completion, then activate the new firmware image.   const char * errorString () Get string representation of the error in format \"ard=..,uf2=..\". Returns \"\" if no error.   const char * getBoardName () Get target board name from UF2 info.   uint8_t getError ()    uint16_t getErrorCode ()    const char * getFirmwareName () Get firmware name from UF2 info.   const char * getFirmwareVersion () Get firmware version from UF2 info.   const char * getLibreTuyaVersion () Get LibreTuya version from UF2 info.   uf2_err_t getUF2Error ()    bool hasError ()    bool isFinished ()    bool isRunning ()    void md5 (uint8_t * result)    String md5String (void)    UpdateClass &amp; onProgress (THandlerFunction_Progress callback) Set the callback invoked after writing data to flash.   void printError (Print &amp; out) Print string error info to the stream.   size_t progress ()    size_t remaining ()    bool rollBack () See LT.otaRollback() for more info.   size_t size ()    size_t write (uint8_t * data, size_t len) Write a chunk of data to the buffer or flash memory.   size_t writeStream (Stream &amp; data)"},{"location":"ltapi/class_update_class/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/class_update_class/#typedef-thandlerfunction_progress","title":"typedef THandlerFunction_Progress","text":"<pre><code>typedef std::function&lt;void(size_t, size_t)&gt; UpdateClass::THandlerFunction_Progress;\n</code></pre>"},{"location":"ltapi/class_update_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_update_class/#function-updateclass","title":"function UpdateClass","text":"<pre><code>UpdateClass::UpdateClass () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-abort","title":"function abort","text":"<pre><code>void UpdateClass::abort () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-begin","title":"function begin","text":"<p>Initialize the update process. <pre><code>bool UpdateClass::begin (\n    size_t size=UPDATE_SIZE_UNKNOWN,\n    int command=U_FLASH,\n    int unused2=-1,\n    uint8_t unused3=LOW,\n    const char * unused4=NULL\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>size</code> total UF2 file size </li> <li><code>command</code> must be U_FLASH </li> </ul> <p>Returns:</p> <p>false if parameters are invalid or update is running, true otherwise </p>"},{"location":"ltapi/class_update_class/#function-canrollback","title":"function canRollBack","text":"<pre><code>bool UpdateClass::canRollBack () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-clearerror","title":"function clearError","text":"<pre><code>inline void UpdateClass::clearError () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-end","title":"function end","text":"<p>Finalize the update process. Check for errors and update completion, then activate the new firmware image. <pre><code>bool UpdateClass::end (\n    bool evenIfRemaining=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>evenIfRemaining</code> no idea </li> </ul> <p>Returns:</p> <p>false in case of errors or no update running, true otherwise </p>"},{"location":"ltapi/class_update_class/#function-errorstring","title":"function errorString","text":"<pre><code>const char * UpdateClass::errorString () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getboardname","title":"function getBoardName","text":"<pre><code>const char * UpdateClass::getBoardName () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-geterror","title":"function getError","text":"<pre><code>inline uint8_t UpdateClass::getError () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-geterrorcode","title":"function getErrorCode","text":"<pre><code>inline uint16_t UpdateClass::getErrorCode () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getfirmwarename","title":"function getFirmwareName","text":"<pre><code>const char * UpdateClass::getFirmwareName () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getfirmwareversion","title":"function getFirmwareVersion","text":"<pre><code>const char * UpdateClass::getFirmwareVersion () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getlibretuyaversion","title":"function getLibreTuyaVersion","text":"<pre><code>const char * UpdateClass::getLibreTuyaVersion () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-getuf2error","title":"function getUF2Error","text":"<pre><code>inline uf2_err_t UpdateClass::getUF2Error () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-haserror","title":"function hasError","text":"<pre><code>inline bool UpdateClass::hasError () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-isfinished","title":"function isFinished","text":"<pre><code>inline bool UpdateClass::isFinished () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-isrunning","title":"function isRunning","text":"<pre><code>inline bool UpdateClass::isRunning () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-md5","title":"function md5","text":"<pre><code>inline void UpdateClass::md5 (\n    uint8_t * result\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-md5string","title":"function md5String","text":"<pre><code>inline String UpdateClass::md5String (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-onprogress","title":"function onProgress","text":"<pre><code>UpdateClass &amp; UpdateClass::onProgress (\n    THandlerFunction_Progress callback\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-printerror","title":"function printError","text":"<pre><code>void UpdateClass::printError (\n    Print &amp; out\n) \n</code></pre>"},{"location":"ltapi/class_update_class/#function-progress","title":"function progress","text":"<pre><code>inline size_t UpdateClass::progress () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-remaining","title":"function remaining","text":"<pre><code>inline size_t UpdateClass::remaining () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-rollback","title":"function rollBack","text":"<pre><code>bool UpdateClass::rollBack () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-size","title":"function size","text":"<pre><code>inline size_t UpdateClass::size () \n</code></pre>"},{"location":"ltapi/class_update_class/#function-write","title":"function write","text":"<p>Write a chunk of data to the buffer or flash memory. <pre><code>size_t UpdateClass::write (\n    uint8_t * data,\n    size_t len\n) \n</code></pre></p> <p>It's advised to write in 512-byte chunks (or its multiples).</p> <p>Parameters:</p> <ul> <li><code>data</code> </li> <li><code>len</code> </li> </ul> <p>Returns:</p> <p>size_t </p>"},{"location":"ltapi/class_update_class/#function-writestream","title":"function writeStream","text":"<pre><code>size_t UpdateClass::writeStream (\n    Stream &amp; data\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Update/Update.h</code></p>"},{"location":"ltapi/class_uri/","title":"Class Uri","text":"<p>ClassList &gt; Uri</p> <p>Inherited by the following classes: UriBraces,  UriGlob,  UriRegex</p>"},{"location":"ltapi/class_uri/#public-functions","title":"Public Functions","text":"Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri/#protected-attributes","title":"Protected Attributes","text":"Type Name     const String _uri"},{"location":"ltapi/class_uri/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri/#function-uri-13","title":"function Uri [1/3]","text":"<pre><code>inline Uri::Uri (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-uri-23","title":"function Uri [2/3]","text":"<pre><code>inline Uri::Uri (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-uri-33","title":"function Uri [3/3]","text":"<pre><code>inline Uri::Uri (\n    const __FlashStringHelper * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool Uri::canHandle (\n    const String &amp; requestUri,\n    __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * Uri::clone () const\n</code></pre>"},{"location":"ltapi/class_uri/#function-initpathargs","title":"function initPathArgs","text":"<pre><code>inline virtual void Uri::initPathArgs (\n    __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs\n) \n</code></pre>"},{"location":"ltapi/class_uri/#function-uri","title":"function ~Uri","text":"<pre><code>inline virtual Uri::~Uri () \n</code></pre>"},{"location":"ltapi/class_uri/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_uri/#variable-_uri","title":"variable _uri","text":"<pre><code>const String Uri::_uri;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/Uri.h</code></p>"},{"location":"ltapi/class_uri_braces/","title":"Class UriBraces","text":"<p>ClassList &gt; UriBraces</p> <p>Inherits the following classes: Uri</p>"},{"location":"ltapi/class_uri_braces/#public-functions","title":"Public Functions","text":"Type Name      UriBraces (const char * uri)     UriBraces (const String &amp; uri)    bool canHandle (const String &amp; requestUri, std::vector&lt; String &gt; &amp; pathArgs) override   virtual Uri * clone () override const   void initPathArgs (std::vector&lt; String &gt; &amp; pathArgs) override"},{"location":"ltapi/class_uri_braces/#public-functions-inherited-from-uri","title":"Public Functions inherited from Uri","text":"<p>See Uri</p>    Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri_braces/#protected-attributes-inherited-from-uri","title":"Protected Attributes inherited from Uri","text":"<p>See Uri</p>    Type Name     const String _uri"},{"location":"ltapi/class_uri_braces/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri_braces/#function-uribraces-12","title":"function UriBraces [1/2]","text":"<pre><code>inline explicit UriBraces::UriBraces (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_braces/#function-uribraces-22","title":"function UriBraces [2/2]","text":"<pre><code>inline explicit UriBraces::UriBraces (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_braces/#function-canhandle","title":"function canHandle","text":"<pre><code>inline bool UriBraces::canHandle (\n    const String &amp; requestUri,\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>"},{"location":"ltapi/class_uri_braces/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * UriBraces::clone () override const\n</code></pre> <p>Implements Uri::clone</p>"},{"location":"ltapi/class_uri_braces/#function-initpathargs","title":"function initPathArgs","text":"<pre><code>inline void UriBraces::initPathArgs (\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/UriBraces.h</code></p>"},{"location":"ltapi/class_uri_glob/","title":"Class UriGlob","text":"<p>ClassList &gt; UriGlob</p> <p>Inherits the following classes: Uri</p>"},{"location":"ltapi/class_uri_glob/#public-functions","title":"Public Functions","text":"Type Name      UriGlob (const char * uri)     UriGlob (const String &amp; uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs) override   virtual Uri * clone () override const"},{"location":"ltapi/class_uri_glob/#public-functions-inherited-from-uri","title":"Public Functions inherited from Uri","text":"<p>See Uri</p>    Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri_glob/#protected-attributes-inherited-from-uri","title":"Protected Attributes inherited from Uri","text":"<p>See Uri</p>    Type Name     const String _uri"},{"location":"ltapi/class_uri_glob/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri_glob/#function-uriglob-12","title":"function UriGlob [1/2]","text":"<pre><code>inline explicit UriGlob::UriGlob (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_glob/#function-uriglob-22","title":"function UriGlob [2/2]","text":"<pre><code>inline explicit UriGlob::UriGlob (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_glob/#function-canhandle","title":"function canHandle","text":"<pre><code>inline virtual bool UriGlob::canHandle (\n    const String &amp; requestUri,\n    __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre> <p>Implements Uri::canHandle</p>"},{"location":"ltapi/class_uri_glob/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * UriGlob::clone () override const\n</code></pre> <p>Implements Uri::clone</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/UriGlob.h</code></p>"},{"location":"ltapi/class_uri_regex/","title":"Class UriRegex","text":"<p>ClassList &gt; UriRegex</p> <p>Inherits the following classes: Uri</p>"},{"location":"ltapi/class_uri_regex/#public-functions","title":"Public Functions","text":"Type Name      UriRegex (const char * uri)     UriRegex (const String &amp; uri)    bool canHandle (const String &amp; requestUri, std::vector&lt; String &gt; &amp; pathArgs) override   virtual Uri * clone () override const   void initPathArgs (std::vector&lt; String &gt; &amp; pathArgs) override"},{"location":"ltapi/class_uri_regex/#public-functions-inherited-from-uri","title":"Public Functions inherited from Uri","text":"<p>See Uri</p>    Type Name      Uri (const char * uri)     Uri (const String &amp; uri)     Uri (const __FlashStringHelper * uri)    virtual bool canHandle (const String &amp; requestUri, __attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual Uri * clone () const   virtual void initPathArgs (__attribute__((unused)) std::vector&lt; String &gt; &amp; pathArgs)    virtual ~Uri ()"},{"location":"ltapi/class_uri_regex/#protected-attributes-inherited-from-uri","title":"Protected Attributes inherited from Uri","text":"<p>See Uri</p>    Type Name     const String _uri"},{"location":"ltapi/class_uri_regex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_uri_regex/#function-uriregex-12","title":"function UriRegex [1/2]","text":"<pre><code>inline explicit UriRegex::UriRegex (\n    const char * uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_regex/#function-uriregex-22","title":"function UriRegex [2/2]","text":"<pre><code>inline explicit UriRegex::UriRegex (\n    const String &amp; uri\n) \n</code></pre>"},{"location":"ltapi/class_uri_regex/#function-canhandle","title":"function canHandle","text":"<pre><code>inline bool UriRegex::canHandle (\n    const String &amp; requestUri,\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>"},{"location":"ltapi/class_uri_regex/#function-clone","title":"function clone","text":"<pre><code>inline virtual Uri * UriRegex::clone () override const\n</code></pre> <p>Implements Uri::clone</p>"},{"location":"ltapi/class_uri_regex/#function-initpathargs","title":"function initPathArgs","text":"<pre><code>inline void UriRegex::initPathArgs (\n    std::vector&lt; String &gt; &amp; pathArgs\n) override\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/UriRegex.h</code></p>"},{"location":"ltapi/class_web_server/","title":"Class WebServer","text":"<p>ClassList &gt; WebServer</p>"},{"location":"ltapi/class_web_server/#public-types","title":"Public Types","text":"Type Name     typedef std::function&lt; void(void)&gt; THandlerFunction"},{"location":"ltapi/class_web_server/#public-functions","title":"Public Functions","text":"Type Name      WebServer (IPAddress addr, int port=80)     WebServer (int port=80)    void addHandler (RequestHandler * handler)    String arg (String name)    String arg (int i)    String argName (int i)    int args ()    bool authenticate (const char * username, const char * password)    virtual void begin ()    virtual void begin (uint16_t port)    virtual WiFiClient client ()    virtual void close ()    void collectHeaders (const char * headerKeys, const size_t headerKeysCount)    void enableCORS (boolean value=true)    void enableCrossOrigin (boolean value=true)    void enableDelay (boolean value)    virtual void handleClient ()    bool hasArg (String name)    bool hasHeader (String name)    String header (String name)    String header (int i)    String headerName (int i)    int headers ()    String hostHeader ()    HTTPMethod method ()    void on (const Uri &amp; uri, THandlerFunction fn)    void on (const Uri &amp; uri, HTTPMethod method, THandlerFunction fn)    void on (const Uri &amp; uri, HTTPMethod method, THandlerFunction fn, THandlerFunction ufn)    void onFileUpload (THandlerFunction ufn)    void onNotFound (THandlerFunction fn)    String pathArg (unsigned int i)    void requestAuthentication (HTTPAuthMethod mode=BASIC_AUTH, const char * realm=NULL, const String &amp; authFailMsg=String(\"\"))    void send (int code, const char * content_type=NULL, const String &amp; content=String(\"\"))    void send (int code, char * content_type, const String &amp; content)    void send (int code, const String &amp; content_type, const String &amp; content)    void sendContent (const String &amp; content)    void sendContent (const char * content, size_t contentLength)    void sendContent_P (PGM_P content)    void sendContent_P (PGM_P content, size_t size)    void sendHeader (const String &amp; name, const String &amp; value, bool first=false)    void send_P (int code, PGM_P content_type, PGM_P content)    void send_P (int code, PGM_P content_type, PGM_P content, size_t contentLength)    void serveStatic (const char * uri, fs::FS &amp; fs, const char * path, const char * cache_header=NULL)    void setContentLength (const size_t contentLength)    void stop ()    size_t streamFile (T &amp; file, const String &amp; contentType)    HTTPUpload &amp; upload ()    String uri ()    virtual ~WebServer ()"},{"location":"ltapi/class_web_server/#public-static-functions","title":"Public Static Functions","text":"Type Name     String urlDecode (const String &amp; text)"},{"location":"ltapi/class_web_server/#protected-attributes","title":"Protected Attributes","text":"Type Name     bool _chunked    size_t _contentLength    boolean _corsEnabled    int _currentArgCount    RequestArgument * _currentArgs    WiFiClient _currentClient    RequestHandler * _currentHandler    RequestArgument * _currentHeaders    HTTPMethod _currentMethod    HTTPClientStatus _currentStatus    std::unique_ptr&lt; HTTPUpload &gt; _currentUpload    String _currentUri    uint8_t _currentVersion    THandlerFunction _fileUploadHandler    RequestHandler * _firstHandler    int _headerKeysCount    String _hostHeader    RequestHandler * _lastHandler    THandlerFunction _notFoundHandler    boolean _nullDelay    RequestArgument * _postArgs    int _postArgsLen    String _responseHeaders    WiFiServer _server    String _snonce    String _sopaque    String _srealm    unsigned long _statusChange"},{"location":"ltapi/class_web_server/#protected-functions","title":"Protected Functions","text":"Type Name     void _addRequestHandler (RequestHandler * handler)    bool _collectHeader (const char * headerName, const char * headerValue)    virtual size_t _currentClientWrite (const char * b, size_t l)    virtual size_t _currentClientWrite_P (PGM_P b, size_t l)    String _extractParam (String &amp; authReq, const String &amp; param, const char delimit='\"')    void _finalizeResponse ()    String _getRandomHexString ()    void _handleRequest ()    void _parseArguments (String data)    bool _parseForm (WiFiClient &amp; client, String boundary, uint32_t len)    bool _parseFormUploadAborted ()    bool _parseRequest (WiFiClient &amp; client)    void _prepareHeader (String &amp; response, int code, const char * content_type, size_t contentLength)    void _streamFileCore (const size_t fileSize, const String &amp; fileName, const String &amp; contentType)    int _uploadReadByte (WiFiClient &amp; client)    void _uploadWriteByte (uint8_t b)"},{"location":"ltapi/class_web_server/#protected-static-functions","title":"Protected Static Functions","text":"Type Name     String _responseCodeToString (int code)"},{"location":"ltapi/class_web_server/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/class_web_server/#typedef-thandlerfunction","title":"typedef THandlerFunction","text":"<pre><code>typedef std::function&lt;void(void)&gt; WebServer::THandlerFunction;\n</code></pre>"},{"location":"ltapi/class_web_server/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-webserver-12","title":"function WebServer [1/2]","text":"<pre><code>WebServer::WebServer (\n    IPAddress addr,\n    int port=80\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-webserver-22","title":"function WebServer [2/2]","text":"<pre><code>WebServer::WebServer (\n    int port=80\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-addhandler","title":"function addHandler","text":"<pre><code>void WebServer::addHandler (\n    RequestHandler * handler\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-arg-12","title":"function arg [1/2]","text":"<pre><code>String WebServer::arg (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-arg-22","title":"function arg [2/2]","text":"<pre><code>String WebServer::arg (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-argname","title":"function argName","text":"<pre><code>String WebServer::argName (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-args","title":"function args","text":"<pre><code>int WebServer::args () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-authenticate","title":"function authenticate","text":"<pre><code>bool WebServer::authenticate (\n    const char * username,\n    const char * password\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>virtual void WebServer::begin () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>virtual void WebServer::begin (\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-client","title":"function client","text":"<pre><code>inline virtual WiFiClient WebServer::client () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-close","title":"function close","text":"<pre><code>virtual void WebServer::close () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-collectheaders","title":"function collectHeaders","text":"<pre><code>void WebServer::collectHeaders (\n    const char * headerKeys,\n    const size_t headerKeysCount\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-enablecors","title":"function enableCORS","text":"<pre><code>void WebServer::enableCORS (\n    boolean value=true\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-enablecrossorigin","title":"function enableCrossOrigin","text":"<pre><code>void WebServer::enableCrossOrigin (\n    boolean value=true\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-enabledelay","title":"function enableDelay","text":"<pre><code>void WebServer::enableDelay (\n    boolean value\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-handleclient","title":"function handleClient","text":"<pre><code>virtual void WebServer::handleClient () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-hasarg","title":"function hasArg","text":"<pre><code>bool WebServer::hasArg (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-hasheader","title":"function hasHeader","text":"<pre><code>bool WebServer::hasHeader (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-header-12","title":"function header [1/2]","text":"<pre><code>String WebServer::header (\n    String name\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-header-22","title":"function header [2/2]","text":"<pre><code>String WebServer::header (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-headername","title":"function headerName","text":"<pre><code>String WebServer::headerName (\n    int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-headers","title":"function headers","text":"<pre><code>int WebServer::headers () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-hostheader","title":"function hostHeader","text":"<pre><code>String WebServer::hostHeader () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-method","title":"function method","text":"<pre><code>inline HTTPMethod WebServer::method () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-on-13","title":"function on [1/3]","text":"<pre><code>void WebServer::on (\n    const Uri &amp; uri,\n    THandlerFunction fn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-on-23","title":"function on [2/3]","text":"<pre><code>void WebServer::on (\n    const Uri &amp; uri,\n    HTTPMethod method,\n    THandlerFunction fn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-on-33","title":"function on [3/3]","text":"<pre><code>void WebServer::on (\n    const Uri &amp; uri,\n    HTTPMethod method,\n    THandlerFunction fn,\n    THandlerFunction ufn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-onfileupload","title":"function onFileUpload","text":"<pre><code>void WebServer::onFileUpload (\n    THandlerFunction ufn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-onnotfound","title":"function onNotFound","text":"<pre><code>void WebServer::onNotFound (\n    THandlerFunction fn\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-patharg","title":"function pathArg","text":"<pre><code>String WebServer::pathArg (\n    unsigned int i\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-requestauthentication","title":"function requestAuthentication","text":"<pre><code>void WebServer::requestAuthentication (\n    HTTPAuthMethod mode=BASIC_AUTH,\n    const char * realm=NULL,\n    const String &amp; authFailMsg=String(\"\")\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send-13","title":"function send [1/3]","text":"<pre><code>void WebServer::send (\n    int code,\n    const char * content_type=NULL,\n    const String &amp; content=String(\"\")\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send-23","title":"function send [2/3]","text":"<pre><code>void WebServer::send (\n    int code,\n    char * content_type,\n    const String &amp; content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send-33","title":"function send [3/3]","text":"<pre><code>void WebServer::send (\n    int code,\n    const String &amp; content_type,\n    const String &amp; content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent-12","title":"function sendContent [1/2]","text":"<pre><code>void WebServer::sendContent (\n    const String &amp; content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent-22","title":"function sendContent [2/2]","text":"<pre><code>void WebServer::sendContent (\n    const char * content,\n    size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent_p-12","title":"function sendContent_P [1/2]","text":"<pre><code>void WebServer::sendContent_P (\n    PGM_P content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendcontent_p-22","title":"function sendContent_P [2/2]","text":"<pre><code>void WebServer::sendContent_P (\n    PGM_P content,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-sendheader","title":"function sendHeader","text":"<pre><code>void WebServer::sendHeader (\n    const String &amp; name,\n    const String &amp; value,\n    bool first=false\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send_p-12","title":"function send_P [1/2]","text":"<pre><code>void WebServer::send_P (\n    int code,\n    PGM_P content_type,\n    PGM_P content\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-send_p-22","title":"function send_P [2/2]","text":"<pre><code>void WebServer::send_P (\n    int code,\n    PGM_P content_type,\n    PGM_P content,\n    size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-servestatic","title":"function serveStatic","text":"<pre><code>void WebServer::serveStatic (\n    const char * uri,\n    fs::FS &amp; fs,\n    const char * path,\n    const char * cache_header=NULL\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-setcontentlength","title":"function setContentLength","text":"<pre><code>void WebServer::setContentLength (\n    const size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-stop","title":"function stop","text":"<pre><code>void WebServer::stop () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-streamfile","title":"function streamFile","text":"<pre><code>template&lt;typename T typename T&gt;\ninline size_t WebServer::streamFile (\n    T &amp; file,\n    const String &amp; contentType\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-upload","title":"function upload","text":"<pre><code>inline HTTPUpload &amp; WebServer::upload () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-uri","title":"function uri","text":"<pre><code>inline String WebServer::uri () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-webserver","title":"function ~WebServer","text":"<pre><code>virtual WebServer::~WebServer () \n</code></pre>"},{"location":"ltapi/class_web_server/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-urldecode","title":"function urlDecode","text":"<pre><code>static String WebServer::urlDecode (\n    const String &amp; text\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/class_web_server/#variable-_chunked","title":"variable _chunked","text":"<pre><code>bool WebServer::_chunked;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_contentlength","title":"variable _contentLength","text":"<pre><code>size_t WebServer::_contentLength;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_corsenabled","title":"variable _corsEnabled","text":"<pre><code>boolean WebServer::_corsEnabled;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentargcount","title":"variable _currentArgCount","text":"<pre><code>int WebServer::_currentArgCount;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentargs","title":"variable _currentArgs","text":"<pre><code>RequestArgument* WebServer::_currentArgs;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentclient","title":"variable _currentClient","text":"<pre><code>WiFiClient WebServer::_currentClient;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currenthandler","title":"variable _currentHandler","text":"<pre><code>RequestHandler* WebServer::_currentHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentheaders","title":"variable _currentHeaders","text":"<pre><code>RequestArgument* WebServer::_currentHeaders;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentmethod","title":"variable _currentMethod","text":"<pre><code>HTTPMethod WebServer::_currentMethod;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentstatus","title":"variable _currentStatus","text":"<pre><code>HTTPClientStatus WebServer::_currentStatus;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentupload","title":"variable _currentUpload","text":"<pre><code>std::unique_ptr&lt;HTTPUpload&gt; WebServer::_currentUpload;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currenturi","title":"variable _currentUri","text":"<pre><code>String WebServer::_currentUri;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_currentversion","title":"variable _currentVersion","text":"<pre><code>uint8_t WebServer::_currentVersion;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_fileuploadhandler","title":"variable _fileUploadHandler","text":"<pre><code>THandlerFunction WebServer::_fileUploadHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_firsthandler","title":"variable _firstHandler","text":"<pre><code>RequestHandler* WebServer::_firstHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_headerkeyscount","title":"variable _headerKeysCount","text":"<pre><code>int WebServer::_headerKeysCount;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_hostheader","title":"variable _hostHeader","text":"<pre><code>String WebServer::_hostHeader;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_lasthandler","title":"variable _lastHandler","text":"<pre><code>RequestHandler* WebServer::_lastHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_notfoundhandler","title":"variable _notFoundHandler","text":"<pre><code>THandlerFunction WebServer::_notFoundHandler;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_nulldelay","title":"variable _nullDelay","text":"<pre><code>boolean WebServer::_nullDelay;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_postargs","title":"variable _postArgs","text":"<pre><code>RequestArgument* WebServer::_postArgs;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_postargslen","title":"variable _postArgsLen","text":"<pre><code>int WebServer::_postArgsLen;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_responseheaders","title":"variable _responseHeaders","text":"<pre><code>String WebServer::_responseHeaders;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_server","title":"variable _server","text":"<pre><code>WiFiServer WebServer::_server;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_snonce","title":"variable _snonce","text":"<pre><code>String WebServer::_snonce;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_sopaque","title":"variable _sopaque","text":"<pre><code>String WebServer::_sopaque;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_srealm","title":"variable _srealm","text":"<pre><code>String WebServer::_srealm;\n</code></pre>"},{"location":"ltapi/class_web_server/#variable-_statuschange","title":"variable _statusChange","text":"<pre><code>unsigned long WebServer::_statusChange;\n</code></pre>"},{"location":"ltapi/class_web_server/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-_addrequesthandler","title":"function _addRequestHandler","text":"<pre><code>void WebServer::_addRequestHandler (\n    RequestHandler * handler\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_collectheader","title":"function _collectHeader","text":"<pre><code>bool WebServer::_collectHeader (\n    const char * headerName,\n    const char * headerValue\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_currentclientwrite","title":"function _currentClientWrite","text":"<pre><code>inline virtual size_t WebServer::_currentClientWrite (\n    const char * b,\n    size_t l\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_currentclientwrite_p","title":"function _currentClientWrite_P","text":"<pre><code>inline virtual size_t WebServer::_currentClientWrite_P (\n    PGM_P b,\n    size_t l\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_extractparam","title":"function _extractParam","text":"<pre><code>String WebServer::_extractParam (\n    String &amp; authReq,\n    const String &amp; param,\n    const char delimit='\"'\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_finalizeresponse","title":"function _finalizeResponse","text":"<pre><code>void WebServer::_finalizeResponse () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_getrandomhexstring","title":"function _getRandomHexString","text":"<pre><code>String WebServer::_getRandomHexString () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_handlerequest","title":"function _handleRequest","text":"<pre><code>void WebServer::_handleRequest () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parsearguments","title":"function _parseArguments","text":"<pre><code>void WebServer::_parseArguments (\n    String data\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parseform","title":"function _parseForm","text":"<pre><code>bool WebServer::_parseForm (\n    WiFiClient &amp; client,\n    String boundary,\n    uint32_t len\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parseformuploadaborted","title":"function _parseFormUploadAborted","text":"<pre><code>bool WebServer::_parseFormUploadAborted () \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_parserequest","title":"function _parseRequest","text":"<pre><code>bool WebServer::_parseRequest (\n    WiFiClient &amp; client\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_prepareheader","title":"function _prepareHeader","text":"<pre><code>void WebServer::_prepareHeader (\n    String &amp; response,\n    int code,\n    const char * content_type,\n    size_t contentLength\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_streamfilecore","title":"function _streamFileCore","text":"<pre><code>void WebServer::_streamFileCore (\n    const size_t fileSize,\n    const String &amp; fileName,\n    const String &amp; contentType\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_uploadreadbyte","title":"function _uploadReadByte","text":"<pre><code>int WebServer::_uploadReadByte (\n    WiFiClient &amp; client\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#function-_uploadwritebyte","title":"function _uploadWriteByte","text":"<pre><code>void WebServer::_uploadWriteByte (\n    uint8_t b\n) \n</code></pre>"},{"location":"ltapi/class_web_server/#protected-static-functions-documentation","title":"Protected Static Functions Documentation","text":""},{"location":"ltapi/class_web_server/#function-_responsecodetostring","title":"function _responseCodeToString","text":"<pre><code>static String WebServer::_responseCodeToString (\n    int code\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/WebServer.h</code></p>"},{"location":"ltapi/struct_web_server_1_1_request_argument/","title":"Struct WebServer::RequestArgument","text":"<p>ClassList &gt; WebServer &gt; RequestArgument</p>"},{"location":"ltapi/struct_web_server_1_1_request_argument/#public-attributes","title":"Public Attributes","text":"Type Name     String key    String value"},{"location":"ltapi/struct_web_server_1_1_request_argument/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_web_server_1_1_request_argument/#variable-key","title":"variable key","text":"<pre><code>String WebServer::RequestArgument::key;\n</code></pre>"},{"location":"ltapi/struct_web_server_1_1_request_argument/#variable-value","title":"variable value","text":"<pre><code>String WebServer::RequestArgument::value;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/WebServer.h</code></p>"},{"location":"ltapi/class_wi_fi_class/","title":"Class WiFiClass","text":"<p>ClassList &gt; WiFiClass</p>"},{"location":"ltapi/class_wi_fi_class/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiScanData * scan   = = NULL"},{"location":"ltapi/class_wi_fi_class/#public-functions","title":"Public Functions","text":"Type Name     uint8_t * BSSID ()    uint8_t * BSSID (uint8_t networkItem)    String BSSIDstr ()    String BSSIDstr (uint8_t networkItem)    int8_t RSSI ()    int32_t RSSI (uint8_t networkItem)    const String SSID ()    String SSID (uint8_t networkItem)     WiFiClass ()    WiFiStatus begin (const char * ssid, const char * passphrase=NULL, int32_t channel=0, const uint8_t * bssid=NULL, bool connect=true)    WiFiStatus begin (char * ssid, char * passphrase=NULL, int32_t channel=0, const uint8_t * bssid=NULL, bool connect=true)    IPAddress broadcastIP ()    int32_t channel ()    int32_t channel (uint8_t networkItem)    bool config (IPAddress localIP, IPAddress gateway, IPAddress subnet, IPAddress dns1=(uint32_t) 0x00000000, IPAddress dns2=(uint32_t) 0x00000000)    void dataFree ()    void dataInitialize ()    bool disconnect (bool wifiOff=false)    IPAddress dnsIP (uint8_t dns_no=0)    bool enableAP (bool enable)    bool enableIpV6 ()    bool enableSTA (bool enable)    WiFiAuthMode encryptionType (uint8_t networkItem)    IPAddress gatewayIP ()    bool getAutoReconnect ()    WiFiAuthMode getEncryption ()    const char * getHostname ()    WiFiMode getMode ()    bool getNetworkInfo (uint8_t networkItem, String &amp; ssid, WiFiAuthMode &amp; encryptionType, int32_t &amp; RSSI, uint8_t *&amp; BSSID, int32_t &amp; channel)    bool getSleep ()    int getTxPower ()    int hostByName (const char * hostname, IPAddress &amp; aResult)    IPAddress hostByName (const char * hostname)    bool hostname (const String &amp; aHostname)    bool isConnected ()    IPAddress localIP ()    IPv6Address localIPv6 ()    uint8_t * macAddress (uint8_t * mac)    String macAddress ()    bool mode (WiFiMode mode)    bool modePriv (WiFiMode mode, WiFiModeAction sta, WiFiModeAction ap)    IPAddress networkID ()    uint16_t onEvent (EventCb callback, EventId eventId=ARDUINO_EVENT_MAX)    uint16_t onEvent (EventFuncCb callback, EventId eventId=ARDUINO_EVENT_MAX)    uint16_t onEvent (EventSysCb callback, EventId eventId=ARDUINO_EVENT_MAX)    void printDiag (Print &amp; dest)    const String psk ()    bool reconnect (const uint8_t * bssid=NULL)    void removeEvent (EventCb callback, EventId eventId)    void removeEvent (EventSysCb callback, EventId eventId)    void removeEvent (uint16_t id)    uint8_t scanAlloc (uint8_t count)    int16_t scanComplete ()    void scanDelete ()    void scanInit ()    int16_t scanNetworks (bool async=false, bool showHidden=false, bool passive=false, uint32_t maxMsPerChannel=300, uint8_t channel=0)    bool setAutoReconnect (bool autoReconnect)    bool setHostname (const char * hostname)    bool setMacAddress (const uint8_t * mac)    bool setSleep (bool enable)    bool setTxPower (int power)    bool softAP (const char * ssid, const char * passphrase=NULL, int channel=1, bool ssidHidden=false, int maxClients=4)    IPAddress softAPBroadcastIP ()    bool softAPConfig (IPAddress localIP, IPAddress gateway, IPAddress subnet)    IPAddress softAPIP ()    IPv6Address softAPIPv6 ()    IPAddress softAPNetworkID ()    const String softAPSSID (void)    uint8_t softAPSubnetCIDR ()    IPAddress softAPSubnetMask ()    bool softAPdisconnect (bool wifiOff=false)    bool softAPenableIpV6 ()    const char * softAPgetHostname ()    uint8_t softAPgetStationNum ()    uint8_t * softAPmacAddress (uint8_t * mac)    String softAPmacAddress (void)    bool softAPsetHostname (const char * hostname)    WiFiStatus status ()    uint8_t subnetCIDR ()    IPAddress subnetMask ()    bool validate (const char * ssid, const char * passphrase)    WiFiStatus waitForConnectResult (unsigned long timeout)     ~WiFiClass ()"},{"location":"ltapi/class_wi_fi_class/#public-static-functions","title":"Public Static Functions","text":"Type Name     IPAddress calculateBroadcast (IPAddress ip, IPAddress subnet)    IPAddress calculateNetworkID (IPAddress ip, IPAddress subnet)    uint8_t calculateSubnetCIDR (IPAddress subnetMask)    String macToString (uint8_t * mac)    void postEvent (EventId eventId, EventInfo eventInfo)"},{"location":"ltapi/class_wi_fi_class/#protected-static-attributes","title":"Protected Static Attributes","text":"Type Name     std::vector&lt; EventHandler &gt; handlers"},{"location":"ltapi/class_wi_fi_class/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#variable-scan","title":"variable scan","text":"<pre><code>WiFiScanData* WiFiClass::scan;\n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#function-bssid-12","title":"function BSSID [1/2]","text":"<pre><code>uint8_t * WiFiClass::BSSID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-bssid-22","title":"function BSSID [2/2]","text":"<pre><code>uint8_t * WiFiClass::BSSID (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-bssidstr-12","title":"function BSSIDstr [1/2]","text":"<pre><code>String WiFiClass::BSSIDstr () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-bssidstr-22","title":"function BSSIDstr [2/2]","text":"<pre><code>String WiFiClass::BSSIDstr (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-rssi-12","title":"function RSSI [1/2]","text":"<pre><code>int8_t WiFiClass::RSSI () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-rssi-22","title":"function RSSI [2/2]","text":"<pre><code>int32_t WiFiClass::RSSI (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-ssid-12","title":"function SSID [1/2]","text":"<pre><code>const String WiFiClass::SSID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-ssid-22","title":"function SSID [2/2]","text":"<pre><code>String WiFiClass::SSID (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-wificlass","title":"function WiFiClass","text":"<pre><code>WiFiClass::WiFiClass () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>WiFiStatus WiFiClass::begin (\n    const char * ssid,\n    const char * passphrase=NULL,\n    int32_t channel=0,\n    const uint8_t * bssid=NULL,\n    bool connect=true\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>WiFiStatus WiFiClass::begin (\n    char * ssid,\n    char * passphrase=NULL,\n    int32_t channel=0,\n    const uint8_t * bssid=NULL,\n    bool connect=true\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-broadcastip","title":"function broadcastIP","text":"<pre><code>IPAddress WiFiClass::broadcastIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-channel-12","title":"function channel [1/2]","text":"<pre><code>int32_t WiFiClass::channel () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-channel-22","title":"function channel [2/2]","text":"<pre><code>int32_t WiFiClass::channel (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-config","title":"function config","text":"<pre><code>bool WiFiClass::config (\n    IPAddress localIP,\n    IPAddress gateway,\n    IPAddress subnet,\n    IPAddress dns1=(uint32_t) 0x00000000,\n    IPAddress dns2=(uint32_t) 0x00000000\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-datafree","title":"function dataFree","text":"<pre><code>void WiFiClass::dataFree () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-datainitialize","title":"function dataInitialize","text":"<pre><code>void WiFiClass::dataInitialize () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-disconnect","title":"function disconnect","text":"<pre><code>bool WiFiClass::disconnect (\n    bool wifiOff=false\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-dnsip","title":"function dnsIP","text":"<pre><code>IPAddress WiFiClass::dnsIP (\n    uint8_t dns_no=0\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-enableap","title":"function enableAP","text":"<pre><code>bool WiFiClass::enableAP (\n    bool enable\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-enableipv6","title":"function enableIpV6","text":"<pre><code>bool WiFiClass::enableIpV6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-enablesta","title":"function enableSTA","text":"<pre><code>bool WiFiClass::enableSTA (\n    bool enable\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-encryptiontype","title":"function encryptionType","text":"<pre><code>WiFiAuthMode WiFiClass::encryptionType (\n    uint8_t networkItem\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-gatewayip","title":"function gatewayIP","text":"<pre><code>IPAddress WiFiClass::gatewayIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getautoreconnect","title":"function getAutoReconnect","text":"<pre><code>bool WiFiClass::getAutoReconnect () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getencryption","title":"function getEncryption","text":"<pre><code>WiFiAuthMode WiFiClass::getEncryption () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-gethostname","title":"function getHostname","text":"<pre><code>const char * WiFiClass::getHostname () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getmode","title":"function getMode","text":"<pre><code>WiFiMode WiFiClass::getMode () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getnetworkinfo","title":"function getNetworkInfo","text":"<pre><code>bool WiFiClass::getNetworkInfo (\n    uint8_t networkItem,\n    String &amp; ssid,\n    WiFiAuthMode &amp; encryptionType,\n    int32_t &amp; RSSI,\n    uint8_t *&amp; BSSID,\n    int32_t &amp; channel\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-getsleep","title":"function getSleep","text":"<pre><code>bool WiFiClass::getSleep () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-gettxpower","title":"function getTxPower","text":"<pre><code>int WiFiClass::getTxPower () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-hostbyname-12","title":"function hostByName [1/2]","text":"<pre><code>int WiFiClass::hostByName (\n    const char * hostname,\n    IPAddress &amp; aResult\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-hostbyname-22","title":"function hostByName [2/2]","text":"<pre><code>IPAddress WiFiClass::hostByName (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-hostname","title":"function hostname","text":"<pre><code>inline bool WiFiClass::hostname (\n    const String &amp; aHostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-isconnected","title":"function isConnected","text":"<pre><code>bool WiFiClass::isConnected () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-localip","title":"function localIP","text":"<pre><code>IPAddress WiFiClass::localIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-localipv6","title":"function localIPv6","text":"<pre><code>IPv6Address WiFiClass::localIPv6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-macaddress-12","title":"function macAddress [1/2]","text":"<pre><code>uint8_t * WiFiClass::macAddress (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-macaddress-22","title":"function macAddress [2/2]","text":"<pre><code>String WiFiClass::macAddress () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-mode","title":"function mode","text":"<pre><code>bool WiFiClass::mode (\n    WiFiMode mode\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-modepriv","title":"function modePriv","text":"<pre><code>bool WiFiClass::modePriv (\n    WiFiMode mode,\n    WiFiModeAction sta,\n    WiFiModeAction ap\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-networkid","title":"function networkID","text":"<pre><code>IPAddress WiFiClass::networkID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-onevent-13","title":"function onEvent [1/3]","text":"<pre><code>uint16_t WiFiClass::onEvent (\n    EventCb callback,\n    EventId eventId=ARDUINO_EVENT_MAX\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-onevent-23","title":"function onEvent [2/3]","text":"<pre><code>uint16_t WiFiClass::onEvent (\n    EventFuncCb callback,\n    EventId eventId=ARDUINO_EVENT_MAX\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-onevent-33","title":"function onEvent [3/3]","text":"<pre><code>uint16_t WiFiClass::onEvent (\n    EventSysCb callback,\n    EventId eventId=ARDUINO_EVENT_MAX\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-printdiag","title":"function printDiag","text":"<pre><code>void WiFiClass::printDiag (\n    Print &amp; dest\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-psk","title":"function psk","text":"<pre><code>const String WiFiClass::psk () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-reconnect","title":"function reconnect","text":"<pre><code>bool WiFiClass::reconnect (\n    const uint8_t * bssid=NULL\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-removeevent-13","title":"function removeEvent [1/3]","text":"<pre><code>void WiFiClass::removeEvent (\n    EventCb callback,\n    EventId eventId\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-removeevent-23","title":"function removeEvent [2/3]","text":"<pre><code>void WiFiClass::removeEvent (\n    EventSysCb callback,\n    EventId eventId\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-removeevent-33","title":"function removeEvent [3/3]","text":"<pre><code>void WiFiClass::removeEvent (\n    uint16_t id\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scanalloc","title":"function scanAlloc","text":"<pre><code>uint8_t WiFiClass::scanAlloc (\n    uint8_t count\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scancomplete","title":"function scanComplete","text":"<pre><code>int16_t WiFiClass::scanComplete () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scandelete","title":"function scanDelete","text":"<pre><code>void WiFiClass::scanDelete () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scaninit","title":"function scanInit","text":"<pre><code>void WiFiClass::scanInit () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-scannetworks","title":"function scanNetworks","text":"<pre><code>int16_t WiFiClass::scanNetworks (\n    bool async=false,\n    bool showHidden=false,\n    bool passive=false,\n    uint32_t maxMsPerChannel=300,\n    uint8_t channel=0\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-setautoreconnect","title":"function setAutoReconnect","text":"<pre><code>bool WiFiClass::setAutoReconnect (\n    bool autoReconnect\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-sethostname","title":"function setHostname","text":"<pre><code>bool WiFiClass::setHostname (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-setmacaddress","title":"function setMacAddress","text":"<pre><code>bool WiFiClass::setMacAddress (\n    const uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-setsleep","title":"function setSleep","text":"<pre><code>bool WiFiClass::setSleep (\n    bool enable\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-settxpower","title":"function setTxPower","text":"<pre><code>bool WiFiClass::setTxPower (\n    int power\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softap","title":"function softAP","text":"<pre><code>bool WiFiClass::softAP (\n    const char * ssid,\n    const char * passphrase=NULL,\n    int channel=1,\n    bool ssidHidden=false,\n    int maxClients=4\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapbroadcastip","title":"function softAPBroadcastIP","text":"<pre><code>IPAddress WiFiClass::softAPBroadcastIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapconfig","title":"function softAPConfig","text":"<pre><code>bool WiFiClass::softAPConfig (\n    IPAddress localIP,\n    IPAddress gateway,\n    IPAddress subnet\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapip","title":"function softAPIP","text":"<pre><code>IPAddress WiFiClass::softAPIP () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapipv6","title":"function softAPIPv6","text":"<pre><code>IPv6Address WiFiClass::softAPIPv6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapnetworkid","title":"function softAPNetworkID","text":"<pre><code>IPAddress WiFiClass::softAPNetworkID () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapssid","title":"function softAPSSID","text":"<pre><code>const String WiFiClass::softAPSSID (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapsubnetcidr","title":"function softAPSubnetCIDR","text":"<pre><code>uint8_t WiFiClass::softAPSubnetCIDR () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapsubnetmask","title":"function softAPSubnetMask","text":"<pre><code>IPAddress WiFiClass::softAPSubnetMask () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapdisconnect","title":"function softAPdisconnect","text":"<pre><code>bool WiFiClass::softAPdisconnect (\n    bool wifiOff=false\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapenableipv6","title":"function softAPenableIpV6","text":"<pre><code>bool WiFiClass::softAPenableIpV6 () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapgethostname","title":"function softAPgetHostname","text":"<pre><code>const char * WiFiClass::softAPgetHostname () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapgetstationnum","title":"function softAPgetStationNum","text":"<pre><code>uint8_t WiFiClass::softAPgetStationNum () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapmacaddress-12","title":"function softAPmacAddress [1/2]","text":"<pre><code>uint8_t * WiFiClass::softAPmacAddress (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapmacaddress-22","title":"function softAPmacAddress [2/2]","text":"<pre><code>String WiFiClass::softAPmacAddress (\n    void\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-softapsethostname","title":"function softAPsetHostname","text":"<pre><code>bool WiFiClass::softAPsetHostname (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-status","title":"function status","text":"<pre><code>WiFiStatus WiFiClass::status () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-subnetcidr","title":"function subnetCIDR","text":"<pre><code>uint8_t WiFiClass::subnetCIDR () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-subnetmask","title":"function subnetMask","text":"<pre><code>IPAddress WiFiClass::subnetMask () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-validate","title":"function validate","text":"<pre><code>bool WiFiClass::validate (\n    const char * ssid,\n    const char * passphrase\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-waitforconnectresult","title":"function waitForConnectResult","text":"<pre><code>WiFiStatus WiFiClass::waitForConnectResult (\n    unsigned long timeout\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-wificlass_1","title":"function ~WiFiClass","text":"<pre><code>WiFiClass::~WiFiClass () \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#function-calculatebroadcast","title":"function calculateBroadcast","text":"<pre><code>static IPAddress WiFiClass::calculateBroadcast (\n    IPAddress ip,\n    IPAddress subnet\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-calculatenetworkid","title":"function calculateNetworkID","text":"<pre><code>static IPAddress WiFiClass::calculateNetworkID (\n    IPAddress ip,\n    IPAddress subnet\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-calculatesubnetcidr","title":"function calculateSubnetCIDR","text":"<pre><code>static uint8_t WiFiClass::calculateSubnetCIDR (\n    IPAddress subnetMask\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-mactostring","title":"function macToString","text":"<pre><code>static String WiFiClass::macToString (\n    uint8_t * mac\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#function-postevent","title":"function postEvent","text":"<pre><code>static void WiFiClass::postEvent (\n    EventId eventId,\n    EventInfo eventInfo\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_class/#protected-static-attributes-documentation","title":"Protected Static Attributes Documentation","text":""},{"location":"ltapi/class_wi_fi_class/#variable-handlers","title":"variable handlers","text":"<pre><code>std::vector&lt; EventHandler &gt; WiFiClass::handlers;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFi.h</code></p>"},{"location":"ltapi/struct_wi_fi_mac_addr/","title":"Struct WiFiMacAddr","text":"<p>ClassList &gt; WiFiMacAddr</p>"},{"location":"ltapi/struct_wi_fi_mac_addr/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t addr"},{"location":"ltapi/struct_wi_fi_mac_addr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_mac_addr/#variable-addr","title":"variable addr","text":"<pre><code>uint8_t WiFiMacAddr::addr[6];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/class_wi_fi_multi/","title":"Class WiFiMulti","text":"<p>ClassList &gt; WiFiMulti</p>"},{"location":"ltapi/class_wi_fi_multi/#public-functions","title":"Public Functions","text":"Type Name      WiFiMulti ()    bool addAP (const char * ssid, const char * passphrase=NULL)    uint8_t run (uint32_t connectTimeout=10000)     ~WiFiMulti ()"},{"location":"ltapi/class_wi_fi_multi/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/class_wi_fi_multi/#function-wifimulti","title":"function WiFiMulti","text":"<pre><code>WiFiMulti::WiFiMulti () \n</code></pre>"},{"location":"ltapi/class_wi_fi_multi/#function-addap","title":"function addAP","text":"<pre><code>bool WiFiMulti::addAP (\n    const char * ssid,\n    const char * passphrase=NULL\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_multi/#function-run","title":"function run","text":"<pre><code>uint8_t WiFiMulti::run (\n    uint32_t connectTimeout=10000\n) \n</code></pre>"},{"location":"ltapi/class_wi_fi_multi/#function-wifimulti_1","title":"function ~WiFiMulti","text":"<pre><code>WiFiMulti::~WiFiMulti () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WiFiMulti/WiFiMulti.h</code></p>"},{"location":"ltapi/struct_wi_fi_scan_a_p/","title":"Struct WiFiScanAP","text":"<p>ClassList &gt; WiFiScanAP</p>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiAuthMode auth    WiFiMacAddr bssid    int32_t channel    int32_t rssi    char * ssid"},{"location":"ltapi/struct_wi_fi_scan_a_p/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-auth","title":"variable auth","text":"<pre><code>WiFiAuthMode WiFiScanAP::auth;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-bssid","title":"variable bssid","text":"<pre><code>WiFiMacAddr WiFiScanAP::bssid;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-channel","title":"variable channel","text":"<pre><code>int32_t WiFiScanAP::channel;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-rssi","title":"variable rssi","text":"<pre><code>int32_t WiFiScanAP::rssi;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_a_p/#variable-ssid","title":"variable ssid","text":"<pre><code>char* WiFiScanAP::ssid;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/struct_wi_fi_scan_data/","title":"Struct WiFiScanData","text":"<p>ClassList &gt; WiFiScanData</p>"},{"location":"ltapi/struct_wi_fi_scan_data/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiScanAP * ap   = = NULL   uint8_t count   = = 0   bool running   = = false   unsigned long timeout   = = 0"},{"location":"ltapi/struct_wi_fi_scan_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wi_fi_scan_data/#variable-ap","title":"variable ap","text":"<pre><code>WiFiScanAP* WiFiScanData::ap;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_data/#variable-count","title":"variable count","text":"<pre><code>uint8_t WiFiScanData::count;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_data/#variable-running","title":"variable running","text":"<pre><code>bool WiFiScanData::running;\n</code></pre>"},{"location":"ltapi/struct_wi_fi_scan_data/#variable-timeout","title":"variable timeout","text":"<pre><code>unsigned long WiFiScanData::timeout;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/struct_wifi_a_plist__t/","title":"Struct WifiAPlist_t","text":"<p>ClassList &gt; WifiAPlist_t</p>"},{"location":"ltapi/struct_wifi_a_plist__t/#public-attributes","title":"Public Attributes","text":"Type Name     char * passphrase    char * ssid"},{"location":"ltapi/struct_wifi_a_plist__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/struct_wifi_a_plist__t/#variable-passphrase","title":"variable passphrase","text":"<pre><code>char* WifiAPlist_t::passphrase;\n</code></pre>"},{"location":"ltapi/struct_wifi_a_plist__t/#variable-ssid","title":"variable ssid","text":"<pre><code>char* WifiAPlist_t::ssid;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WiFiMulti/WiFiMulti.h</code></p>"},{"location":"ltapi/namespacearduino/","title":"Namespace arduino","text":"<p>Namespace List &gt; arduino</p>"},{"location":"ltapi/namespacearduino/#classes","title":"Classes","text":"Type Name     class IPv6Address      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/IPv6Address.h</code></p>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/","title":"Class arduino::IPv6Address","text":"<p>ClassList &gt; arduino &gt; IPv6Address</p> <p>Inherits the following classes: Printable</p>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t bytes    uint32_t dword"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-functions","title":"Public Functions","text":"Type Name      IPv6Address ()     IPv6Address (const uint8_t * address)     IPv6Address (const uint32_t * address)    bool fromString (const char * address)    bool fromString (const String &amp; address)     operator const uint32_t * () const    operator const uint8_t * () const   IPv6Address &amp; operator= (const uint8_t * address)    bool operator== (const IPv6Address &amp; addr) const   bool operator== (const uint8_t * addr) const   uint8_t operator[] (int index) const   uint8_t &amp; operator[] (int index)    virtual size_t printTo (Print &amp; p) const   String toString () const   virtual ~IPv6Address ()"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/classarduino_1_1_i_pv6_address/#variable-bytes","title":"variable bytes","text":"<pre><code>uint8_t arduino::IPv6Address::bytes[16];\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#variable-dword","title":"variable dword","text":"<pre><code>uint32_t arduino::IPv6Address::dword[4];\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address-13","title":"function IPv6Address [1/3]","text":"<pre><code>arduino::IPv6Address::IPv6Address () \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address-23","title":"function IPv6Address [2/3]","text":"<pre><code>arduino::IPv6Address::IPv6Address (\n    const uint8_t * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address-33","title":"function IPv6Address [3/3]","text":"<pre><code>arduino::IPv6Address::IPv6Address (\n    const uint32_t * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-fromstring-12","title":"function fromString [1/2]","text":"<pre><code>bool arduino::IPv6Address::fromString (\n    const char * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-fromstring-22","title":"function fromString [2/2]","text":"<pre><code>inline bool arduino::IPv6Address::fromString (\n    const String &amp; address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator-const-uint32_t","title":"function operator const uint32_t *","text":"<pre><code>inline arduino::IPv6Address::operator const uint32_t * () const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator-const-uint8_t","title":"function operator const uint8_t *","text":"<pre><code>inline arduino::IPv6Address::operator const uint8_t * () const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator","title":"function operator=","text":"<pre><code>IPv6Address &amp; arduino::IPv6Address::operator= (\n    const uint8_t * address\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_1","title":"function operator==","text":"<pre><code>inline bool arduino::IPv6Address::operator== (\n    const IPv6Address &amp; addr\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_2","title":"function operator==","text":"<pre><code>bool arduino::IPv6Address::operator== (\n    const uint8_t * addr\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_3","title":"function operator[]","text":"<pre><code>inline uint8_t arduino::IPv6Address::operator[] (\n    int index\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-operator_4","title":"function operator[]","text":"<pre><code>inline uint8_t &amp; arduino::IPv6Address::operator[] (\n    int index\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-printto","title":"function printTo","text":"<pre><code>virtual size_t arduino::IPv6Address::printTo (\n    Print &amp; p\n) const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-tostring","title":"function toString","text":"<pre><code>String arduino::IPv6Address::toString () const\n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#function-ipv6address","title":"function ~IPv6Address","text":"<pre><code>inline virtual arduino::IPv6Address::~IPv6Address () \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friends-documentation","title":"Friends Documentation","text":""},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friend-client","title":"friend Client","text":"<pre><code>class arduino::IPv6Address::Client (\n    Client\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friend-server","title":"friend Server","text":"<pre><code>class arduino::IPv6Address::Server (\n    Server\n) \n</code></pre>"},{"location":"ltapi/classarduino_1_1_i_pv6_address/#friend-udp","title":"friend UDP","text":"<pre><code>class arduino::IPv6Address::UDP (\n    UDP\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/IPv6Address.h</code></p>"},{"location":"ltapi/unionarduino__event__info__t/","title":"Union arduino_event_info_t","text":"<p>ClassList &gt; arduino_event_info_t</p>"},{"location":"ltapi/unionarduino__event__info__t/#public-attributes","title":"Public Attributes","text":"Type Name     ip_event_got_ip_t got_ip    ip_event_got_ip6_t got_ip6    wifi_event_ap_probe_req_rx_t wifi_ap_probereqrecved    wifi_event_ap_staconnected_t wifi_ap_staconnected    wifi_event_ap_stadisconnected_t wifi_ap_stadisconnected    ip_event_ap_staipassigned_t wifi_ap_staipassigned    wifi_event_ftm_report_t wifi_ftm_report    wifi_event_sta_scan_done_t wifi_scan_done    wifi_event_sta_authmode_change_t wifi_sta_authmode_change    wifi_event_sta_connected_t wifi_sta_connected    wifi_event_sta_disconnected_t wifi_sta_disconnected    wifi_event_sta_wps_er_pin_t wps_er_pin    wifi_event_sta_wps_fail_reason_t wps_fail_reason"},{"location":"ltapi/unionarduino__event__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/unionarduino__event__info__t/#variable-got_ip","title":"variable got_ip","text":"<pre><code>ip_event_got_ip_t arduino_event_info_t::got_ip;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-got_ip6","title":"variable got_ip6","text":"<pre><code>ip_event_got_ip6_t arduino_event_info_t::got_ip6;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_probereqrecved","title":"variable wifi_ap_probereqrecved","text":"<pre><code>wifi_event_ap_probe_req_rx_t arduino_event_info_t::wifi_ap_probereqrecved;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_staconnected","title":"variable wifi_ap_staconnected","text":"<pre><code>wifi_event_ap_staconnected_t arduino_event_info_t::wifi_ap_staconnected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_stadisconnected","title":"variable wifi_ap_stadisconnected","text":"<pre><code>wifi_event_ap_stadisconnected_t arduino_event_info_t::wifi_ap_stadisconnected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ap_staipassigned","title":"variable wifi_ap_staipassigned","text":"<pre><code>ip_event_ap_staipassigned_t arduino_event_info_t::wifi_ap_staipassigned;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_ftm_report","title":"variable wifi_ftm_report","text":"<pre><code>wifi_event_ftm_report_t arduino_event_info_t::wifi_ftm_report;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_scan_done","title":"variable wifi_scan_done","text":"<pre><code>wifi_event_sta_scan_done_t arduino_event_info_t::wifi_scan_done;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_sta_authmode_change","title":"variable wifi_sta_authmode_change","text":"<pre><code>wifi_event_sta_authmode_change_t arduino_event_info_t::wifi_sta_authmode_change;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_sta_connected","title":"variable wifi_sta_connected","text":"<pre><code>wifi_event_sta_connected_t arduino_event_info_t::wifi_sta_connected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wifi_sta_disconnected","title":"variable wifi_sta_disconnected","text":"<pre><code>wifi_event_sta_disconnected_t arduino_event_info_t::wifi_sta_disconnected;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wps_er_pin","title":"variable wps_er_pin","text":"<pre><code>wifi_event_sta_wps_er_pin_t arduino_event_info_t::wps_er_pin;\n</code></pre>"},{"location":"ltapi/unionarduino__event__info__t/#variable-wps_fail_reason","title":"variable wps_fail_reason","text":"<pre><code>wifi_event_sta_wps_fail_reason_t arduino_event_info_t::wps_fail_reason;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Events.h</code></p>"},{"location":"ltapi/structarduino__event__t/","title":"Struct arduino_event_t","text":"<p>ClassList &gt; arduino_event_t</p>"},{"location":"ltapi/structarduino__event__t/#public-attributes","title":"Public Attributes","text":"Type Name     arduino_event_id_t event_id    arduino_event_info_t event_info"},{"location":"ltapi/structarduino__event__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structarduino__event__t/#variable-event_id","title":"variable event_id","text":"<pre><code>arduino_event_id_t arduino_event_t::event_id;\n</code></pre>"},{"location":"ltapi/structarduino__event__t/#variable-event_info","title":"variable event_info","text":"<pre><code>arduino_event_info_t arduino_event_t::event_info;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Events.h</code></p>"},{"location":"ltapi/classbase64/","title":"Class base64","text":"<p>ClassList &gt; base64</p>"},{"location":"ltapi/classbase64/#public-static-functions","title":"Public Static Functions","text":"Type Name     String encode (const uint8_t * data, size_t length)    String encode (const String &amp; text)"},{"location":"ltapi/classbase64/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/classbase64/#function-encode-12","title":"function encode [1/2]","text":"<pre><code>static String base64::encode (\n    const uint8_t * data,\n    size_t length\n) \n</code></pre> <p>base64.cpp</p> <p>Created on: 09.12.2015</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the ESP31B core for Arduino.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA convert input data to base64 </p> <p>Parameters:</p> <ul> <li><code>data</code> const uint8_t * </li> <li><code>length</code> size_t </li> </ul> <p>Returns:</p> <p>String </p>"},{"location":"ltapi/classbase64/#function-encode-22","title":"function encode [2/2]","text":"<pre><code>static String base64::encode (\n    const String &amp; text\n) \n</code></pre> <p>convert input data to base64 </p> <p>Parameters:</p> <ul> <li><code>text</code> const String&amp; </li> </ul> <p>Returns:</p> <p>String </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/base64.h</code></p>"},{"location":"ltapi/structbase64__decodestate/","title":"Struct base64_decodestate","text":"<p>ClassList &gt; base64_decodestate</p>"},{"location":"ltapi/structbase64__decodestate/#public-attributes","title":"Public Attributes","text":"Type Name     char plainchar    base64_decodestep step"},{"location":"ltapi/structbase64__decodestate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structbase64__decodestate/#variable-plainchar","title":"variable plainchar","text":"<pre><code>char base64_decodestate::plainchar;\n</code></pre>"},{"location":"ltapi/structbase64__decodestate/#variable-step","title":"variable step","text":"<pre><code>base64_decodestep base64_decodestate::step;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/cdecode.h</code></p>"},{"location":"ltapi/structbase64__encodestate/","title":"Struct base64_encodestate","text":"<p>ClassList &gt; base64_encodestate</p>"},{"location":"ltapi/structbase64__encodestate/#public-attributes","title":"Public Attributes","text":"Type Name     char result    base64_encodestep step    int stepcount"},{"location":"ltapi/structbase64__encodestate/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structbase64__encodestate/#variable-result","title":"variable result","text":"<pre><code>char base64_encodestate::result;\n</code></pre>"},{"location":"ltapi/structbase64__encodestate/#variable-step","title":"variable step","text":"<pre><code>base64_encodestep base64_encodestate::step;\n</code></pre>"},{"location":"ltapi/structbase64__encodestate/#variable-stepcount","title":"variable stepcount","text":"<pre><code>int base64_encodestate::stepcount;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/cencode.h</code></p>"},{"location":"ltapi/classcbuf/","title":"Class cbuf","text":"<p>ClassList &gt; cbuf</p>"},{"location":"ltapi/classcbuf/#public-attributes","title":"Public Attributes","text":"Type Name     cbuf * next"},{"location":"ltapi/classcbuf/#public-functions","title":"Public Functions","text":"Type Name     size_t available () const    cbuf (size_t size)    bool empty () const   void flush ()    bool full () const   int peek ()    size_t peek (char * dst, size_t size)    int read ()    size_t read (char * dst, size_t size)    size_t remove (size_t size)    size_t resize (size_t newSize)    size_t resizeAdd (size_t addSize)    size_t room () const   size_t size ()    size_t write (char c)    size_t write (const char * src, size_t size)     ~cbuf ()"},{"location":"ltapi/classcbuf/#protected-attributes","title":"Protected Attributes","text":"Type Name     char * _begin    char * _buf    const char * _bufend    char * _end    size_t _size"},{"location":"ltapi/classcbuf/#protected-functions","title":"Protected Functions","text":"Type Name     char * wrap_if_bufend (char * ptr) const"},{"location":"ltapi/classcbuf/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/classcbuf/#variable-next","title":"variable next","text":"<pre><code>cbuf* cbuf::next;\n</code></pre>"},{"location":"ltapi/classcbuf/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classcbuf/#function-available","title":"function available","text":"<pre><code>size_t cbuf::available () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-cbuf","title":"function cbuf","text":"<pre><code>cbuf::cbuf (\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-empty","title":"function empty","text":"<pre><code>inline bool cbuf::empty () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-flush","title":"function flush","text":"<pre><code>void cbuf::flush () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-full","title":"function full","text":"<pre><code>inline bool cbuf::full () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-peek-12","title":"function peek [1/2]","text":"<pre><code>int cbuf::peek () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-peek-22","title":"function peek [2/2]","text":"<pre><code>size_t cbuf::peek (\n    char * dst,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-read-12","title":"function read [1/2]","text":"<pre><code>int cbuf::read () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-read-22","title":"function read [2/2]","text":"<pre><code>size_t cbuf::read (\n    char * dst,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-remove","title":"function remove","text":"<pre><code>size_t cbuf::remove (\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-resize","title":"function resize","text":"<pre><code>size_t cbuf::resize (\n    size_t newSize\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-resizeadd","title":"function resizeAdd","text":"<pre><code>size_t cbuf::resizeAdd (\n    size_t addSize\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-room","title":"function room","text":"<pre><code>size_t cbuf::room () const\n</code></pre>"},{"location":"ltapi/classcbuf/#function-size","title":"function size","text":"<pre><code>size_t cbuf::size () \n</code></pre>"},{"location":"ltapi/classcbuf/#function-write-12","title":"function write [1/2]","text":"<pre><code>size_t cbuf::write (\n    char c\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-write-22","title":"function write [2/2]","text":"<pre><code>size_t cbuf::write (\n    const char * src,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classcbuf/#function-cbuf_1","title":"function ~cbuf","text":"<pre><code>cbuf::~cbuf () \n</code></pre>"},{"location":"ltapi/classcbuf/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/classcbuf/#variable-_begin","title":"variable _begin","text":"<pre><code>char* cbuf::_begin;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_buf","title":"variable _buf","text":"<pre><code>char* cbuf::_buf;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_bufend","title":"variable _bufend","text":"<pre><code>const char* cbuf::_bufend;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_end","title":"variable _end","text":"<pre><code>char* cbuf::_end;\n</code></pre>"},{"location":"ltapi/classcbuf/#variable-_size","title":"variable _size","text":"<pre><code>size_t cbuf::_size;\n</code></pre>"},{"location":"ltapi/classcbuf/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"ltapi/classcbuf/#function-wrap_if_bufend","title":"function wrap_if_bufend","text":"<pre><code>inline char * cbuf::wrap_if_bufend (\n    char * ptr\n) const\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/cbuf/cbuf.h</code></p>"},{"location":"ltapi/structesp__ip4__addr/","title":"Struct esp_ip4_addr","text":"<p>ClassList &gt; esp_ip4_addr</p>"},{"location":"ltapi/structesp__ip4__addr/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t addr"},{"location":"ltapi/structesp__ip4__addr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__ip4__addr/#variable-addr","title":"variable addr","text":"<pre><code>uint32_t esp_ip4_addr::addr;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/structesp__ip6__addr/","title":"Struct esp_ip6_addr","text":"<p>ClassList &gt; esp_ip6_addr</p>"},{"location":"ltapi/structesp__ip6__addr/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t addr    uint8_t zone"},{"location":"ltapi/structesp__ip6__addr/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__ip6__addr/#variable-addr","title":"variable addr","text":"<pre><code>uint32_t esp_ip6_addr::addr[4];\n</code></pre>"},{"location":"ltapi/structesp__ip6__addr/#variable-zone","title":"variable zone","text":"<pre><code>uint8_t esp_ip6_addr::zone;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/structesp__netif__ip6__info__t/","title":"Struct esp_netif_ip6_info_t","text":"<p>ClassList &gt; esp_netif_ip6_info_t</p> <p>IPV6 IP address information. </p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structesp__netif__ip6__info__t/#public-attributes","title":"Public Attributes","text":"Type Name     esp_ip6_addr_t ip"},{"location":"ltapi/structesp__netif__ip6__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__netif__ip6__info__t/#variable-ip","title":"variable ip","text":"<pre><code>esp_ip6_addr_t esp_netif_ip6_info_t::ip;\n</code></pre> <p>Interface IPV6 address </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structesp__netif__ip__info__t/","title":"Struct esp_netif_ip_info_t","text":"<p>ClassList &gt; esp_netif_ip_info_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structesp__netif__ip__info__t/#public-attributes","title":"Public Attributes","text":"Type Name     esp_ip4_addr_t gw    esp_ip4_addr_t ip    esp_ip4_addr_t netmask"},{"location":"ltapi/structesp__netif__ip__info__t/#detailed-description","title":"Detailed Description","text":"<p>Event structure for IP_EVENT_STA_GOT_IP, IP_EVENT_ETH_GOT_IP events </p>"},{"location":"ltapi/structesp__netif__ip__info__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structesp__netif__ip__info__t/#variable-gw","title":"variable gw","text":"<pre><code>esp_ip4_addr_t esp_netif_ip_info_t::gw;\n</code></pre> <p>Interface IPV4 gateway address </p>"},{"location":"ltapi/structesp__netif__ip__info__t/#variable-ip","title":"variable ip","text":"<pre><code>esp_ip4_addr_t esp_netif_ip_info_t::ip;\n</code></pre> <p>Interface IPV4 address </p>"},{"location":"ltapi/structesp__netif__ip__info__t/#variable-netmask","title":"variable netmask","text":"<pre><code>esp_ip4_addr_t esp_netif_ip_info_t::netmask;\n</code></pre> <p>Interface IPV4 netmask </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/namespacefs/","title":"Namespace fs","text":"<p>Namespace List &gt; fs</p>"},{"location":"ltapi/namespacefs/#classes","title":"Classes","text":"Type Name     class FS    class FSImpl    class File    class FileImpl"},{"location":"ltapi/namespacefs/#public-types","title":"Public Types","text":"Type Name     typedef std::shared_ptr&lt; FSImpl &gt; FSImplPtr    typedef std::shared_ptr&lt; FileImpl &gt; FileImplPtr    enum SeekMode"},{"location":"ltapi/namespacefs/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/namespacefs/#typedef-fsimplptr","title":"typedef FSImplPtr","text":"<pre><code>typedef std::shared_ptr&lt;FSImpl&gt; fs::FSImplPtr;\n</code></pre>"},{"location":"ltapi/namespacefs/#typedef-fileimplptr","title":"typedef FileImplPtr","text":"<pre><code>typedef std::shared_ptr&lt;FileImpl&gt; fs::FileImplPtr;\n</code></pre>"},{"location":"ltapi/namespacefs/#enum-seekmode","title":"enum SeekMode","text":"<pre><code>enum fs::SeekMode {\n    SeekSet = 0,\n    SeekCur = 1,\n    SeekEnd = 2\n};\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_f_s/","title":"Class fs::FS","text":"<p>ClassList &gt; fs &gt; FS</p>"},{"location":"ltapi/classfs_1_1_f_s/#public-functions","title":"Public Functions","text":"Type Name      FS (FSImplPtr impl)    bool exists (const char * path)    bool exists (const String &amp; path)    bool mkdir (const char * path)    bool mkdir (const String &amp; path)    File open (const char * path, const char * mode=FILE_READ, const bool create=false)    File open (const String &amp; path, const char * mode=FILE_READ, const bool create=false)    bool remove (const char * path)    bool remove (const String &amp; path)    bool rename (const char * pathFrom, const char * pathTo)    bool rename (const String &amp; pathFrom, const String &amp; pathTo)    bool rmdir (const char * path)    bool rmdir (const String &amp; path)"},{"location":"ltapi/classfs_1_1_f_s/#protected-attributes","title":"Protected Attributes","text":"Type Name     FSImplPtr _impl"},{"location":"ltapi/classfs_1_1_f_s/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_f_s/#function-fs","title":"function FS","text":"<pre><code>inline fs::FS::FS (\n    FSImplPtr impl\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-exists-12","title":"function exists [1/2]","text":"<pre><code>bool fs::FS::exists (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-exists-22","title":"function exists [2/2]","text":"<pre><code>bool fs::FS::exists (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-mkdir-12","title":"function mkdir [1/2]","text":"<pre><code>bool fs::FS::mkdir (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-mkdir-22","title":"function mkdir [2/2]","text":"<pre><code>bool fs::FS::mkdir (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-open-12","title":"function open [1/2]","text":"<pre><code>File fs::FS::open (\n    const char * path,\n    const char * mode=FILE_READ,\n    const bool create=false\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-open-22","title":"function open [2/2]","text":"<pre><code>File fs::FS::open (\n    const String &amp; path,\n    const char * mode=FILE_READ,\n    const bool create=false\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-remove-12","title":"function remove [1/2]","text":"<pre><code>bool fs::FS::remove (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-remove-22","title":"function remove [2/2]","text":"<pre><code>bool fs::FS::remove (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rename-12","title":"function rename [1/2]","text":"<pre><code>bool fs::FS::rename (\n    const char * pathFrom,\n    const char * pathTo\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rename-22","title":"function rename [2/2]","text":"<pre><code>bool fs::FS::rename (\n    const String &amp; pathFrom,\n    const String &amp; pathTo\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rmdir-12","title":"function rmdir [1/2]","text":"<pre><code>bool fs::FS::rmdir (\n    const char * path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#function-rmdir-22","title":"function rmdir [2/2]","text":"<pre><code>bool fs::FS::rmdir (\n    const String &amp; path\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/classfs_1_1_f_s/#variable-_impl","title":"variable _impl","text":"<pre><code>FSImplPtr fs::FS::_impl;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_f_s_impl/","title":"Class fs::FSImpl","text":"<p>ClassList &gt; fs &gt; FSImpl</p>"},{"location":"ltapi/classfs_1_1_f_s_impl/#public-functions","title":"Public Functions","text":"Type Name      FSImpl ()    virtual bool exists (const char * path) = 0   virtual bool mkdir (const char * path) = 0   virtual FileImplPtr open (const char * path, const char * mode, const bool create) = 0   virtual bool remove (const char * path) = 0   virtual bool rename (const char * pathFrom, const char * pathTo) = 0   virtual bool rmdir (const char * path) = 0   virtual ~FSImpl ()"},{"location":"ltapi/classfs_1_1_f_s_impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_f_s_impl/#function-fsimpl","title":"function FSImpl","text":"<pre><code>inline fs::FSImpl::FSImpl () \n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-exists","title":"function exists","text":"<pre><code>virtual bool fs::FSImpl::exists (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-mkdir","title":"function mkdir","text":"<pre><code>virtual bool fs::FSImpl::mkdir (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-open","title":"function open","text":"<pre><code>virtual FileImplPtr fs::FSImpl::open (\n    const char * path,\n    const char * mode,\n    const bool create\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-remove","title":"function remove","text":"<pre><code>virtual bool fs::FSImpl::remove (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-rename","title":"function rename","text":"<pre><code>virtual bool fs::FSImpl::rename (\n    const char * pathFrom,\n    const char * pathTo\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-rmdir","title":"function rmdir","text":"<pre><code>virtual bool fs::FSImpl::rmdir (\n    const char * path\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_f_s_impl/#function-fsimpl_1","title":"function ~FSImpl","text":"<pre><code>inline virtual fs::FSImpl::~FSImpl () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_file/","title":"Class fs::File","text":"<p>ClassList &gt; fs &gt; File</p> <p>Inherits the following classes: Stream</p>"},{"location":"ltapi/classfs_1_1_file/#public-functions","title":"Public Functions","text":"Type Name      File (FileImplPtr p=FileImplPtr())    int available () override   void close ()    void flush () override   time_t getLastWrite ()    boolean isDirectory (void)    const char * name () const   File openNextFile (const char * mode=FILE_READ)     operator bool () const   const char * path () const   int peek () override   size_t position () const   int read () override   size_t read (uint8_t * buf, size_t size)    size_t readBytes (char * buffer, size_t length)    void rewindDirectory (void)    bool seek (uint32_t pos, SeekMode mode)    bool seek (uint32_t pos)    bool setBufferSize (size_t size)    size_t size () const   size_t write (uint8_t c) override   size_t write (const uint8_t * buf, size_t size) override"},{"location":"ltapi/classfs_1_1_file/#protected-attributes","title":"Protected Attributes","text":"Type Name     FileImplPtr _p"},{"location":"ltapi/classfs_1_1_file/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_file/#function-file","title":"function File","text":"<pre><code>inline fs::File::File (\n    FileImplPtr p=FileImplPtr()\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-available","title":"function available","text":"<pre><code>int fs::File::available () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-close","title":"function close","text":"<pre><code>void fs::File::close () \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-flush","title":"function flush","text":"<pre><code>void fs::File::flush () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-getlastwrite","title":"function getLastWrite","text":"<pre><code>time_t fs::File::getLastWrite () \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-isdirectory","title":"function isDirectory","text":"<pre><code>boolean fs::File::isDirectory (\n    void\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-name","title":"function name","text":"<pre><code>const char * fs::File::name () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-opennextfile","title":"function openNextFile","text":"<pre><code>File fs::File::openNextFile (\n    const char * mode=FILE_READ\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-operator-bool","title":"function operator bool","text":"<pre><code>fs::File::operator bool () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-path","title":"function path","text":"<pre><code>const char * fs::File::path () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-peek","title":"function peek","text":"<pre><code>int fs::File::peek () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-position","title":"function position","text":"<pre><code>size_t fs::File::position () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-read-12","title":"function read [1/2]","text":"<pre><code>int fs::File::read () override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-read-22","title":"function read [2/2]","text":"<pre><code>size_t fs::File::read (\n    uint8_t * buf,\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-readbytes","title":"function readBytes","text":"<pre><code>inline size_t fs::File::readBytes (\n    char * buffer,\n    size_t length\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-rewinddirectory","title":"function rewindDirectory","text":"<pre><code>void fs::File::rewindDirectory (\n    void\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-seek-12","title":"function seek [1/2]","text":"<pre><code>bool fs::File::seek (\n    uint32_t pos,\n    SeekMode mode\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-seek-22","title":"function seek [2/2]","text":"<pre><code>inline bool fs::File::seek (\n    uint32_t pos\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-setbuffersize","title":"function setBufferSize","text":"<pre><code>bool fs::File::setBufferSize (\n    size_t size\n) \n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-size","title":"function size","text":"<pre><code>size_t fs::File::size () const\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-write-12","title":"function write [1/2]","text":"<pre><code>size_t fs::File::write (\n    uint8_t c\n) override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#function-write-22","title":"function write [2/2]","text":"<pre><code>size_t fs::File::write (\n    const uint8_t * buf,\n    size_t size\n) override\n</code></pre>"},{"location":"ltapi/classfs_1_1_file/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"ltapi/classfs_1_1_file/#variable-_p","title":"variable _p","text":"<pre><code>FileImplPtr fs::File::_p;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.h</code></p>"},{"location":"ltapi/classfs_1_1_file_impl/","title":"Class fs::FileImpl","text":"<p>ClassList &gt; fs &gt; FileImpl</p>"},{"location":"ltapi/classfs_1_1_file_impl/#public-functions","title":"Public Functions","text":"Type Name     virtual void close () = 0   virtual void flush () = 0   virtual time_t getLastWrite () = 0   virtual boolean isDirectory (void) = 0   virtual const char * name () const = 0   virtual FileImplPtr openNextFile (const char * mode) = 0   virtual operator bool () = 0   virtual const char * path () const = 0   virtual size_t position () const = 0   virtual size_t read (uint8_t * buf, size_t size) = 0   virtual void rewindDirectory (void) = 0   virtual bool seek (uint32_t pos, SeekMode mode) = 0   virtual bool setBufferSize (size_t size) = 0   virtual size_t size () const = 0   virtual size_t write (const uint8_t * buf, size_t size) = 0   virtual ~FileImpl ()"},{"location":"ltapi/classfs_1_1_file_impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classfs_1_1_file_impl/#function-close","title":"function close","text":"<pre><code>virtual void fs::FileImpl::close () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-flush","title":"function flush","text":"<pre><code>virtual void fs::FileImpl::flush () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-getlastwrite","title":"function getLastWrite","text":"<pre><code>virtual time_t fs::FileImpl::getLastWrite () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-isdirectory","title":"function isDirectory","text":"<pre><code>virtual boolean fs::FileImpl::isDirectory (\n    void\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-name","title":"function name","text":"<pre><code>virtual const char * fs::FileImpl::name () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-opennextfile","title":"function openNextFile","text":"<pre><code>virtual FileImplPtr fs::FileImpl::openNextFile (\n    const char * mode\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-operator-bool","title":"function operator bool","text":"<pre><code>virtual fs::FileImpl::operator bool () = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-path","title":"function path","text":"<pre><code>virtual const char * fs::FileImpl::path () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-position","title":"function position","text":"<pre><code>virtual size_t fs::FileImpl::position () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-read","title":"function read","text":"<pre><code>virtual size_t fs::FileImpl::read (\n    uint8_t * buf,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-rewinddirectory","title":"function rewindDirectory","text":"<pre><code>virtual void fs::FileImpl::rewindDirectory (\n    void\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-seek","title":"function seek","text":"<pre><code>virtual bool fs::FileImpl::seek (\n    uint32_t pos,\n    SeekMode mode\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-setbuffersize","title":"function setBufferSize","text":"<pre><code>virtual bool fs::FileImpl::setBufferSize (\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-size","title":"function size","text":"<pre><code>virtual size_t fs::FileImpl::size () const = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-write","title":"function write","text":"<pre><code>virtual size_t fs::FileImpl::write (\n    const uint8_t * buf,\n    size_t size\n) = 0\n</code></pre>"},{"location":"ltapi/classfs_1_1_file_impl/#function-fileimpl","title":"function ~FileImpl","text":"<pre><code>inline virtual fs::FileImpl::~FileImpl () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.h</code></p>"},{"location":"ltapi/structip__event__ap__staipassigned__t/","title":"Struct ip_event_ap_staipassigned_t","text":"<p>ClassList &gt; ip_event_ap_staipassigned_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structip__event__ap__staipassigned__t/#public-attributes","title":"Public Attributes","text":"Type Name     esp_ip4_addr_t ip"},{"location":"ltapi/structip__event__ap__staipassigned__t/#detailed-description","title":"Detailed Description","text":"<p>Event structure for IP_EVENT_AP_STAIPASSIGNED event </p>"},{"location":"ltapi/structip__event__ap__staipassigned__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structip__event__ap__staipassigned__t/#variable-ip","title":"variable ip","text":"<pre><code>esp_ip4_addr_t ip_event_ap_staipassigned_t::ip;\n</code></pre> <p>IP address which was assigned to the station </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structip__event__got__ip6__t/","title":"Struct ip_event_got_ip6_t","text":"<p>ClassList &gt; ip_event_got_ip6_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structip__event__got__ip6__t/#public-attributes","title":"Public Attributes","text":"Type Name     void * esp_netif    int if_index    esp_netif_ip6_info_t ip6_info    int ip_index"},{"location":"ltapi/structip__event__got__ip6__t/#detailed-description","title":"Detailed Description","text":"<p>Event structure for IP_EVENT_GOT_IP6 event </p>"},{"location":"ltapi/structip__event__got__ip6__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structip__event__got__ip6__t/#variable-esp_netif","title":"variable esp_netif","text":"<pre><code>void* ip_event_got_ip6_t::esp_netif;\n</code></pre> <p>Pointer to corresponding esp-netif object </p>"},{"location":"ltapi/structip__event__got__ip6__t/#variable-if_index","title":"variable if_index","text":"<pre><code>int ip_event_got_ip6_t::if_index;\n</code></pre> <p>Interface index for which the event is received (left for legacy compilation) </p>"},{"location":"ltapi/structip__event__got__ip6__t/#variable-ip6_info","title":"variable ip6_info","text":"<pre><code>esp_netif_ip6_info_t ip_event_got_ip6_t::ip6_info;\n</code></pre> <p>IPv6 address of the interface </p>"},{"location":"ltapi/structip__event__got__ip6__t/#variable-ip_index","title":"variable ip_index","text":"<pre><code>int ip_event_got_ip6_t::ip_index;\n</code></pre> <p>IPv6 address index </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structip__event__got__ip__t/","title":"Struct ip_event_got_ip_t","text":"<p>ClassList &gt; ip_event_got_ip_t</p>"},{"location":"ltapi/structip__event__got__ip__t/#public-attributes","title":"Public Attributes","text":"Type Name     void * esp_netif    int if_index    bool ip_changed    esp_netif_ip_info_t ip_info"},{"location":"ltapi/structip__event__got__ip__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structip__event__got__ip__t/#variable-esp_netif","title":"variable esp_netif","text":"<pre><code>void* ip_event_got_ip_t::esp_netif;\n</code></pre> <p>Pointer to corresponding esp-netif object </p>"},{"location":"ltapi/structip__event__got__ip__t/#variable-if_index","title":"variable if_index","text":"<pre><code>int ip_event_got_ip_t::if_index;\n</code></pre> <p>Interface index for which the event is received (left for legacy compilation) </p>"},{"location":"ltapi/structip__event__got__ip__t/#variable-ip_changed","title":"variable ip_changed","text":"<pre><code>bool ip_event_got_ip_t::ip_changed;\n</code></pre> <p>Whether the assigned IP has changed or not </p>"},{"location":"ltapi/structip__event__got__ip__t/#variable-ip_info","title":"variable ip_info","text":"<pre><code>esp_netif_ip_info_t ip_event_got_ip_t::ip_info;\n</code></pre> <p>IP address, netmask, gatway IP address </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/classm_d_n_s/","title":"Class mDNS","text":"<p>ClassList &gt; mDNS</p>"},{"location":"ltapi/classm_d_n_s/#public-functions","title":"Public Functions","text":"Type Name     IPAddress IP (int idx)    IPv6Address IPv6 (int idx)    bool addService (char * service, char * proto, uint16_t port)    bool addService (const char * service, const char * proto, uint16_t port)    bool addService (String service, String proto, uint16_t port)    bool addServiceTxt (char * service, char * proto, char * key, char * value)    void addServiceTxt (const char * service, const char * proto, const char * key, const char * value)    void addServiceTxt (String service, String proto, String key, String value)    bool begin (const char * hostname)    void end ()    bool hasTxt (int idx, const char * key)    String hostname (int idx)     mDNS ()    int numTxt (int idx)    uint16_t port (int idx)    IPAddress queryHost (char * host, uint32_t timeout=2000)    IPAddress queryHost (const char * host, uint32_t timeout=2000)    IPAddress queryHost (String host, uint32_t timeout=2000)    int queryService (char * service, char * proto)    int queryService (const char * service, const char * proto)    int queryService (String service, String proto)    void setInstanceName (const char * name)    void setInstanceName (String name)    void setInstanceName (char * name)    String txt (int idx, const char * key)    String txt (int idx, int txtIdx)    String txtKey (int idx, int txtIdx)     ~mDNS ()"},{"location":"ltapi/classm_d_n_s/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/classm_d_n_s/#function-ip","title":"function IP","text":"<pre><code>IPAddress mDNS::IP (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-ipv6","title":"function IPv6","text":"<pre><code>IPv6Address mDNS::IPv6 (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservice-13","title":"function addService [1/3]","text":"<pre><code>bool mDNS::addService (\n    char * service,\n    char * proto,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservice-23","title":"function addService [2/3]","text":"<pre><code>inline bool mDNS::addService (\n    const char * service,\n    const char * proto,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservice-33","title":"function addService [3/3]","text":"<pre><code>inline bool mDNS::addService (\n    String service,\n    String proto,\n    uint16_t port\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservicetxt-13","title":"function addServiceTxt [1/3]","text":"<pre><code>bool mDNS::addServiceTxt (\n    char * service,\n    char * proto,\n    char * key,\n    char * value\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservicetxt-23","title":"function addServiceTxt [2/3]","text":"<pre><code>inline void mDNS::addServiceTxt (\n    const char * service,\n    const char * proto,\n    const char * key,\n    const char * value\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-addservicetxt-33","title":"function addServiceTxt [3/3]","text":"<pre><code>inline void mDNS::addServiceTxt (\n    String service,\n    String proto,\n    String key,\n    String value\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-begin","title":"function begin","text":"<pre><code>bool mDNS::begin (\n    const char * hostname\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-end","title":"function end","text":"<pre><code>void mDNS::end () \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-hastxt","title":"function hasTxt","text":"<pre><code>bool mDNS::hasTxt (\n    int idx,\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-hostname","title":"function hostname","text":"<pre><code>String mDNS::hostname (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-mdns","title":"function mDNS","text":"<pre><code>mDNS::mDNS () \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-numtxt","title":"function numTxt","text":"<pre><code>int mDNS::numTxt (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-port","title":"function port","text":"<pre><code>uint16_t mDNS::port (\n    int idx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryhost-13","title":"function queryHost [1/3]","text":"<pre><code>IPAddress mDNS::queryHost (\n    char * host,\n    uint32_t timeout=2000\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryhost-23","title":"function queryHost [2/3]","text":"<pre><code>inline IPAddress mDNS::queryHost (\n    const char * host,\n    uint32_t timeout=2000\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryhost-33","title":"function queryHost [3/3]","text":"<pre><code>inline IPAddress mDNS::queryHost (\n    String host,\n    uint32_t timeout=2000\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryservice-13","title":"function queryService [1/3]","text":"<pre><code>int mDNS::queryService (\n    char * service,\n    char * proto\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryservice-23","title":"function queryService [2/3]","text":"<pre><code>inline int mDNS::queryService (\n    const char * service,\n    const char * proto\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-queryservice-33","title":"function queryService [3/3]","text":"<pre><code>inline int mDNS::queryService (\n    String service,\n    String proto\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-setinstancename-13","title":"function setInstanceName [1/3]","text":"<pre><code>void mDNS::setInstanceName (\n    const char * name\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-setinstancename-23","title":"function setInstanceName [2/3]","text":"<pre><code>inline void mDNS::setInstanceName (\n    String name\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-setinstancename-33","title":"function setInstanceName [3/3]","text":"<pre><code>inline void mDNS::setInstanceName (\n    char * name\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-txt-12","title":"function txt [1/2]","text":"<pre><code>String mDNS::txt (\n    int idx,\n    const char * key\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-txt-22","title":"function txt [2/2]","text":"<pre><code>String mDNS::txt (\n    int idx,\n    int txtIdx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-txtkey","title":"function txtKey","text":"<pre><code>String mDNS::txtKey (\n    int idx,\n    int txtIdx\n) \n</code></pre>"},{"location":"ltapi/classm_d_n_s/#function-mdns_1","title":"function ~mDNS","text":"<pre><code>mDNS::~mDNS () \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/mDNS/mDNS.h</code></p>"},{"location":"ltapi/namespacemime/","title":"Namespace mime","text":"<p>Namespace List &gt; mime</p>"},{"location":"ltapi/namespacemime/#classes","title":"Classes","text":"Type Name     struct Entry"},{"location":"ltapi/namespacemime/#public-types","title":"Public Types","text":"Type Name     enum type"},{"location":"ltapi/namespacemime/#public-attributes","title":"Public Attributes","text":"Type Name     const Entry mimeTable   = = {   {\".html\",     \"text/html\"                    },    {\".htm\",         \"text/html\"                    },    {\".css\",         \"text/css\"                    },    {\".txt\",         \"text/plain\"                    },    {\".js\",     \"application/javascript\"        },    {\".json\",     \"application/json\"                },    {\".png\",         \"image/png\"                    },    {\".gif\",         \"image/gif\"                    },    {\".jpg\",         \"image/jpeg\"                    },    {\".ico\",         \"image/x-icon\"                },    {\".svg\",         \"image/svg+xml\"                },    {\".ttf\",         \"application/x-font-ttf\"        },    {\".otf\",         \"application/x-font-opentype\"  },    {\".woff\",     \"application/font-woff\"        },    {\".woff2\",     \"application/font-woff2\"    },    {\".eot\",         \"application/vnd.ms-fontobject\"},    {\".sfnt\",     \"application/font-sfnt\"        },    {\".xml\",         \"text/xml\"                    },    {\".pdf\",         \"application/pdf\"            },    {\".zip\",         \"application/zip\"            },    {\".gz\",     \"application/x-gzip\"            },    {\".appcache\", \"text/cache-manifest\"        },    {\"\",          \"application/octet-stream\"       }    }"},{"location":"ltapi/namespacemime/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/namespacemime/#enum-type","title":"enum type","text":"<pre><code>enum mime::type {\n    html,\n    htm,\n    css,\n    txt,\n    js,\n    json,\n    png,\n    gif,\n    jpg,\n    ico,\n    svg,\n    ttf,\n    otf,\n    woff,\n    woff2,\n    eot,\n    sfnt,\n    xml,\n    pdf,\n    zip,\n    gz,\n    appcache,\n    none,\n    maxType\n};\n</code></pre>"},{"location":"ltapi/namespacemime/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/namespacemime/#variable-mimetable","title":"variable mimeTable","text":"<pre><code>const Entry mime::mimeTable;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/mimetable.cpp</code></p>"},{"location":"ltapi/structmime_1_1_entry/","title":"Struct mime::Entry","text":"<p>ClassList &gt; mime &gt; Entry</p>"},{"location":"ltapi/structmime_1_1_entry/#public-attributes","title":"Public Attributes","text":"Type Name     const char endsWith    const char mimeType"},{"location":"ltapi/structmime_1_1_entry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structmime_1_1_entry/#variable-endswith","title":"variable endsWith","text":"<pre><code>const char mime::Entry::endsWith[16];\n</code></pre>"},{"location":"ltapi/structmime_1_1_entry/#variable-mimetype","title":"variable mimeType","text":"<pre><code>const char mime::Entry::mimeType[32];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/mimetable.h</code></p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/","title":"Struct wifi_event_action_tx_status_t","text":"<p>ClassList &gt; wifi_event_action_tx_status_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t context    uint8_t da    int ifx    uint8_t status"},{"location":"ltapi/structwifi__event__action__tx__status__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_ACTION_TX_STATUS event </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-context","title":"variable context","text":"<pre><code>uint32_t wifi_event_action_tx_status_t::context;\n</code></pre> <p>Context to identify the request </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-da","title":"variable da","text":"<pre><code>uint8_t wifi_event_action_tx_status_t::da[6];\n</code></pre> <p>Destination MAC address </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-ifx","title":"variable ifx","text":"<pre><code>int wifi_event_action_tx_status_t::ifx;\n</code></pre> <p>WiFi interface to send request to </p>"},{"location":"ltapi/structwifi__event__action__tx__status__t/#variable-status","title":"variable status","text":"<pre><code>uint8_t wifi_event_action_tx_status_t::status;\n</code></pre> <p>Status of the operation </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/","title":"Struct wifi_event_ap_probe_req_rx_t","text":"<p>ClassList &gt; wifi_event_ap_probe_req_rx_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t mac    int rssi"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_AP_PROBEREQRECVED event </p>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#variable-mac","title":"variable mac","text":"<pre><code>uint8_t wifi_event_ap_probe_req_rx_t::mac[6];\n</code></pre> <p>MAC address of the station which send probe request </p>"},{"location":"ltapi/structwifi__event__ap__probe__req__rx__t/#variable-rssi","title":"variable rssi","text":"<pre><code>int wifi_event_ap_probe_req_rx_t::rssi;\n</code></pre> <p>Received probe request signal strength </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/","title":"Struct wifi_event_ap_staconnected_t","text":"<p>ClassList &gt; wifi_event_ap_staconnected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t aid    bool is_mesh_child    uint8_t mac"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_AP_STACONNECTED event </p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ap__staconnected__t/#variable-aid","title":"variable aid","text":"<pre><code>uint8_t wifi_event_ap_staconnected_t::aid;\n</code></pre> <p>the aid that ESP32 soft-AP gives to the station connected to </p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#variable-is_mesh_child","title":"variable is_mesh_child","text":"<pre><code>bool wifi_event_ap_staconnected_t::is_mesh_child;\n</code></pre> <p>flag to identify mesh child </p>"},{"location":"ltapi/structwifi__event__ap__staconnected__t/#variable-mac","title":"variable mac","text":"<pre><code>uint8_t wifi_event_ap_staconnected_t::mac[6];\n</code></pre> <p>MAC address of the station connected to ESP32 soft-AP </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/","title":"Struct wifi_event_ap_stadisconnected_t","text":"<p>ClassList &gt; wifi_event_ap_stadisconnected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t aid    bool is_mesh_child    uint8_t mac"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_AP_STADISCONNECTED event </p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#variable-aid","title":"variable aid","text":"<pre><code>uint8_t wifi_event_ap_stadisconnected_t::aid;\n</code></pre> <p>the aid that ESP32 soft-AP gave to the station disconnects to </p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#variable-is_mesh_child","title":"variable is_mesh_child","text":"<pre><code>bool wifi_event_ap_stadisconnected_t::is_mesh_child;\n</code></pre> <p>flag to identify mesh child </p>"},{"location":"ltapi/structwifi__event__ap__stadisconnected__t/#variable-mac","title":"variable mac","text":"<pre><code>uint8_t wifi_event_ap_stadisconnected_t::mac[6];\n</code></pre> <p>MAC address of the station disconnects to ESP32 soft-AP </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__ftm__report__t/","title":"Struct wifi_event_ftm_report_t","text":"<p>ClassList &gt; wifi_event_ftm_report_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__ftm__report__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t dist_est    wifi_ftm_report_entry_t * ftm_report_data    uint8_t ftm_report_num_entries    uint8_t peer_mac    uint32_t rtt_est    uint32_t rtt_raw    wifi_ftm_status_t status"},{"location":"ltapi/structwifi__event__ftm__report__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_FTM_REPORT event </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-dist_est","title":"variable dist_est","text":"<pre><code>uint32_t wifi_event_ftm_report_t::dist_est;\n</code></pre> <p>Estimated one-way distance in Centi-Meters </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-ftm_report_data","title":"variable ftm_report_data","text":"<pre><code>wifi_ftm_report_entry_t* wifi_event_ftm_report_t::ftm_report_data;\n</code></pre> <p>Pointer to FTM Report with multiple entries, should be freed after use </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-ftm_report_num_entries","title":"variable ftm_report_num_entries","text":"<pre><code>uint8_t wifi_event_ftm_report_t::ftm_report_num_entries;\n</code></pre> <p>Number of entries in the FTM Report data </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-peer_mac","title":"variable peer_mac","text":"<pre><code>uint8_t wifi_event_ftm_report_t::peer_mac[6];\n</code></pre> <p>MAC address of the FTM Peer </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-rtt_est","title":"variable rtt_est","text":"<pre><code>uint32_t wifi_event_ftm_report_t::rtt_est;\n</code></pre> <p>Estimated Round-Trip-Time with peer in Nano-Seconds </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-rtt_raw","title":"variable rtt_raw","text":"<pre><code>uint32_t wifi_event_ftm_report_t::rtt_raw;\n</code></pre> <p>Raw average Round-Trip-Time with peer in Nano-Seconds </p>"},{"location":"ltapi/structwifi__event__ftm__report__t/#variable-status","title":"variable status","text":"<pre><code>wifi_ftm_status_t wifi_event_ftm_report_t::status;\n</code></pre> <p>Status of the FTM operation </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__roc__done__t/","title":"Struct wifi_event_roc_done_t","text":"<p>ClassList &gt; wifi_event_roc_done_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__roc__done__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint32_t context"},{"location":"ltapi/structwifi__event__roc__done__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_ROC_DONE event </p>"},{"location":"ltapi/structwifi__event__roc__done__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__roc__done__t/#variable-context","title":"variable context","text":"<pre><code>uint32_t wifi_event_roc_done_t::context;\n</code></pre> <p>Context to identify the request </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/","title":"Struct wifi_event_sta_authmode_change_t","text":"<p>ClassList &gt; wifi_event_sta_authmode_change_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#public-attributes","title":"Public Attributes","text":"Type Name     wifi_auth_mode_t new_mode    wifi_auth_mode_t old_mode"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_AUTHMODE_CHANGE event </p>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#variable-new_mode","title":"variable new_mode","text":"<pre><code>wifi_auth_mode_t wifi_event_sta_authmode_change_t::new_mode;\n</code></pre> <p>the new auth mode of AP </p>"},{"location":"ltapi/structwifi__event__sta__authmode__change__t/#variable-old_mode","title":"variable old_mode","text":"<pre><code>wifi_auth_mode_t wifi_event_sta_authmode_change_t::old_mode;\n</code></pre> <p>the old auth mode of AP </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__connected__t/","title":"Struct wifi_event_sta_connected_t","text":"<p>ClassList &gt; wifi_event_sta_connected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__connected__t/#public-attributes","title":"Public Attributes","text":"Type Name     wifi_auth_mode_t authmode    uint8_t bssid    uint8_t channel    uint8_t ssid    uint8_t ssid_len"},{"location":"ltapi/structwifi__event__sta__connected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_CONNECTED event </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-authmode","title":"variable authmode","text":"<pre><code>wifi_auth_mode_t wifi_event_sta_connected_t::authmode;\n</code></pre> <p>authentication mode used by AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-bssid","title":"variable bssid","text":"<pre><code>uint8_t wifi_event_sta_connected_t::bssid[6];\n</code></pre> <p>BSSID of connected AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-channel","title":"variable channel","text":"<pre><code>uint8_t wifi_event_sta_connected_t::channel;\n</code></pre> <p>channel of connected AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-ssid","title":"variable ssid","text":"<pre><code>uint8_t wifi_event_sta_connected_t::ssid[32];\n</code></pre> <p>SSID of connected AP </p>"},{"location":"ltapi/structwifi__event__sta__connected__t/#variable-ssid_len","title":"variable ssid_len","text":"<pre><code>uint8_t wifi_event_sta_connected_t::ssid_len;\n</code></pre> <p>SSID length of connected AP </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/","title":"Struct wifi_event_sta_disconnected_t","text":"<p>ClassList &gt; wifi_event_sta_disconnected_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t bssid    uint8_t reason    uint8_t ssid    uint8_t ssid_len"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_DISCONNECTED event </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-bssid","title":"variable bssid","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::bssid[6];\n</code></pre> <p>BSSID of disconnected AP </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-reason","title":"variable reason","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::reason;\n</code></pre> <p>reason of disconnection </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-ssid","title":"variable ssid","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::ssid[32];\n</code></pre> <p>SSID of disconnected AP </p>"},{"location":"ltapi/structwifi__event__sta__disconnected__t/#variable-ssid_len","title":"variable ssid_len","text":"<pre><code>uint8_t wifi_event_sta_disconnected_t::ssid_len;\n</code></pre> <p>SSID length of disconnected AP </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/","title":"Struct wifi_event_sta_scan_done_t","text":"<p>ClassList &gt; wifi_event_sta_scan_done_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t number    uint8_t scan_id    uint32_t status"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_SCAN_DONE event </p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__scan__done__t/#variable-number","title":"variable number","text":"<pre><code>uint8_t wifi_event_sta_scan_done_t::number;\n</code></pre> <p>number of scan results </p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#variable-scan_id","title":"variable scan_id","text":"<pre><code>uint8_t wifi_event_sta_scan_done_t::scan_id;\n</code></pre> <p>scan sequence number, used for block scan </p>"},{"location":"ltapi/structwifi__event__sta__scan__done__t/#variable-status","title":"variable status","text":"<pre><code>uint32_t wifi_event_sta_scan_done_t::status;\n</code></pre> <p>status of scanning APs: 0 - success, 1 - failure </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/","title":"Struct wifi_event_sta_wps_er_pin_t","text":"<p>ClassList &gt; wifi_event_sta_wps_er_pin_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t pin_code"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_WPS_ER_PIN event </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__wps__er__pin__t/#variable-pin_code","title":"variable pin_code","text":"<pre><code>uint8_t wifi_event_sta_wps_er_pin_t::pin_code[8];\n</code></pre> <p>PIN code of station in enrollee mode </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/","title":"Struct wifi_event_sta_wps_er_success_t","text":"<p>ClassList &gt; wifi_event_sta_wps_er_success_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#public-attributes","title":"Public Attributes","text":"Type Name     struct wifi_event_sta_wps_er_success_t::@0 ap_cred    uint8_t ap_cred_cnt    uint8_t passphrase    uint8_t ssid"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for WIFI_EVENT_STA_WPS_ER_SUCCESS event </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-ap_cred","title":"variable ap_cred","text":"<pre><code>struct wifi_event_sta_wps_er_success_t::@0 wifi_event_sta_wps_er_success_t::ap_cred[MAX_WPS_AP_CRED];\n</code></pre> <p>All AP credentials received from WPS handshake </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-ap_cred_cnt","title":"variable ap_cred_cnt","text":"<pre><code>uint8_t wifi_event_sta_wps_er_success_t::ap_cred_cnt;\n</code></pre> <p>Number of AP credentials received </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-passphrase","title":"variable passphrase","text":"<pre><code>uint8_t wifi_event_sta_wps_er_success_t::passphrase[MAX_PASSPHRASE_LEN];\n</code></pre> <p>Passphrase for the AP </p>"},{"location":"ltapi/structwifi__event__sta__wps__er__success__t/#variable-ssid","title":"variable ssid","text":"<pre><code>uint8_t wifi_event_sta_wps_er_success_t::ssid[MAX_SSID_LEN];\n</code></pre> <p>SSID of AP </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/","title":"Struct wifi_ftm_report_entry_t","text":"<p>ClassList &gt; wifi_ftm_report_entry_t</p> <p>More...</p> <ul> <li><code>#include &lt;WiFiEvents.h&gt;</code></li> </ul>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#public-attributes","title":"Public Attributes","text":"Type Name     uint8_t dlog_token    int8_t rssi    uint32_t rtt    uint64_t t1    uint64_t t2    uint64_t t3    uint64_t t4"},{"location":"ltapi/structwifi__ftm__report__entry__t/#detailed-description","title":"Detailed Description","text":"<p>Argument structure for </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-dlog_token","title":"variable dlog_token","text":"<pre><code>uint8_t wifi_ftm_report_entry_t::dlog_token;\n</code></pre> <p>Dialog Token of the FTM frame </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-rssi","title":"variable rssi","text":"<pre><code>int8_t wifi_ftm_report_entry_t::rssi;\n</code></pre> <p>RSSI of the FTM frame received </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-rtt","title":"variable rtt","text":"<pre><code>uint32_t wifi_ftm_report_entry_t::rtt;\n</code></pre> <p>Round Trip Time in pSec with a peer </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t1","title":"variable t1","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t1;\n</code></pre> <p>Time of departure of FTM frame from FTM Responder in pSec </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t2","title":"variable t2","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t2;\n</code></pre> <p>Time of arrival of FTM frame at FTM Initiator in pSec </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t3","title":"variable t3","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t3;\n</code></pre> <p>Time of departure of ACK from FTM Initiator in pSec </p>"},{"location":"ltapi/structwifi__ftm__report__entry__t/#variable-t4","title":"variable t4","text":"<pre><code>uint64_t wifi_ftm_report_entry_t::t4;\n</code></pre> <p>Time of arrival of ACK at FTM Responder in pSec </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/dir_7957e4d193d4a425fd39fd4994c5caf1/","title":"Dir arduino","text":"<p>FileList &gt; arduino</p>"},{"location":"ltapi/dir_7957e4d193d4a425fd39fd4994c5caf1/#directories","title":"Directories","text":"Type Name     dir libretuya      <p>The documentation for this class was generated from the following file <code>arduino/</code></p>"},{"location":"ltapi/dir_035288a59a5e2ae5a9321e93b53ea147/","title":"Dir arduino/libretuya","text":"<p>FileList &gt; arduino &gt; libretuya</p>"},{"location":"ltapi/dir_035288a59a5e2ae5a9321e93b53ea147/#directories","title":"Directories","text":"Type Name     dir api    dir common    dir compat    dir core    dir libraries    dir port    dir posix      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/</code></p>"},{"location":"ltapi/dir_549250a93dd29f15573c6c8e6f93a413/","title":"Dir arduino/libretuya/api","text":"<p>FileList &gt; api</p>"},{"location":"ltapi/dir_549250a93dd29f15573c6c8e6f93a413/#files","title":"Files","text":"Type Name     file Events.cpp    file Events.h    file FS.cpp    file FS.h    file Preferences.h    file SoftwareSerial.cpp    file SoftwareSerial.h    file WiFiClient.h    file WiFiClientSecure.h    file WiFiServer.h    file WiFiUdp.h    file Wire.h"},{"location":"ltapi/dir_549250a93dd29f15573c6c8e6f93a413/#directories","title":"Directories","text":"Type Name     dir WiFi      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/</code></p>"},{"location":"ltapi/_events_8cpp/","title":"File Events.cpp","text":"<p>FileList &gt; api &gt; Events.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Events.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Events.cpp</code></p>"},{"location":"ltapi/_events_8cpp_source/","title":"File Events.cpp","text":"<p>File List &gt; api &gt; Events.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-17. */\n\n#include \"Events.h\"\n\nuint16_t EventHandler_s::lastId = 1;\n</code></pre>"},{"location":"ltapi/_events_8h/","title":"File Events.h","text":"<p>FileList &gt; api &gt; Events.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/WiFi/WiFiEvents.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"ltapi/_events_8h/#classes","title":"Classes","text":"Type Name     struct EventHandler_s    struct arduino_event_t"},{"location":"ltapi/_events_8h/#public-types","title":"Public Types","text":"Type Name     typedef void(* EventCb    typedef std::function&lt; void(EventId event, EventInfo info)&gt; EventFuncCb    typedef struct EventHandler_s EventHandler    typedef void(* EventSysCb    enum arduino_event_id_t    union arduino_event_info_t"},{"location":"ltapi/_events_8h/#macros","title":"Macros","text":"Type Name     define EventId  arduino_event_id_t   define EventId_t  arduino_event_id_t   define EventInfo arduino_event_info_t   define EventInfo_t arduino_event_info_t   define Event_t arduino_event_t"},{"location":"ltapi/_events_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_events_8h/#typedef-eventcb","title":"typedef EventCb","text":"<pre><code>typedef void(* EventCb) (EventId event);\n</code></pre>"},{"location":"ltapi/_events_8h/#typedef-eventfunccb","title":"typedef EventFuncCb","text":"<pre><code>typedef std::function&lt;void(EventId event, EventInfo info)&gt; EventFuncCb;\n</code></pre>"},{"location":"ltapi/_events_8h/#typedef-eventhandler","title":"typedef EventHandler","text":"<pre><code>typedef struct EventHandler_s EventHandler;\n</code></pre>"},{"location":"ltapi/_events_8h/#typedef-eventsyscb","title":"typedef EventSysCb","text":"<pre><code>typedef void(* EventSysCb) (Event_t *event);\n</code></pre>"},{"location":"ltapi/_events_8h/#enum-arduino_event_id_t","title":"enum arduino_event_id_t","text":"<pre><code>enum arduino_event_id_t {\n    ARDUINO_EVENT_WIFI_READY = 0,\n    ARDUINO_EVENT_WIFI_SCAN_DONE,\n    ARDUINO_EVENT_WIFI_STA_START,\n    ARDUINO_EVENT_WIFI_STA_STOP,\n    ARDUINO_EVENT_WIFI_STA_CONNECTED,\n    ARDUINO_EVENT_WIFI_STA_DISCONNECTED,\n    ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP6,\n    ARDUINO_EVENT_WIFI_STA_LOST_IP,\n    ARDUINO_EVENT_WIFI_AP_START,\n    ARDUINO_EVENT_WIFI_AP_STOP,\n    ARDUINO_EVENT_WIFI_AP_STACONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STADISCONNECTED,\n    ARDUINO_EVENT_WIFI_AP_STAIPASSIGNED,\n    ARDUINO_EVENT_WIFI_AP_PROBEREQRECVED,\n    ARDUINO_EVENT_WIFI_AP_GOT_IP6,\n    ARDUINO_EVENT_WIFI_FTM_REPORT,\n    ARDUINO_EVENT_ETH_START,\n    ARDUINO_EVENT_ETH_STOP,\n    ARDUINO_EVENT_ETH_CONNECTED,\n    ARDUINO_EVENT_ETH_DISCONNECTED,\n    ARDUINO_EVENT_ETH_GOT_IP,\n    ARDUINO_EVENT_ETH_GOT_IP6,\n    ARDUINO_EVENT_WPS_ER_SUCCESS,\n    ARDUINO_EVENT_WPS_ER_FAILED,\n    ARDUINO_EVENT_WPS_ER_TIMEOUT,\n    ARDUINO_EVENT_WPS_ER_PIN,\n    ARDUINO_EVENT_WPS_ER_PBC_OVERLAP,\n    ARDUINO_EVENT_SC_SCAN_DONE,\n    ARDUINO_EVENT_SC_FOUND_CHANNEL,\n    ARDUINO_EVENT_SC_GOT_SSID_PSWD,\n    ARDUINO_EVENT_SC_SEND_ACK_DONE,\n    ARDUINO_EVENT_PROV_INIT,\n    ARDUINO_EVENT_PROV_DEINIT,\n    ARDUINO_EVENT_PROV_START,\n    ARDUINO_EVENT_PROV_END,\n    ARDUINO_EVENT_PROV_CRED_RECV,\n    ARDUINO_EVENT_PROV_CRED_FAIL,\n    ARDUINO_EVENT_PROV_CRED_SUCCESS,\n    ARDUINO_EVENT_MAX\n};\n</code></pre>"},{"location":"ltapi/_events_8h/#union-arduino_event_info_t","title":"union arduino_event_info_t","text":""},{"location":"ltapi/_events_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_events_8h/#define-eventid","title":"define EventId","text":"<pre><code>#define EventId arduino_event_id_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-eventid_t","title":"define EventId_t","text":"<pre><code>#define EventId_t arduino_event_id_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-eventinfo","title":"define EventInfo","text":"<pre><code>#define EventInfo arduino_event_info_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-eventinfo_t","title":"define EventInfo_t","text":"<pre><code>#define EventInfo_t arduino_event_info_t\n</code></pre>"},{"location":"ltapi/_events_8h/#define-event_t","title":"define Event_t","text":"<pre><code>#define Event_t arduino_event_t\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Events.h</code></p>"},{"location":"ltapi/_events_8h_source/","title":"File Events.h","text":"<p>File List &gt; api &gt; Events.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n ESP8266WiFiGeneric.h - esp8266 Wifi support.\n Based on WiFi.h from Ardiono WiFi shield library.\n Copyright (c) 2011-2014 Arduino.  All right reserved.\n Modified by Ivan Grokhotkov, December 2014\n Reworked by Markus Sattler, December 2015\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/WiFi/WiFiEvents.h&gt;\n#include &lt;functional&gt;\n\ntypedef enum {\n    ARDUINO_EVENT_WIFI_READY = 0,           \n    ARDUINO_EVENT_WIFI_SCAN_DONE,           \n    ARDUINO_EVENT_WIFI_STA_START,           \n    ARDUINO_EVENT_WIFI_STA_STOP,            \n    ARDUINO_EVENT_WIFI_STA_CONNECTED,       \n    ARDUINO_EVENT_WIFI_STA_DISCONNECTED,    \n    ARDUINO_EVENT_WIFI_STA_AUTHMODE_CHANGE, \n    ARDUINO_EVENT_WIFI_STA_GOT_IP,\n    ARDUINO_EVENT_WIFI_STA_GOT_IP6,\n    ARDUINO_EVENT_WIFI_STA_LOST_IP,\n    ARDUINO_EVENT_WIFI_AP_START,           \n    ARDUINO_EVENT_WIFI_AP_STOP,            \n    ARDUINO_EVENT_WIFI_AP_STACONNECTED,    \n    ARDUINO_EVENT_WIFI_AP_STADISCONNECTED, \n    ARDUINO_EVENT_WIFI_AP_STAIPASSIGNED,\n    ARDUINO_EVENT_WIFI_AP_PROBEREQRECVED, \n    ARDUINO_EVENT_WIFI_AP_GOT_IP6,\n    ARDUINO_EVENT_WIFI_FTM_REPORT, \n    ARDUINO_EVENT_ETH_START,\n    ARDUINO_EVENT_ETH_STOP,\n    ARDUINO_EVENT_ETH_CONNECTED,\n    ARDUINO_EVENT_ETH_DISCONNECTED,\n    ARDUINO_EVENT_ETH_GOT_IP,\n    ARDUINO_EVENT_ETH_GOT_IP6,\n    ARDUINO_EVENT_WPS_ER_SUCCESS,     \n    ARDUINO_EVENT_WPS_ER_FAILED,      \n    ARDUINO_EVENT_WPS_ER_TIMEOUT,     \n    ARDUINO_EVENT_WPS_ER_PIN,         \n    ARDUINO_EVENT_WPS_ER_PBC_OVERLAP, \n    ARDUINO_EVENT_SC_SCAN_DONE,\n    ARDUINO_EVENT_SC_FOUND_CHANNEL,\n    ARDUINO_EVENT_SC_GOT_SSID_PSWD,\n    ARDUINO_EVENT_SC_SEND_ACK_DONE,\n    ARDUINO_EVENT_PROV_INIT,\n    ARDUINO_EVENT_PROV_DEINIT,\n    ARDUINO_EVENT_PROV_START,\n    ARDUINO_EVENT_PROV_END,\n    ARDUINO_EVENT_PROV_CRED_RECV,\n    ARDUINO_EVENT_PROV_CRED_FAIL,\n    ARDUINO_EVENT_PROV_CRED_SUCCESS,\n    ARDUINO_EVENT_MAX\n} arduino_event_id_t;\n\ntypedef union {\n    wifi_event_sta_scan_done_t wifi_scan_done;\n    wifi_event_sta_authmode_change_t wifi_sta_authmode_change;\n    wifi_event_sta_connected_t wifi_sta_connected;\n    wifi_event_sta_disconnected_t wifi_sta_disconnected;\n    wifi_event_sta_wps_er_pin_t wps_er_pin;\n    wifi_event_sta_wps_fail_reason_t wps_fail_reason;\n    wifi_event_ap_probe_req_rx_t wifi_ap_probereqrecved;\n    wifi_event_ap_staconnected_t wifi_ap_staconnected;\n    wifi_event_ap_stadisconnected_t wifi_ap_stadisconnected;\n    wifi_event_ftm_report_t wifi_ftm_report;\n    ip_event_ap_staipassigned_t wifi_ap_staipassigned;\n    ip_event_got_ip_t got_ip;\n    ip_event_got_ip6_t got_ip6;\n    // smartconfig_event_got_ssid_pswd_t sc_got_ssid_pswd;\n    // esp_eth_handle_t eth_connected;\n    // wifi_sta_config_t prov_cred_recv;\n    // wifi_prov_sta_fail_reason_t prov_fail_reason;\n} arduino_event_info_t;\n\ntypedef struct {\n    arduino_event_id_t event_id;\n    arduino_event_info_t event_info;\n} arduino_event_t;\n\n#define EventId     arduino_event_id_t\n#define EventId_t   arduino_event_id_t\n#define EventInfo   arduino_event_info_t\n#define EventInfo_t arduino_event_info_t\n#define Event_t     arduino_event_t\n\ntypedef void (*EventCb)(EventId event);\ntypedef std::function&lt;void(EventId event, EventInfo info)&gt; EventFuncCb;\ntypedef void (*EventSysCb)(Event_t *event);\n\ntypedef struct EventHandler_s {\n    static uint16_t lastId;\n    uint16_t id;\n    EventCb cb;\n    EventFuncCb fcb;\n    EventSysCb scb;\n    EventId eventId;\n\n    EventHandler_s() : id(lastId++), cb(NULL), fcb(NULL), scb(NULL) {}\n} EventHandler;\n</code></pre>"},{"location":"ltapi/_f_s_8cpp/","title":"File FS.cpp","text":"<p>FileList &gt; api &gt; FS.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"FS.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.cpp</code></p>"},{"location":"ltapi/_f_s_8cpp_source/","title":"File FS.cpp","text":"<p>File List &gt; api &gt; FS.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n FS.cpp - file system wrapper\n Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"FS.h\"\n\nusing namespace fs;\n\nsize_t File::write(uint8_t c) {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;write(&amp;c, 1);\n}\n\ntime_t File::getLastWrite() {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;getLastWrite();\n}\n\nsize_t File::write(const uint8_t *buf, size_t size) {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;write(buf, size);\n}\n\nint File::available() {\n    if (!*this) {\n        return false;\n    }\n    return _p-&gt;size() - _p-&gt;position();\n}\n\nint File::read() {\n    if (!*this) {\n        return -1;\n    }\n    uint8_t result;\n    if (_p-&gt;read(&amp;result, 1) != 1) {\n        return -1;\n    }\n    return result;\n}\n\nsize_t File::read(uint8_t *buf, size_t size) {\n    if (!*this) {\n        return -1;\n    }\n    return _p-&gt;read(buf, size);\n}\n\nint File::peek() {\n    if (!*this) {\n        return -1;\n    }\n    size_t curPos = _p-&gt;position();\n    int result    = read();\n    seek(curPos, SeekSet);\n    return result;\n}\n\nvoid File::flush() {\n    if (!*this) {\n        return;\n    }\n    _p-&gt;flush();\n}\n\nbool File::seek(uint32_t pos, SeekMode mode) {\n    if (!*this) {\n        return false;\n    }\n    return _p-&gt;seek(pos, mode);\n}\n\nsize_t File::position() const {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;position();\n}\n\nsize_t File::size() const {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;size();\n}\n\nbool File::setBufferSize(size_t size) {\n    if (!*this) {\n        return 0;\n    }\n    return _p-&gt;setBufferSize(size);\n}\n\nvoid File::close() {\n    if (_p) {\n        _p-&gt;close();\n        _p = nullptr;\n    }\n}\n\nFile::operator bool() const {\n    return _p != nullptr &amp;&amp; *_p != false;\n}\n\nconst char *File::path() const {\n    if (!*this) {\n        return nullptr;\n    }\n    return _p-&gt;path();\n}\n\nconst char *File::name() const {\n    if (!*this) {\n        return nullptr;\n    }\n    return _p-&gt;name();\n}\n\n// to implement\nboolean File::isDirectory(void) {\n    if (!*this) {\n        return false;\n    }\n    return _p-&gt;isDirectory();\n}\n\nFile File::openNextFile(const char *mode) {\n    if (!*this) {\n        return File();\n    }\n    return _p-&gt;openNextFile(mode);\n}\n\nvoid File::rewindDirectory(void) {\n    if (!*this) {\n        return;\n    }\n    _p-&gt;rewindDirectory();\n}\n\nFile FS::open(const String &amp;path, const char *mode, const bool create) {\n    return open(path.c_str(), mode, create);\n}\n\nFile FS::open(const char *path, const char *mode, const bool create) {\n    if (!_impl) {\n        return File();\n    }\n\n    return File(_impl-&gt;open(path, mode, create));\n}\n\nbool FS::exists(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;exists(path);\n}\n\nbool FS::exists(const String &amp;path) {\n    return exists(path.c_str());\n}\n\nbool FS::remove(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;remove(path);\n}\n\nbool FS::remove(const String &amp;path) {\n    return remove(path.c_str());\n}\n\nbool FS::rename(const char *pathFrom, const char *pathTo) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;rename(pathFrom, pathTo);\n}\n\nbool FS::rename(const String &amp;pathFrom, const String &amp;pathTo) {\n    return rename(pathFrom.c_str(), pathTo.c_str());\n}\n\nbool FS::mkdir(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;mkdir(path);\n}\n\nbool FS::mkdir(const String &amp;path) {\n    return mkdir(path.c_str());\n}\n\nbool FS::rmdir(const char *path) {\n    if (!_impl) {\n        return false;\n    }\n    return _impl-&gt;rmdir(path);\n}\n\nbool FS::rmdir(const String &amp;path) {\n    return rmdir(path.c_str());\n}\n</code></pre>"},{"location":"ltapi/api_2_f_s_8h/","title":"File FS.h","text":"<p>FileList &gt; api &gt; FS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"ltapi/api_2_f_s_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace fs"},{"location":"ltapi/api_2_f_s_8h/#classes","title":"Classes","text":"Type Name     class FS    class FSImpl    class File    class FileImpl"},{"location":"ltapi/api_2_f_s_8h/#macros","title":"Macros","text":"Type Name     define FILE_APPEND  \"a\"   define FILE_READ  \"r\"   define FILE_WRITE  \"w\""},{"location":"ltapi/api_2_f_s_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/api_2_f_s_8h/#define-file_append","title":"define FILE_APPEND","text":"<pre><code>#define FILE_APPEND \"a\"\n</code></pre>"},{"location":"ltapi/api_2_f_s_8h/#define-file_read","title":"define FILE_READ","text":"<pre><code>#define FILE_READ \"r\"\n</code></pre>"},{"location":"ltapi/api_2_f_s_8h/#define-file_write","title":"define FILE_WRITE","text":"<pre><code>#define FILE_WRITE \"w\"\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/FS.h</code></p>"},{"location":"ltapi/api_2_f_s_8h_source/","title":"File FS.h","text":"<p>File List &gt; api &gt; FS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n FS.h - file system wrapper\n Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;memory&gt;\n\nnamespace fs {\n\n#define FILE_READ   \"r\"\n#define FILE_WRITE  \"w\"\n#define FILE_APPEND \"a\"\n\nclass File;\n\nclass FileImpl;\ntypedef std::shared_ptr&lt;FileImpl&gt; FileImplPtr;\nclass FSImpl;\ntypedef std::shared_ptr&lt;FSImpl&gt; FSImplPtr;\n\nenum SeekMode { SeekSet = 0, SeekCur = 1, SeekEnd = 2 };\n\nclass File : public Stream {\n  public:\n    File(FileImplPtr p = FileImplPtr()) : _p(p) {\n        _timeout = 0;\n    }\n\n    size_t write(uint8_t) override;\n    size_t write(const uint8_t *buf, size_t size) override;\n    int available() override;\n    int read() override;\n    int peek() override;\n    void flush() override;\n    size_t read(uint8_t *buf, size_t size);\n\n    size_t readBytes(char *buffer, size_t length) {\n        return read((uint8_t *)buffer, length);\n    }\n\n    bool seek(uint32_t pos, SeekMode mode);\n\n    bool seek(uint32_t pos) {\n        return seek(pos, SeekSet);\n    }\n\n    size_t position() const;\n    size_t size() const;\n    bool setBufferSize(size_t size);\n    void close();\n    operator bool() const;\n    time_t getLastWrite();\n    const char *path() const;\n    const char *name() const;\n\n    boolean isDirectory(void);\n    File openNextFile(const char *mode = FILE_READ);\n    void rewindDirectory(void);\n\n  protected:\n    FileImplPtr _p;\n};\n\nclass FileImpl {\n  public:\n    virtual ~FileImpl() {}\n\n    virtual size_t write(const uint8_t *buf, size_t size) = 0;\n    virtual size_t read(uint8_t *buf, size_t size)        = 0;\n    virtual void flush()                                  = 0;\n    virtual bool seek(uint32_t pos, SeekMode mode)        = 0;\n    virtual size_t position() const                       = 0;\n    virtual size_t size() const                           = 0;\n    virtual bool setBufferSize(size_t size)               = 0;\n    virtual void close()                                  = 0;\n    virtual time_t getLastWrite()                         = 0;\n    virtual const char *path() const                      = 0;\n    virtual const char *name() const                      = 0;\n    virtual boolean isDirectory(void)                     = 0;\n    virtual FileImplPtr openNextFile(const char *mode)    = 0;\n    virtual void rewindDirectory(void)                    = 0;\n    virtual operator bool()                               = 0;\n};\n\nclass FS {\n  public:\n    FS(FSImplPtr impl) : _impl(impl) {}\n\n    File open(const char *path, const char *mode = FILE_READ, const bool create = false);\n    File open(const String &amp;path, const char *mode = FILE_READ, const bool create = false);\n\n    bool exists(const char *path);\n    bool exists(const String &amp;path);\n\n    bool remove(const char *path);\n    bool remove(const String &amp;path);\n\n    bool rename(const char *pathFrom, const char *pathTo);\n    bool rename(const String &amp;pathFrom, const String &amp;pathTo);\n\n    bool mkdir(const char *path);\n    bool mkdir(const String &amp;path);\n\n    bool rmdir(const char *path);\n    bool rmdir(const String &amp;path);\n\n  protected:\n    FSImplPtr _impl;\n};\n\nclass FSImpl {\n  public:\n    FSImpl() {}\n\n    virtual ~FSImpl() {}\n\n    virtual FileImplPtr open(const char *path, const char *mode, const bool create) = 0;\n    virtual bool exists(const char *path)                                           = 0;\n    virtual bool rename(const char *pathFrom, const char *pathTo)                   = 0;\n    virtual bool remove(const char *path)                                           = 0;\n    virtual bool mkdir(const char *path)                                            = 0;\n    virtual bool rmdir(const char *path)                                            = 0;\n};\n\n} // namespace fs\n\n#ifndef FS_NO_GLOBALS\nusing fs::File;\nusing fs::FS;\nusing fs::SeekCur;\nusing fs::SeekEnd;\nusing fs::SeekMode;\nusing fs::SeekSet;\n#endif // FS_NO_GLOBALS\n</code></pre>"},{"location":"ltapi/_preferences_8h/","title":"File Preferences.h","text":"<p>FileList &gt; api &gt; Preferences.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;api/String.h&gt;</code></li> </ul>"},{"location":"ltapi/_preferences_8h/#classes","title":"Classes","text":"Type Name     class IPreferences"},{"location":"ltapi/_preferences_8h/#public-types","title":"Public Types","text":"Type Name     enum PreferenceType"},{"location":"ltapi/_preferences_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_preferences_8h/#enum-preferencetype","title":"enum PreferenceType","text":"<pre><code>enum PreferenceType {\n    PT_I8,\n    PT_U8,\n    PT_I16,\n    PT_U16,\n    PT_I32,\n    PT_U32,\n    PT_I64,\n    PT_U64,\n    PT_STR,\n    PT_BLOB,\n    PT_INVALID\n};\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Preferences.h</code></p>"},{"location":"ltapi/_preferences_8h_source/","title":"File Preferences.h","text":"<p>File List &gt; api &gt; Preferences.h</p> <p>Go to the documentation of this file. </p> <pre><code>// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;stdbool.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdlib.h&gt;\n\n#include &lt;api/String.h&gt;\n\ntypedef enum {\n    PT_I8,\n    PT_U8,\n    PT_I16,\n    PT_U16,\n    PT_I32,\n    PT_U32,\n    PT_I64,\n    PT_U64,\n    PT_STR,\n    PT_BLOB,\n    PT_INVALID,\n} PreferenceType;\n\nclass IPreferences {\n  public:\n    IPreferences() {}\n\n    ~IPreferences() {}\n\n    bool begin(const char *name, bool readOnly = false, const char *partition_label = NULL);\n    void end();\n\n    bool clear();\n    bool remove(const char *key);\n\n    size_t putChar(const char *key, int8_t value);\n    size_t putUChar(const char *key, uint8_t value);\n    size_t putShort(const char *key, int16_t value);\n    size_t putUShort(const char *key, uint16_t value);\n    size_t putInt(const char *key, int32_t value);\n    size_t putUInt(const char *key, uint32_t value);\n    size_t putLong(const char *key, int32_t value);\n    size_t putULong(const char *key, uint32_t value);\n    size_t putLong64(const char *key, int64_t value);\n    size_t putULong64(const char *key, uint64_t value);\n    size_t putFloat(const char *key, float_t value);\n    size_t putDouble(const char *key, double_t value);\n    size_t putBool(const char *key, bool value);\n    size_t putString(const char *key, const char *value);\n    size_t putString(const char *key, String value);\n    size_t putBytes(const char *key, const void *value, size_t len);\n\n    bool isKey(const char *key);\n    PreferenceType getType(const char *key);\n    int8_t getChar(const char *key, int8_t defaultValue = 0);\n    uint8_t getUChar(const char *key, uint8_t defaultValue = 0);\n    int16_t getShort(const char *key, int16_t defaultValue = 0);\n    uint16_t getUShort(const char *key, uint16_t defaultValue = 0);\n    int32_t getInt(const char *key, int32_t defaultValue = 0);\n    uint32_t getUInt(const char *key, uint32_t defaultValue = 0);\n    int32_t getLong(const char *key, int32_t defaultValue = 0);\n    uint32_t getULong(const char *key, uint32_t defaultValue = 0);\n    int64_t getLong64(const char *key, int64_t defaultValue = 0);\n    uint64_t getULong64(const char *key, uint64_t defaultValue = 0);\n    float_t getFloat(const char *key, float_t defaultValue = NAN);\n    double_t getDouble(const char *key, double_t defaultValue = NAN);\n    bool getBool(const char *key, bool defaultValue = false);\n    size_t getString(const char *key, char *value, size_t maxLen);\n    String getString(const char *key, String defaultValue = String());\n    size_t getBytesLength(const char *key);\n    size_t getBytes(const char *key, void *buf, size_t maxLen);\n    size_t freeEntries();\n};\n</code></pre>"},{"location":"ltapi/_software_serial_8cpp/","title":"File SoftwareSerial.cpp","text":"<p>FileList &gt; api &gt; SoftwareSerial.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"SoftwareSerial.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/SoftwareSerial.cpp</code></p>"},{"location":"ltapi/_software_serial_8cpp_source/","title":"File SoftwareSerial.cpp","text":"<p>File List &gt; api &gt; SoftwareSerial.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-03. */\n\n#include \"SoftwareSerial.h\"\n\n#ifdef LT_ARD_HAS_SOFTSERIAL\n\nSoftwareSerial::SoftwareSerial(pin_size_t receivePin, pin_size_t transmitPin, bool inverted) {\n    data.rx.buf = NULL;\n    data.tx.buf = NULL;\n    data.rx.pin = receivePin;\n    data.tx.pin = transmitPin;\n    data.invert = inverted == true;\n}\n\nint SoftwareSerial::available() {\n    return data.rx.buf-&gt;available();\n}\n\nint SoftwareSerial::peek() {\n    return data.rx.buf-&gt;peek();\n}\n\nint SoftwareSerial::read() {\n    return data.rx.buf-&gt;read_char();\n}\n\nvoid SoftwareSerial::flush() {\n    while (data.rx.buf-&gt;available()) {\n        yield();\n    }\n}\n\nsize_t SoftwareSerial::write(uint8_t c) {\n    while (data.tx.buf-&gt;isFull()) {\n        yield();\n    }\n    data.tx.buf-&gt;store_char(c);\n    if (data.tx.state == SS_IDLE) {\n        data.tx.state = SS_START;\n        this-&gt;startTx();\n    }\n    return 1;\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_software_serial_8h/","title":"File SoftwareSerial.h","text":"<p>FileList &gt; api &gt; SoftwareSerial.h</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/SoftwareSerial.h</code></p>"},{"location":"ltapi/_software_serial_8h_source/","title":"File SoftwareSerial.h","text":"<p>File List &gt; api &gt; SoftwareSerial.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-03. */\n\n#pragma once\n\n#ifdef LT_ARD_HAS_SOFTSERIAL\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/HardwareSerial.h&gt;\n#include &lt;api/RingBuffer.h&gt;\n\nusing namespace arduino;\n\ntypedef enum {\n    SS_IDLE = 0,\n    SS_START,\n    SS_DATA0,\n    SS_DATA1,\n    SS_DATA2,\n    SS_DATA3,\n    SS_DATA4,\n    SS_DATA5,\n    SS_DATA6,\n    SS_DATA7,\n    SS_STOP,\n    SS_END,\n} SoftState;\n\ntypedef struct {\n    SoftState state;\n    RingBuffer *buf;\n    uint8_t byte;\n    pin_size_t pin;\n    void *param;\n} SoftData;\n\ntypedef struct {\n    SoftData rx;\n    SoftData tx;\n    uint8_t invert;\n    void *param;\n} SoftSerial;\n\nclass SoftwareSerial : public HardwareSerial {\n  private:\n    SoftSerial data;\n    void *param;\n\n  public:\n    SoftwareSerial(pin_size_t receivePin, pin_size_t transmitPin, bool inverted = false);\n\n    inline void begin(unsigned long baudrate) {\n        begin(baudrate, SERIAL_8N1);\n    }\n\n    int available();\n    int peek();\n    int read();\n    void flush();\n    size_t write(uint8_t c);\n\n    operator bool() {\n        return data.rx.buf || data.tx.buf;\n    }\n\n  public: // Family needs to implement these methods only\n    void begin(unsigned long baudrate, uint16_t config);\n    void end();\n\n  private:\n    void startTx();\n    void endTx();\n\n    using Print::write;\n};\n\n#endif\n</code></pre>"},{"location":"ltapi/_wi_fi_client_8h/","title":"File WiFiClient.h","text":"<p>FileList &gt; api &gt; WiFiClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Client.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_client_8h/#classes","title":"Classes","text":"Type Name     class IWiFiClient      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiClient.h</code></p>"},{"location":"ltapi/_wi_fi_client_8h_source/","title":"File WiFiClient.h","text":"<p>File List &gt; api &gt; WiFiClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Client.h - Base class that provides Client\n  Copyright (c) 2011 Adrian McEwen.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Client.h&gt;\n\nclass IWiFiClient : public Client {\n  public:\n    IWiFiClient() {}\n\n    IWiFiClient(int sock) {}\n\n    ~IWiFiClient() {}\n\n    virtual int connect(IPAddress ip, uint16_t port, int32_t timeout)     = 0;\n    virtual int connect(const char *host, uint16_t port, int32_t timeout) = 0;\n\n    virtual size_t write(Stream &amp;stream) = 0;\n\n    size_t write_P(PGM_P buffer, size_t size) {\n        return write((const uint8_t *)buffer, size);\n    }\n\n    virtual int fd() const                   = 0;\n    virtual int socket()                     = 0;\n    virtual int setTimeout(uint32_t seconds) = 0;\n\n    bool operator==(const IWiFiClient &amp;other) const;\n\n    operator bool() {\n        return connected();\n    }\n\n    virtual bool operator==(const bool value) {\n        return bool() == value;\n    }\n\n    virtual bool operator!=(const bool value) {\n        return bool() != value;\n    }\n\n    virtual bool operator!=(const IWiFiClient &amp;other) {\n        return !this-&gt;operator==(other);\n    };\n\n    virtual IPAddress remoteIP() const          = 0;\n    virtual IPAddress remoteIP(int sock) const  = 0;\n    virtual uint16_t remotePort() const         = 0;\n    virtual uint16_t remotePort(int sock) const = 0;\n    virtual IPAddress localIP() const           = 0;\n    virtual IPAddress localIP(int sock) const   = 0;\n    virtual uint16_t localPort() const          = 0;\n    virtual uint16_t localPort(int sock) const  = 0;\n\n    using Print::write;\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_client_secure_8h/","title":"File WiFiClientSecure.h","text":"<p>FileList &gt; api &gt; WiFiClientSecure.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include \"WiFiClient.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_client_secure_8h/#classes","title":"Classes","text":"Type Name     class IWiFiClientSecure      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiClientSecure.h</code></p>"},{"location":"ltapi/_wi_fi_client_secure_8h_source/","title":"File WiFiClientSecure.h","text":"<p>File List &gt; api &gt; WiFiClientSecure.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  WiFiClientSecure.h - Base class that provides Client SSL to ESP32\n  Copyright (c) 2011 Adrian McEwen.  All right reserved.\n  Additions Copyright (C) 2017 Evandro Luis Copercini.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#include \"WiFiClient.h\"\n\nclass IWiFiClientSecure {\n  public:\n    virtual int\n    connect(IPAddress ip, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey) = 0;\n    virtual int\n    connect(const char *host, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey) = 0;\n    virtual int connect(IPAddress ip, uint16_t port, const char *pskIdent, const char *psk)                        = 0;\n    virtual int connect(const char *host, uint16_t port, const char *pskIdent, const char *psk)                    = 0;\n\n    virtual int lastError(char *buf, const size_t size) = 0;\n    virtual void setInsecure() = 0; // Don't validate the chain, just accept whatever is given. VERY INSECURE!\n    virtual void setPreSharedKey(const char *pskIdent, const char *psk)  = 0; // psk in hex\n    virtual void setCACert(const char *rootCA)                           = 0;\n    virtual void setCertificate(const char *clientCA)                    = 0;\n    virtual void setPrivateKey(const char *privateKey)                   = 0;\n    virtual bool loadCACert(Stream &amp;stream, size_t size)                 = 0;\n    virtual bool loadCertificate(Stream &amp;stream, size_t size)            = 0;\n    virtual bool loadPrivateKey(Stream &amp;stream, size_t size)             = 0;\n    virtual bool verify(const char *fingerprint, const char *domainName) = 0;\n    virtual void setHandshakeTimeout(unsigned long handshakeTimeout)     = 0;\n    virtual void setAlpnProtocols(const char **alpnProtocols)            = 0;\n    virtual bool getFingerprintSHA256(uint8_t result[32])                = 0;\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_server_8h/","title":"File WiFiServer.h","text":"<p>FileList &gt; api &gt; WiFiServer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Print.h&gt;</code></li> <li><code>#include \"WiFiClient.h\"</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_server_8h/#classes","title":"Classes","text":"Type Name     class IWiFiServer &lt;typename TWiFiClient, typename&gt;     <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiServer.h</code></p>"},{"location":"ltapi/_wi_fi_server_8h_source/","title":"File WiFiServer.h","text":"<p>File List &gt; api &gt; WiFiServer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Server.h - Server class for Raspberry Pi\n  Copyright (c) 2016 Hristo Gochkov  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Print.h&gt;\n\n#include \"WiFiClient.h\"\n\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename TWiFiClient, typename = std::enable_if&lt;std::is_base_of&lt;IWiFiClient, TWiFiClient&gt;::value&gt;&gt;\n\nclass IWiFiServer : public Print { // arduino::Server is useless anyway\n  public:\n    void listenOnLocalhost() {}\n\n    IWiFiServer(uint16_t port = 80, uint8_t maxClients = 4) {}\n\n    IWiFiServer(const IPAddress &amp;addr, uint16_t port = 80, uint8_t maxClients = 4) {}\n\n    ~IWiFiServer() {\n        stop();\n    }\n\n    TWiFiClient available() {\n        return accept();\n    };\n\n    virtual operator bool() = 0;\n\n    virtual bool begin(uint16_t port = 0, bool reuseAddr = true) = 0;\n    virtual void end()                                           = 0;\n    virtual TWiFiClient accept()                                 = 0;\n\n    void close() {\n        end();\n    }\n\n    void stop() {\n        end();\n    }\n\n    virtual int setTimeout(uint32_t seconds) = 0;\n    virtual void stopAll()                   = 0;\n    virtual void setNoDelay(bool noDelay)    = 0;\n    virtual bool getNoDelay()                = 0;\n    virtual bool hasClient()                 = 0;\n\n    size_t write(uint8_t data) {\n        return write(&amp;data, 1);\n    }\n\n    using Print::write;\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_udp_8h/","title":"File WiFiUdp.h","text":"<p>FileList &gt; api &gt; WiFiUdp.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Udp.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_udp_8h/#classes","title":"Classes","text":"Type Name     class IWiFiUDP      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFiUdp.h</code></p>"},{"location":"ltapi/_wi_fi_udp_8h_source/","title":"File WiFiUdp.h","text":"<p>File List &gt; api &gt; WiFiUdp.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Udp.h&gt;\n\nclass IWiFiUDP : public UDP {\n  public:\n    IWiFiUDP() {}\n\n    ~IWiFiUDP() {}\n\n    virtual uint8_t begin(IPAddress ip, uint16_t port)          = 0;\n    virtual uint8_t begin(uint16_t port)                        = 0;\n    virtual uint8_t beginMulticast(IPAddress ip, uint16_t port) = 0;\n    virtual void stop()                                         = 0;\n    virtual int beginMulticastPacket()                          = 0;\n    virtual int beginPacket()                                   = 0;\n    virtual int beginPacket(IPAddress ip, uint16_t port)        = 0;\n    virtual int beginPacket(const char *host, uint16_t port)    = 0;\n    virtual int endPacket()                                     = 0;\n    virtual size_t write(uint8_t)                               = 0;\n    virtual size_t write(const uint8_t *buffer, size_t size)    = 0;\n    virtual int parsePacket()                                   = 0;\n    virtual int available()                                     = 0;\n    virtual int read()                                          = 0;\n    virtual int read(unsigned char *buffer, size_t len)         = 0;\n    virtual int read(char *buffer, size_t len)                  = 0;\n    virtual int peek()                                          = 0;\n    virtual void flush()                                        = 0;\n    virtual IPAddress remoteIP()                                = 0;\n    virtual uint16_t remotePort()                               = 0;\n};\n</code></pre>"},{"location":"ltapi/_wire_8h/","title":"File Wire.h","text":"<p>FileList &gt; api &gt; Wire.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/Stream.h&gt;</code></li> </ul>"},{"location":"ltapi/_wire_8h/#classes","title":"Classes","text":"Type Name     class ITwoWire      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/Wire.h</code></p>"},{"location":"ltapi/_wire_8h_source/","title":"File Wire.h","text":"<p>File List &gt; api &gt; Wire.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-09. */\n\n#include &lt;api/Stream.h&gt;\n\nclass ITwoWire : public Stream {\n  protected:\n    int8_t _sda    = -1;\n    int8_t _scl    = -1;\n    uint32_t _freq = 0;\n\n    void (*onRequestCallback)(void);\n    void (*onReceiveCallback)(int);\n\n  public:\n    bool begin() {\n        return begin(_sda, _scl, _freq);\n    }\n\n    bool begin(uint8_t address) {\n        return begin(address, _sda, _scl, _freq);\n    }\n\n    virtual bool setPins(int8_t sda, int8_t scl) = 0;\n\n    virtual bool begin(int8_t sda, int8_t scl, uint32_t frequency = 0)                  = 0;\n    virtual bool begin(uint8_t address, int8_t sda, int8_t scl, uint32_t frequency = 0) = 0;\n    virtual bool end()                                                                  = 0;\n\n    virtual bool setClock(uint32_t freq) = 0;\n\n    virtual void beginTransmission(uint8_t address) = 0;\n    virtual uint8_t endTransmission(bool stopBit)   = 0;\n\n    virtual size_t requestFrom(uint8_t address, size_t len, bool stopBit) = 0;\n\n    virtual size_t write(const uint8_t *data, size_t len) = 0;\n\n    virtual int available() = 0;\n    virtual int read()      = 0;\n    virtual int peek()      = 0;\n    virtual void flush()    = 0;\n\n    uint32_t getClock() {\n        return _freq;\n    }\n\n    uint8_t endTransmission() {\n        return endTransmission(true);\n    }\n\n    size_t requestFrom(uint8_t address, size_t len) {\n        return requestFrom(address, len, true);\n    }\n\n    virtual size_t write(uint8_t data) {\n        return write(&amp;data, 1);\n    }\n\n    void onReceive(void (*cb)(int)) {\n        onReceiveCallback = cb;\n    }\n\n    void onRequest(void (*cb)(void)) {\n        onRequestCallback = cb;\n    }\n};\n</code></pre>"},{"location":"ltapi/dir_fa4467cb0be219eff12b23d1341d7603/","title":"Dir arduino/libretuya/api/WiFi","text":"<p>FileList &gt; api &gt; WiFi</p>"},{"location":"ltapi/dir_fa4467cb0be219eff12b23d1341d7603/#files","title":"Files","text":"Type Name     file WiFi.cpp    file WiFi.h    file WiFiAP.cpp    file WiFiEvents.cpp    file WiFiEvents.h    file WiFiGeneric.cpp    file WiFiSTA.cpp    file WiFiScan.cpp    file WiFiType.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/</code></p>"},{"location":"ltapi/_wi_fi_8cpp/","title":"File WiFi.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFi.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiClass WiFi    WiFiClass * pWiFi   = = NULL"},{"location":"ltapi/_wi_fi_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_wi_fi_8cpp/#variable-wifi","title":"variable WiFi","text":"<pre><code>WiFiClass WiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_8cpp/#variable-pwifi","title":"variable pWiFi","text":"<pre><code>WiFiClass* pWiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFi.cpp</code></p>"},{"location":"ltapi/_wi_fi_8cpp_source/","title":"File WiFi.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFi.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nvoid WiFiClass::printDiag(Print &amp;dest) {\n    const char *modes[] = {\"NULL\", \"STA\", \"AP\", \"STA+AP\"};\n    const char *enc[]   = {\"Open\", \"WEP\", \"WPA PSK\", \"WPA2 PSK\", \"WPA/WPA2\", \"WPA\", \"WPA2\"};\n\n    dest.print(\"Mode: \");\n    dest.println(modes[getMode()]);\n\n    if (getMode() &amp; WIFI_MODE_STA) {\n        dest.println(\"-- Station --\");\n        dest.print(\"SSID: \");\n        if (isConnected()) {\n            dest.println(SSID());\n            dest.print(\"Channel: \");\n            dest.println(channel());\n            dest.print(\"BSSID: \");\n            dest.println(BSSIDstr());\n            dest.print(\"RSSI: \");\n            dest.println(RSSI());\n            dest.print(\"Encryption: \");\n            dest.println(enc[getEncryption()]);\n            dest.print(\"IP: \");\n            dest.println(localIP());\n            dest.print(\"MAC: \");\n            dest.println(macAddress());\n            dest.print(\"Hostname: \");\n            dest.println(getHostname());\n        } else {\n            dest.println(\"disconnected\");\n        }\n    }\n\n    if (getMode() &amp; WIFI_MODE_AP) {\n        dest.println(\"-- Access Point --\");\n        dest.print(\"SSID: \");\n        if (softAPSSID().length()) {\n            dest.println(softAPSSID());\n            dest.print(\"IP: \");\n            dest.println(softAPIP());\n            dest.print(\"MAC: \");\n            dest.println(softAPmacAddress());\n            dest.print(\"Hostname: \");\n            dest.println(softAPgetHostname());\n        } else {\n            dest.println(\"disconnected\");\n        }\n    }\n}\n\nbool WiFiClass::validate(const char *ssid, const char *passphrase) {\n    if (!ssid || *ssid == 0x00 || strlen(ssid) &gt; 32) {\n        LT_WM(WIFI, \"SSID not specified or too long\");\n        return false;\n    }\n    if (passphrase) {\n        uint16_t length = strlen(passphrase);\n        if (length &lt; 8) {\n            LT_WM(WIFI, \"Passphrase too short (%u)\", length);\n            return false;\n        }\n        if (length &gt; 63) {\n            LT_WM(WIFI, \"Passphrase too long (%u)\", length);\n            return false;\n        }\n    }\n    return true;\n}\n\n__attribute__((weak)) void WiFiClass::dataInitialize() {}\n\n__attribute__((weak)) void WiFiClass::dataFree() {}\n\nWiFiClass WiFi;\nWiFiClass *pWiFi = NULL;\n</code></pre>"},{"location":"ltapi/_wi_fi_8h/","title":"File WiFi.h","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFi.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Events.h&gt;</code></li> <li><code>#include &lt;api/IPAddress.h&gt;</code></li> <li><code>#include &lt;api/IPv6Address.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"WiFiType.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_8h/#classes","title":"Classes","text":"Type Name     class WiFiClass"},{"location":"ltapi/_wi_fi_8h/#public-attributes","title":"Public Attributes","text":"Type Name     WiFiClass WiFi    WiFiClass * pWiFi"},{"location":"ltapi/_wi_fi_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_wi_fi_8h/#variable-wifi","title":"variable WiFi","text":"<pre><code>WiFiClass WiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_8h/#variable-pwifi","title":"variable pWiFi","text":"<pre><code>WiFiClass* pWiFi;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFi.h</code></p>"},{"location":"ltapi/_wi_fi_8h_source/","title":"File WiFi.h","text":"<p>File List &gt; api &gt; WiFi &gt; WiFi.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n WiFi.h - esp32 Wifi support.\n Based on WiFi.h from Arduino WiFi shield library.\n Copyright (c) 2011-2014 Arduino.  All right reserved.\n Modified by Ivan Grokhotkov, December 2014\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Events.h&gt;\n#include &lt;api/IPAddress.h&gt;\n#include &lt;api/IPv6Address.h&gt;\n#include &lt;vector&gt;\n\n#include \"WiFiType.h\"\n\n#ifdef LT_ARD_HAS_WIFI\n// family's data structure\n#include &lt;WiFiData.h&gt;\n#endif\n\nclass WiFiClass {\n  public:\n#ifdef LT_ARD_HAS_WIFI\n    // must be public for WiFiEvents &amp; WiFiScan static handlers\n    WiFiData data;\n#endif\n    WiFiScanData *scan = NULL;\n\n  public: /* WiFi.cpp */\n    WiFiClass();\n    ~WiFiClass();\n    void printDiag(Print &amp;dest);\n    bool validate(const char *ssid, const char *passphrase);\n    void dataInitialize();\n    void dataFree();\n\n  public: /* WiFiGeneric.cpp */\n    bool mode(WiFiMode mode);\n    bool modePriv(WiFiMode mode, WiFiModeAction sta, WiFiModeAction ap);\n    WiFiMode getMode();\n    WiFiStatus status();\n\n    bool enableSTA(bool enable);\n    bool enableAP(bool enable);\n\n    bool setSleep(bool enable);\n    bool getSleep();\n\n    bool setTxPower(int power);\n    int getTxPower();\n\n    int hostByName(const char *hostname, IPAddress &amp;aResult);\n    IPAddress hostByName(const char *hostname);\n\n    static IPAddress calculateNetworkID(IPAddress ip, IPAddress subnet);\n    static IPAddress calculateBroadcast(IPAddress ip, IPAddress subnet);\n    static uint8_t calculateSubnetCIDR(IPAddress subnetMask);\n    static String macToString(uint8_t *mac);\n\n  protected: /* WiFiEvents.cpp */\n    static std::vector&lt;EventHandler&gt; handlers;\n\n  public: /* WiFiEvents.cpp */\n    uint16_t onEvent(EventCb callback, EventId eventId = ARDUINO_EVENT_MAX);\n    uint16_t onEvent(EventFuncCb callback, EventId eventId = ARDUINO_EVENT_MAX);\n    uint16_t onEvent(EventSysCb callback, EventId eventId = ARDUINO_EVENT_MAX);\n    void removeEvent(EventCb callback, EventId eventId);\n    void removeEvent(EventSysCb callback, EventId eventId);\n    void removeEvent(uint16_t id);\n    static void postEvent(EventId eventId, EventInfo eventInfo);\n\n  public: /* WiFiSTA.cpp */\n    WiFiStatus begin(\n        const char *ssid,\n        const char *passphrase = NULL,\n        int32_t channel        = 0,\n        const uint8_t *bssid   = NULL,\n        bool connect           = true\n    );\n    WiFiStatus\n    begin(char *ssid, char *passphrase = NULL, int32_t channel = 0, const uint8_t *bssid = NULL, bool connect = true);\n\n    bool config(\n        IPAddress localIP,\n        IPAddress gateway,\n        IPAddress subnet,\n        IPAddress dns1 = (uint32_t)0x00000000,\n        IPAddress dns2 = (uint32_t)0x00000000\n    );\n\n    bool reconnect(const uint8_t *bssid = NULL);\n    bool disconnect(bool wifiOff = false);\n\n    bool isConnected();\n\n    bool setAutoReconnect(bool autoReconnect);\n    bool getAutoReconnect();\n\n    WiFiStatus waitForConnectResult(unsigned long timeout);\n\n    IPAddress localIP();\n    uint8_t *macAddress(uint8_t *mac);\n    String macAddress();\n    IPAddress subnetMask();\n    IPAddress gatewayIP();\n    IPAddress dnsIP(uint8_t dns_no = 0);\n    IPAddress broadcastIP();\n    IPAddress networkID();\n    uint8_t subnetCIDR();\n    bool enableIpV6();\n    IPv6Address localIPv6();\n    const char *getHostname();\n    bool setHostname(const char *hostname);\n    bool setMacAddress(const uint8_t *mac);\n\n    inline bool hostname(const String &amp;aHostname) {\n        return setHostname(aHostname.c_str());\n    }\n\n    const String SSID();\n    const String psk();\n    uint8_t *BSSID();\n    String BSSIDstr();\n    int32_t channel();\n    int8_t RSSI();\n    WiFiAuthMode getEncryption();\n\n  public: /* WiFiScan.cpp */\n    int16_t scanNetworks(\n        bool async               = false,\n        bool showHidden          = false,\n        bool passive             = false,\n        uint32_t maxMsPerChannel = 300,\n        uint8_t channel          = 0\n    );\n    bool getNetworkInfo(\n        uint8_t networkItem,\n        String &amp;ssid,\n        WiFiAuthMode &amp;encryptionType,\n        int32_t &amp;RSSI,\n        uint8_t *&amp;BSSID,\n        int32_t &amp;channel\n    );\n\n    int16_t scanComplete();\n    uint8_t scanAlloc(uint8_t count);\n    void scanInit();\n    void scanDelete();\n\n    String SSID(uint8_t networkItem);\n    WiFiAuthMode encryptionType(uint8_t networkItem);\n    int32_t RSSI(uint8_t networkItem);\n    uint8_t *BSSID(uint8_t networkItem);\n    String BSSIDstr(uint8_t networkItem);\n    int32_t channel(uint8_t networkItem);\n\n  public: /* WiFiAP.cpp */\n    bool softAP(\n        const char *ssid, const char *passphrase = NULL, int channel = 1, bool ssidHidden = false, int maxClients = 4\n    );\n    bool softAPConfig(IPAddress localIP, IPAddress gateway, IPAddress subnet);\n    bool softAPdisconnect(bool wifiOff = false);\n\n    uint8_t softAPgetStationNum();\n\n    IPAddress softAPIP();\n    IPAddress softAPBroadcastIP();\n    IPAddress softAPNetworkID();\n    uint8_t softAPSubnetCIDR();\n    IPAddress softAPSubnetMask();\n    bool softAPenableIpV6();\n    IPv6Address softAPIPv6();\n    const char *softAPgetHostname();\n    bool softAPsetHostname(const char *hostname);\n    uint8_t *softAPmacAddress(uint8_t *mac);\n    String softAPmacAddress(void);\n    const String softAPSSID(void);\n};\n\nextern WiFiClass WiFi;\nextern WiFiClass *pWiFi;\n</code></pre>"},{"location":"ltapi/_wi_fi_a_p_8cpp/","title":"File WiFiAP.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiAP.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_a_p_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_a_p_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_a_p_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiAP.cpp</code></p>"},{"location":"ltapi/_wi_fi_a_p_8cpp_source/","title":"File WiFiAP.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiAP.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nIPAddress WiFiClass::softAPBroadcastIP() {\n    return calculateBroadcast(softAPIP(), softAPSubnetMask());\n}\n\nIPAddress WiFiClass::softAPNetworkID() {\n    return calculateNetworkID(softAPIP(), softAPSubnetMask());\n}\n\nuint8_t WiFiClass::softAPSubnetCIDR() {\n    return calculateSubnetCIDR(softAPSubnetMask());\n}\n\n__attribute__((weak)) bool WiFiClass::softAPenableIpV6() {\n    return false;\n}\n\n__attribute__((weak)) IPv6Address WiFiClass::softAPIPv6() {\n    return IPv6Address();\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8cpp/","title":"File WiFiEvents.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiEvents.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.cpp</code></p>"},{"location":"ltapi/_wi_fi_events_8cpp_source/","title":"File WiFiEvents.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiEvents.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-17. */\n\n#include \"WiFi.h\"\n\nstd::vector&lt;EventHandler&gt; WiFiClass::handlers;\n\nuint16_t WiFiClass::onEvent(EventCb callback, EventId eventId) {\n    if (!callback)\n        return 0;\n    EventHandler handler;\n    handler.cb      = callback;\n    handler.eventId = eventId;\n    handlers.push_back(handler);\n    return handler.id;\n}\n\nuint16_t WiFiClass::onEvent(EventFuncCb callback, EventId eventId) {\n    if (!callback)\n        return 0;\n    EventHandler handler;\n    handler.fcb     = callback;\n    handler.eventId = eventId;\n    handlers.push_back(handler);\n    return handler.id;\n}\n\nuint16_t WiFiClass::onEvent(EventSysCb callback, EventId eventId) {\n    if (!callback)\n        return 0;\n    EventHandler handler;\n    handler.scb     = callback;\n    handler.eventId = eventId;\n    handlers.push_back(handler);\n    return handler.id;\n}\n\nvoid WiFiClass::removeEvent(EventCb callback, EventId eventId) {\n    if (!callback)\n        return;\n    for (uint16_t i = 0; i &lt; handlers.size(); i++) {\n        EventHandler handler = handlers[i];\n        if (handler.cb == callback &amp;&amp; handler.eventId == eventId) {\n            handlers.erase(handlers.begin() + i);\n        }\n    }\n}\n\nvoid WiFiClass::removeEvent(EventSysCb callback, EventId eventId) {\n    if (!callback)\n        return;\n    for (uint16_t i = 0; i &lt; handlers.size(); i++) {\n        EventHandler handler = handlers[i];\n        if (handler.scb == callback &amp;&amp; handler.eventId == eventId) {\n            handlers.erase(handlers.begin() + i);\n        }\n    }\n}\n\nvoid WiFiClass::removeEvent(uint16_t id) {\n    for (uint16_t i = 0; i &lt; handlers.size(); i++) {\n        EventHandler handler = handlers[i];\n        if (handler.id == id) {\n            handlers.erase(handlers.begin() + i);\n        }\n    }\n}\n\nvoid WiFiClass::postEvent(EventId eventId, EventInfo eventInfo) {\n    for (auto handler : handlers) {\n        if (handler.eventId != ARDUINO_EVENT_MAX &amp;&amp; handler.eventId != eventId)\n            continue;\n        if (handler.cb) {\n            handler.cb(eventId);\n        } else if (handler.fcb) {\n            handler.fcb(eventId, eventInfo);\n        } else if (handler.scb) {\n            Event_t event = {\n                .event_id   = eventId,\n                .event_info = eventInfo,\n            };\n            handler.scb(&amp;event);\n        }\n    }\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/","title":"File WiFiEvents.h","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiEvents.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFiType.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_events_8h/#classes","title":"Classes","text":"Type Name     struct esp_netif_ip6_info_t IPV6 IP address information.   struct esp_netif_ip_info_t    struct ip_event_ap_staipassigned_t    struct ip_event_got_ip6_t    struct ip_event_got_ip_t    struct wifi_event_action_tx_status_t    struct wifi_event_ap_probe_req_rx_t    struct wifi_event_ap_staconnected_t    struct wifi_event_ap_stadisconnected_t    struct wifi_event_ftm_report_t    struct wifi_event_roc_done_t    struct wifi_event_sta_authmode_change_t    struct wifi_event_sta_connected_t    struct wifi_event_sta_disconnected_t    struct wifi_event_sta_scan_done_t    struct wifi_event_sta_wps_er_pin_t    struct wifi_event_sta_wps_er_success_t    struct wifi_ftm_report_entry_t"},{"location":"ltapi/_wi_fi_events_8h/#public-types","title":"Public Types","text":"Type Name     enum wifi_event_sta_wps_fail_reason_t    enum wifi_ftm_status_t FTM operation status types."},{"location":"ltapi/_wi_fi_events_8h/#macros","title":"Macros","text":"Type Name     define MAX_PASSPHRASE_LEN  64   define MAX_SSID_LEN  32   define MAX_WPS_AP_CRED  3   define WIFI_STATIS_ALL  (-1)   define WIFI_STATIS_BUFFER  (1 &lt;&lt; 0)   define WIFI_STATIS_DIAG  (1 &lt;&lt; 3)   define WIFI_STATIS_HW  (1 &lt;&lt; 2)   define WIFI_STATIS_PS  (1 &lt;&lt; 4)   define WIFI_STATIS_RXTX  (1 &lt;&lt; 1)"},{"location":"ltapi/_wi_fi_events_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_wi_fi_events_8h/#enum-wifi_event_sta_wps_fail_reason_t","title":"enum wifi_event_sta_wps_fail_reason_t","text":"<pre><code>enum wifi_event_sta_wps_fail_reason_t {\n    WPS_FAIL_REASON_NORMAL = 0,\n    WPS_FAIL_REASON_RECV_M2D,\n    WPS_FAIL_REASON_MAX\n};\n</code></pre> <p>Argument structure for WIFI_EVENT_STA_WPS_ER_FAILED event </p>"},{"location":"ltapi/_wi_fi_events_8h/#enum-wifi_ftm_status_t","title":"enum wifi_ftm_status_t","text":"<pre><code>enum wifi_ftm_status_t {\n    FTM_STATUS_SUCCESS = 0,\n    FTM_STATUS_UNSUPPORTED,\n    FTM_STATUS_CONF_REJECTED,\n    FTM_STATUS_NO_RESPONSE,\n    FTM_STATUS_FAIL\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_wi_fi_events_8h/#define-max_passphrase_len","title":"define MAX_PASSPHRASE_LEN","text":"<pre><code>#define MAX_PASSPHRASE_LEN 64\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-max_ssid_len","title":"define MAX_SSID_LEN","text":"<pre><code>#define MAX_SSID_LEN 32\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-max_wps_ap_cred","title":"define MAX_WPS_AP_CRED","text":"<pre><code>#define MAX_WPS_AP_CRED 3\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_all","title":"define WIFI_STATIS_ALL","text":"<pre><code>#define WIFI_STATIS_ALL (-1)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_buffer","title":"define WIFI_STATIS_BUFFER","text":"<pre><code>#define WIFI_STATIS_BUFFER (1 &lt;&lt; 0)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_diag","title":"define WIFI_STATIS_DIAG","text":"<pre><code>#define WIFI_STATIS_DIAG (1 &lt;&lt; 3)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_hw","title":"define WIFI_STATIS_HW","text":"<pre><code>#define WIFI_STATIS_HW (1 &lt;&lt; 2)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_ps","title":"define WIFI_STATIS_PS","text":"<pre><code>#define WIFI_STATIS_PS (1 &lt;&lt; 4)\n</code></pre>"},{"location":"ltapi/_wi_fi_events_8h/#define-wifi_statis_rxtx","title":"define WIFI_STATIS_RXTX","text":"<pre><code>#define WIFI_STATIS_RXTX (1 &lt;&lt; 1)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiEvents.h</code></p>"},{"location":"ltapi/_wi_fi_events_8h_source/","title":"File WiFiEvents.h","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiEvents.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * SPDX-FileCopyrightText: 2015-2021 Espressif Systems (Shanghai) CO LTD\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#pragma once\n\n#include \"WiFiType.h\"\n\ntypedef struct {\n    uint32_t status; \n    uint8_t number;  \n    uint8_t scan_id; \n} wifi_event_sta_scan_done_t;\n\ntypedef struct {\n    uint8_t ssid[32];          \n    uint8_t ssid_len;          \n    uint8_t bssid[6];          \n    uint8_t channel;           \n    wifi_auth_mode_t authmode; \n} wifi_event_sta_connected_t;\n\ntypedef struct {\n    uint8_t ssid[32]; \n    uint8_t ssid_len; \n    uint8_t bssid[6]; \n    uint8_t reason;   \n} wifi_event_sta_disconnected_t;\n\ntypedef struct {\n    wifi_auth_mode_t old_mode; \n    wifi_auth_mode_t new_mode; \n} wifi_event_sta_authmode_change_t;\n\ntypedef struct {\n    uint8_t pin_code[8]; \n} wifi_event_sta_wps_er_pin_t;\n\ntypedef enum {\n    WPS_FAIL_REASON_NORMAL = 0, \n    WPS_FAIL_REASON_RECV_M2D,   \n    WPS_FAIL_REASON_MAX\n} wifi_event_sta_wps_fail_reason_t;\n\n#define MAX_SSID_LEN       32\n#define MAX_PASSPHRASE_LEN 64\n#define MAX_WPS_AP_CRED    3\n\ntypedef struct {\n    uint8_t ap_cred_cnt; \n    struct {\n        uint8_t ssid[MAX_SSID_LEN];             \n        uint8_t passphrase[MAX_PASSPHRASE_LEN]; \n    } ap_cred[MAX_WPS_AP_CRED];                 \n} wifi_event_sta_wps_er_success_t;\n\ntypedef struct {\n    uint8_t mac[6];     \n    uint8_t aid;        \n    bool is_mesh_child; \n} wifi_event_ap_staconnected_t;\n\ntypedef struct {\n    uint8_t mac[6];     \n    uint8_t aid;        \n    bool is_mesh_child; \n} wifi_event_ap_stadisconnected_t;\n\ntypedef struct {\n    int rssi;       \n    uint8_t mac[6]; \n} wifi_event_ap_probe_req_rx_t;\n\ntypedef enum {\n    FTM_STATUS_SUCCESS = 0,   \n    FTM_STATUS_UNSUPPORTED,   \n    FTM_STATUS_CONF_REJECTED, \n    FTM_STATUS_NO_RESPONSE,   \n    FTM_STATUS_FAIL,          \n} wifi_ftm_status_t;\n\ntypedef struct {\n    uint8_t dlog_token; \n    int8_t rssi;        \n    uint32_t rtt;       \n    uint64_t t1;        \n    uint64_t t2;        \n    uint64_t t3;        \n    uint64_t t4;        \n} wifi_ftm_report_entry_t;\n\ntypedef struct {\n    uint8_t peer_mac[6];      \n    wifi_ftm_status_t status; \n    uint32_t rtt_raw;         \n    uint32_t rtt_est;         \n    uint32_t dist_est;        \n    wifi_ftm_report_entry_t\n        *ftm_report_data;           \n    uint8_t ftm_report_num_entries; \n} wifi_event_ftm_report_t;\n\n#define WIFI_STATIS_BUFFER (1 &lt;&lt; 0)\n#define WIFI_STATIS_RXTX   (1 &lt;&lt; 1)\n#define WIFI_STATIS_HW     (1 &lt;&lt; 2)\n#define WIFI_STATIS_DIAG   (1 &lt;&lt; 3)\n#define WIFI_STATIS_PS     (1 &lt;&lt; 4)\n#define WIFI_STATIS_ALL    (-1)\n\ntypedef struct {\n    int ifx;          \n    uint32_t context; \n    uint8_t da[6];    \n    uint8_t status;   \n} wifi_event_action_tx_status_t;\n\ntypedef struct {\n    uint32_t context; \n} wifi_event_roc_done_t;\n\ntypedef struct {\n    esp_ip4_addr_t ip;      \n    esp_ip4_addr_t netmask; \n    esp_ip4_addr_t gw;      \n} esp_netif_ip_info_t;\n\ntypedef struct {\n    esp_ip6_addr_t ip; \n} esp_netif_ip6_info_t;\n\ntypedef struct {\n    int if_index;                \n    void *esp_netif;             \n    esp_netif_ip_info_t ip_info; \n    bool ip_changed;             \n} ip_event_got_ip_t;\n\ntypedef struct {\n    int if_index;                  \n    void *esp_netif;               \n    esp_netif_ip6_info_t ip6_info; \n    int ip_index;                  \n} ip_event_got_ip6_t;\n\ntypedef struct {\n    esp_ip4_addr_t ip; \n} ip_event_ap_staipassigned_t;\n</code></pre>"},{"location":"ltapi/_wi_fi_generic_8cpp/","title":"File WiFiGeneric.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiGeneric.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_generic_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_generic_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_generic_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiGeneric.cpp</code></p>"},{"location":"ltapi/_wi_fi_generic_8cpp_source/","title":"File WiFiGeneric.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiGeneric.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nbool WiFiClass::mode(WiFiMode mode) {\n    // store a pointer to WiFi for WiFiEvents.cpp\n    pWiFi = this;\n\n    WiFiMode currentMode = getMode();\n    LT_DM(WIFI, \"Mode changing %u -&gt; %u\", currentMode, mode);\n    if (mode == currentMode)\n        return true;\n\n    // get mode changes as 0/1\n    WiFiModeAction sta = WiFiModeAction((mode &amp; WIFI_MODE_STA) != (currentMode &amp; WIFI_MODE_STA));\n    WiFiModeAction ap  = WiFiModeAction((mode &amp; WIFI_MODE_AP) != (currentMode &amp; WIFI_MODE_AP));\n    // change 0/1 to 1/2\n    sta = WiFiModeAction(sta + sta * !!(mode &amp; WIFI_MODE_STA));\n    ap  = WiFiModeAction(ap + ap * !!(mode &amp; WIFI_MODE_AP));\n    // initialize data structures if wifi is enabled\n    if (mode)\n        dataInitialize();\n    // actually change the mode\n    LT_HEAP_I();\n    if (!modePriv(mode, sta, ap))\n        return false;\n    if (getMode() != mode) {\n        LT_WM(WIFI, \"Mode changed to %d (requested %d)\", getMode(), mode);\n    }\n    return true;\n}\n\nbool WiFiClass::enableSTA(bool enable) {\n    WiFiMode currentMode = getMode();\n    if (((currentMode &amp; WIFI_MODE_STA) != 0) != enable) {\n        return mode((WiFiMode)(currentMode ^ WIFI_MODE_STA));\n    }\n    return true;\n}\n\nbool WiFiClass::enableAP(bool enable) {\n    WiFiMode currentMode = getMode();\n    if (((currentMode &amp; WIFI_MODE_AP) != 0) != enable) {\n        return mode((WiFiMode)(currentMode ^ WIFI_MODE_AP));\n    }\n    return true;\n}\n\n__attribute__((weak)) bool WiFiClass::setSleep(bool enable) {\n    return false;\n}\n\n__attribute__((weak)) bool WiFiClass::getSleep() {\n    return false;\n}\n\n__attribute__((weak)) bool WiFiClass::setTxPower(int power) {\n    return false;\n}\n\n__attribute__((weak)) int WiFiClass::getTxPower() {\n    return 0;\n}\n\nint WiFiClass::hostByName(const char *hostname, IPAddress &amp;aResult) {\n    aResult = hostByName(hostname);\n    return true;\n}\n\nIPAddress WiFiClass::calculateNetworkID(IPAddress ip, IPAddress subnet) {\n    IPAddress networkID;\n\n    for (size_t i = 0; i &lt; 4; i++)\n        networkID[i] = subnet[i] &amp; ip[i];\n\n    return networkID;\n}\n\nIPAddress WiFiClass::calculateBroadcast(IPAddress ip, IPAddress subnet) {\n    IPAddress broadcastIp;\n\n    for (int i = 0; i &lt; 4; i++)\n        broadcastIp[i] = ~subnet[i] | ip[i];\n\n    return broadcastIp;\n}\n\nuint8_t WiFiClass::calculateSubnetCIDR(IPAddress subnetMask) {\n    uint8_t CIDR = 0;\n\n    for (uint8_t i = 0; i &lt; 4; i++) {\n        if (subnetMask[i] == 0x80) // 128\n            CIDR += 1;\n        else if (subnetMask[i] == 0xC0) // 192\n            CIDR += 2;\n        else if (subnetMask[i] == 0xE0) // 224\n            CIDR += 3;\n        else if (subnetMask[i] == 0xF0) // 242\n            CIDR += 4;\n        else if (subnetMask[i] == 0xF8) // 248\n            CIDR += 5;\n        else if (subnetMask[i] == 0xFC) // 252\n            CIDR += 6;\n        else if (subnetMask[i] == 0xFE) // 254\n            CIDR += 7;\n        else if (subnetMask[i] == 0xFF) // 255\n            CIDR += 8;\n    }\n\n    return CIDR;\n}\n\nString WiFiClass::macToString(uint8_t *mac) {\n    char macStr[18]; // 6*2 + 5*':' + '\\0'\n    sprintf(macStr, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    return macStr;\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_s_t_a_8cpp/","title":"File WiFiSTA.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiSTA.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>"},{"location":"ltapi/_wi_fi_s_t_a_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/_wi_fi_s_t_a_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_wi_fi_s_t_a_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiSTA.cpp</code></p>"},{"location":"ltapi/_wi_fi_s_t_a_8cpp_source/","title":"File WiFiSTA.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiSTA.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nWiFiStatus WiFiClass::begin(char *ssid, char *passphrase, int32_t channel, const uint8_t *bssid, bool connect) {\n    return begin((const char *)ssid, (const char *)passphrase, channel, bssid, connect);\n}\n\nbool WiFiClass::isConnected() {\n    return status() == WL_CONNECTED;\n}\n\nWiFiStatus WiFiClass::waitForConnectResult(unsigned long timeout) {\n    if ((getMode() &amp; WIFI_MODE_STA) == 0) {\n        return WL_DISCONNECTED;\n    }\n    unsigned long start = millis();\n    while ((!status() || status() &gt;= WL_DISCONNECTED) &amp;&amp; (millis() - start) &lt; timeout) {\n        delay(100);\n    }\n    return status();\n}\n\nString WiFiClass::macAddress(void) {\n    uint8_t mac[6];\n    macAddress(mac);\n    return macToString(mac);\n}\n\nIPAddress WiFiClass::networkID() {\n    return calculateNetworkID(gatewayIP(), subnetMask());\n}\n\nuint8_t WiFiClass::subnetCIDR() {\n    return calculateSubnetCIDR(subnetMask());\n}\n\nString WiFiClass::BSSIDstr() {\n    return macToString(BSSID());\n}\n\n__attribute__((weak)) bool WiFiClass::enableIpV6() {\n    return false;\n}\n\n__attribute__((weak)) IPv6Address WiFiClass::localIPv6() {\n    return IPv6Address();\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_scan_8cpp/","title":"File WiFiScan.cpp","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiScan.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiScan.cpp</code></p>"},{"location":"ltapi/_wi_fi_scan_8cpp_source/","title":"File WiFiScan.cpp","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiScan.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-25. */\n\n#include \"WiFi.h\"\n\nbool WiFiClass::getNetworkInfo(\n    uint8_t networkItem, String &amp;ssid, WiFiAuthMode &amp;encType, int32_t &amp;rssi, uint8_t *&amp;bssid, int32_t &amp;channel\n) {\n    ssid    = SSID(networkItem);\n    encType = encryptionType(networkItem);\n    rssi    = RSSI(networkItem);\n    bssid   = BSSID(networkItem);\n    channel = this-&gt;channel(networkItem);\n    return true;\n}\n\nint16_t WiFiClass::scanComplete() {\n    if (!scan)\n        return 0;\n    if (scan-&gt;running)\n        return WIFI_SCAN_RUNNING;\n    return scan-&gt;count;\n}\n\nvoid WiFiClass::scanInit() {\n    if (scan)\n        return;\n    scan = (WiFiScanData *)zalloc(sizeof(WiFiScanData));\n}\n\nvoid WiFiClass::scanDelete() {\n    if (!scan)\n        return;\n    for (uint8_t i = 0; i &lt; scan-&gt;count; i++) {\n        free(scan-&gt;ap[i].ssid);\n    }\n    free(scan-&gt;ap);\n    free(scan);\n    scan = NULL;\n}\n\nuint8_t WiFiClass::scanAlloc(uint8_t count) {\n    uint8_t last = scan-&gt;count;\n    scan-&gt;count  = count;\n    scan-&gt;ap     = (WiFiScanAP *)realloc(scan-&gt;ap, count * sizeof(WiFiScanAP));\n    if (!scan-&gt;ap)\n        return 255;\n    memset(scan-&gt;ap + last, 0, sizeof(WiFiScanAP));\n    return last;\n}\n\nString WiFiClass::SSID(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return \"\";\n    return scan-&gt;ap[networkItem].ssid;\n}\n\nWiFiAuthMode WiFiClass::encryptionType(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return WIFI_AUTH_INVALID;\n    return scan-&gt;ap[networkItem].auth;\n}\n\nint32_t WiFiClass::RSSI(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return 0;\n    return scan-&gt;ap[networkItem].rssi;\n}\n\nuint8_t *WiFiClass::BSSID(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return NULL;\n    return scan-&gt;ap[networkItem].bssid.addr;\n}\n\nString WiFiClass::BSSIDstr(uint8_t networkItem) {\n    return macToString(BSSID(networkItem));\n}\n\nint32_t WiFiClass::channel(uint8_t networkItem) {\n    if (!scan || networkItem &gt;= scan-&gt;count)\n        return 0;\n    return scan-&gt;ap[networkItem].channel;\n}\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/","title":"File WiFiType.h","text":"<p>FileList &gt; api &gt; WiFi &gt; WiFiType.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_type_8h/#classes","title":"Classes","text":"Type Name     struct WiFiMacAddr    struct WiFiScanAP    struct WiFiScanData    struct esp_ip4_addr    struct esp_ip6_addr"},{"location":"ltapi/_wi_fi_type_8h/#public-types","title":"Public Types","text":"Type Name     enum WiFiModeAction    typedef struct esp_ip4_addr esp_ip4_addr_t    typedef struct esp_ip6_addr esp_ip6_addr_t    enum wifi_auth_mode_t    enum wifi_err_reason_t    enum wifi_mode_t    enum wl_status_t"},{"location":"ltapi/_wi_fi_type_8h/#macros","title":"Macros","text":"Type Name     define WIFI_AP  WIFI_MODE_AP   define WIFI_AP_STA  WIFI_MODE_APSTA   define WIFI_OFF  WIFI_MODE_NULL   define WIFI_SCAN_FAILED  (-2)   define WIFI_SCAN_RUNNING  (-1)   define WIFI_STA  WIFI_MODE_STA   define WiFiAuthMode  wifi_auth_mode_t   define WiFiEventId_t  uint16_t   define WiFiEventInfo_t arduino_event_info_t   define WiFiEvent_t  arduino_event_id_t   define WiFiMode  wifi_mode_t   define WiFiMode_t  wifi_mode_t   define WiFiStatus  wl_status_t"},{"location":"ltapi/_wi_fi_type_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_wi_fi_type_8h/#enum-wifimodeaction","title":"enum WiFiModeAction","text":"<pre><code>enum WiFiModeAction {\n    WLMODE_NONE = 0,\n    WLMODE_DISABLE = 1,\n    WLMODE_ENABLE = 2\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#typedef-esp_ip4_addr_t","title":"typedef esp_ip4_addr_t","text":"<pre><code>typedef struct esp_ip4_addr esp_ip4_addr_t;\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#typedef-esp_ip6_addr_t","title":"typedef esp_ip6_addr_t","text":"<pre><code>typedef struct esp_ip6_addr esp_ip6_addr_t;\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wifi_auth_mode_t","title":"enum wifi_auth_mode_t","text":"<pre><code>enum wifi_auth_mode_t {\n    WIFI_AUTH_OPEN = 0,\n    WIFI_AUTH_WEP,\n    WIFI_AUTH_WPA_PSK,\n    WIFI_AUTH_WPA2_PSK,\n    WIFI_AUTH_WPA_WPA2_PSK,\n    WIFI_AUTH_WPA2_ENTERPRISE,\n    WIFI_AUTH_WPA3_PSK,\n    WIFI_AUTH_WPA2_WPA3_PSK,\n    WIFI_AUTH_WAPI_PSK,\n    WIFI_AUTH_WPA,\n    WIFI_AUTH_WPA2,\n    WIFI_AUTH_AUTO = 200,\n    WIFI_AUTH_INVALID = 255,\n    WIFI_AUTH_MAX\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wifi_err_reason_t","title":"enum wifi_err_reason_t","text":"<pre><code>enum wifi_err_reason_t {\n    WIFI_REASON_UNSPECIFIED = 1,\n    WIFI_REASON_AUTH_EXPIRE = 2,\n    WIFI_REASON_AUTH_LEAVE = 3,\n    WIFI_REASON_ASSOC_EXPIRE = 4,\n    WIFI_REASON_ASSOC_TOOMANY = 5,\n    WIFI_REASON_NOT_AUTHED = 6,\n    WIFI_REASON_NOT_ASSOCED = 7,\n    WIFI_REASON_ASSOC_LEAVE = 8,\n    WIFI_REASON_ASSOC_NOT_AUTHED = 9,\n    WIFI_REASON_DISASSOC_PWRCAP_BAD = 10,\n    WIFI_REASON_DISASSOC_SUPCHAN_BAD = 11,\n    WIFI_REASON_BSS_TRANSITION_DISASSOC = 12,\n    WIFI_REASON_IE_INVALID = 13,\n    WIFI_REASON_MIC_FAILURE = 14,\n    WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,\n    WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,\n    WIFI_REASON_IE_IN_4WAY_DIFFERS = 17,\n    WIFI_REASON_GROUP_CIPHER_INVALID = 18,\n    WIFI_REASON_PAIRWISE_CIPHER_INVALID = 19,\n    WIFI_REASON_AKMP_INVALID = 20,\n    WIFI_REASON_UNSUPP_RSN_IE_VERSION = 21,\n    WIFI_REASON_INVALID_RSN_IE_CAP = 22,\n    WIFI_REASON_802_1X_AUTH_FAILED = 23,\n    WIFI_REASON_CIPHER_SUITE_REJECTED = 24,\n    WIFI_REASON_INVALID_PMKID = 53,\n    WIFI_REASON_BEACON_TIMEOUT = 200,\n    WIFI_REASON_NO_AP_FOUND = 201,\n    WIFI_REASON_AUTH_FAIL = 202,\n    WIFI_REASON_ASSOC_FAIL = 203,\n    WIFI_REASON_HANDSHAKE_TIMEOUT = 204,\n    WIFI_REASON_CONNECTION_FAIL = 205,\n    WIFI_REASON_AP_TSF_RESET = 206,\n    WIFI_REASON_ROAMING = 207\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wifi_mode_t","title":"enum wifi_mode_t","text":"<pre><code>enum wifi_mode_t {\n    WIFI_MODE_NULL = 0,\n    WIFI_MODE_STA,\n    WIFI_MODE_AP,\n    WIFI_MODE_APSTA,\n    WIFI_MODE_MAX\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#enum-wl_status_t","title":"enum wl_status_t","text":"<pre><code>enum wl_status_t {\n    WL_NO_SHIELD = 255,\n    WL_IDLE_STATUS = 0,\n    WL_NO_SSID_AVAIL = 1,\n    WL_SCAN_COMPLETED = 2,\n    WL_CONNECTED = 3,\n    WL_CONNECT_FAILED = 4,\n    WL_CONNECTION_LOST = 5,\n    WL_DISCONNECTED = 6\n};\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_ap","title":"define WIFI_AP","text":"<pre><code>#define WIFI_AP WIFI_MODE_AP\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_ap_sta","title":"define WIFI_AP_STA","text":"<pre><code>#define WIFI_AP_STA WIFI_MODE_APSTA\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_off","title":"define WIFI_OFF","text":"<pre><code>#define WIFI_OFF WIFI_MODE_NULL\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_scan_failed","title":"define WIFI_SCAN_FAILED","text":"<pre><code>#define WIFI_SCAN_FAILED (-2)\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_scan_running","title":"define WIFI_SCAN_RUNNING","text":"<pre><code>#define WIFI_SCAN_RUNNING (-1)\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifi_sta","title":"define WIFI_STA","text":"<pre><code>#define WIFI_STA WIFI_MODE_STA\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifiauthmode","title":"define WiFiAuthMode","text":"<pre><code>#define WiFiAuthMode wifi_auth_mode_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifieventid_t","title":"define WiFiEventId_t","text":"<pre><code>#define WiFiEventId_t uint16_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifieventinfo_t","title":"define WiFiEventInfo_t","text":"<pre><code>#define WiFiEventInfo_t arduino_event_info_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifievent_t","title":"define WiFiEvent_t","text":"<pre><code>#define WiFiEvent_t arduino_event_id_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifimode","title":"define WiFiMode","text":"<pre><code>#define WiFiMode wifi_mode_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifimode_t","title":"define WiFiMode_t","text":"<pre><code>#define WiFiMode_t wifi_mode_t\n</code></pre>"},{"location":"ltapi/_wi_fi_type_8h/#define-wifistatus","title":"define WiFiStatus","text":"<pre><code>#define WiFiStatus wl_status_t\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/api/WiFi/WiFiType.h</code></p>"},{"location":"ltapi/_wi_fi_type_8h_source/","title":"File WiFiType.h","text":"<p>File List &gt; api &gt; WiFi &gt; WiFiType.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n ESP8266WiFiType.h - esp8266 Wifi support.\n Copyright (c) 2011-2014 Arduino.  All right reserved.\n Modified by Ivan Grokhotkov, December 2014\n Reworked by Markus Sattler, December 2015\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#define WIFI_SCAN_RUNNING (-1)\n#define WIFI_SCAN_FAILED  (-2)\n\n#define WiFiMode_t   wifi_mode_t\n#define WiFiMode     wifi_mode_t\n#define WiFiStatus   wl_status_t\n#define WiFiAuthMode wifi_auth_mode_t\n\n#define WIFI_OFF    WIFI_MODE_NULL\n#define WIFI_STA    WIFI_MODE_STA\n#define WIFI_AP     WIFI_MODE_AP\n#define WIFI_AP_STA WIFI_MODE_APSTA\n\n#define WiFiEvent_t     arduino_event_id_t\n#define WiFiEventInfo_t arduino_event_info_t\n#define WiFiEventId_t   uint16_t\n\ntypedef struct {\n    uint8_t addr[6];\n} WiFiMacAddr;\n\nstruct esp_ip6_addr {\n    uint32_t addr[4];\n    uint8_t zone;\n};\n\nstruct esp_ip4_addr {\n    uint32_t addr;\n};\n\ntypedef struct esp_ip4_addr esp_ip4_addr_t;\ntypedef struct esp_ip6_addr esp_ip6_addr_t;\n\ntypedef enum {\n    WIFI_MODE_NULL = 0, \n    WIFI_MODE_STA,      \n    WIFI_MODE_AP,       \n    WIFI_MODE_APSTA,    \n    WIFI_MODE_MAX\n} wifi_mode_t;\n\ntypedef enum {\n    WL_NO_SHIELD       = 255, // for compatibility with WiFi Shield library\n    WL_IDLE_STATUS     = 0,\n    WL_NO_SSID_AVAIL   = 1,\n    WL_SCAN_COMPLETED  = 2,\n    WL_CONNECTED       = 3,\n    WL_CONNECT_FAILED  = 4,\n    WL_CONNECTION_LOST = 5,\n    WL_DISCONNECTED    = 6,\n} wl_status_t;\n\ntypedef enum {\n    WIFI_AUTH_OPEN = 0,        \n    WIFI_AUTH_WEP,             \n    WIFI_AUTH_WPA_PSK,         \n    WIFI_AUTH_WPA2_PSK,        \n    WIFI_AUTH_WPA_WPA2_PSK,    \n    WIFI_AUTH_WPA2_ENTERPRISE, \n    WIFI_AUTH_WPA3_PSK,        \n    WIFI_AUTH_WPA2_WPA3_PSK,   \n    WIFI_AUTH_WAPI_PSK,        \n    WIFI_AUTH_WPA,\n    WIFI_AUTH_WPA2,\n    WIFI_AUTH_AUTO    = 200,\n    WIFI_AUTH_INVALID = 255,\n    WIFI_AUTH_MAX\n} wifi_auth_mode_t;\n\ntypedef enum {\n    WIFI_REASON_UNSPECIFIED              = 1,\n    WIFI_REASON_AUTH_EXPIRE              = 2,\n    WIFI_REASON_AUTH_LEAVE               = 3,\n    WIFI_REASON_ASSOC_EXPIRE             = 4,\n    WIFI_REASON_ASSOC_TOOMANY            = 5,\n    WIFI_REASON_NOT_AUTHED               = 6,\n    WIFI_REASON_NOT_ASSOCED              = 7,\n    WIFI_REASON_ASSOC_LEAVE              = 8,\n    WIFI_REASON_ASSOC_NOT_AUTHED         = 9,\n    WIFI_REASON_DISASSOC_PWRCAP_BAD      = 10,\n    WIFI_REASON_DISASSOC_SUPCHAN_BAD     = 11,\n    WIFI_REASON_BSS_TRANSITION_DISASSOC  = 12,\n    WIFI_REASON_IE_INVALID               = 13,\n    WIFI_REASON_MIC_FAILURE              = 14,\n    WIFI_REASON_4WAY_HANDSHAKE_TIMEOUT   = 15,\n    WIFI_REASON_GROUP_KEY_UPDATE_TIMEOUT = 16,\n    WIFI_REASON_IE_IN_4WAY_DIFFERS       = 17,\n    WIFI_REASON_GROUP_CIPHER_INVALID     = 18,\n    WIFI_REASON_PAIRWISE_CIPHER_INVALID  = 19,\n    WIFI_REASON_AKMP_INVALID             = 20,\n    WIFI_REASON_UNSUPP_RSN_IE_VERSION    = 21,\n    WIFI_REASON_INVALID_RSN_IE_CAP       = 22,\n    WIFI_REASON_802_1X_AUTH_FAILED       = 23,\n    WIFI_REASON_CIPHER_SUITE_REJECTED    = 24,\n    WIFI_REASON_INVALID_PMKID            = 53,\n    WIFI_REASON_BEACON_TIMEOUT           = 200,\n    WIFI_REASON_NO_AP_FOUND              = 201,\n    WIFI_REASON_AUTH_FAIL                = 202,\n    WIFI_REASON_ASSOC_FAIL               = 203,\n    WIFI_REASON_HANDSHAKE_TIMEOUT        = 204,\n    WIFI_REASON_CONNECTION_FAIL          = 205,\n    WIFI_REASON_AP_TSF_RESET             = 206,\n    WIFI_REASON_ROAMING                  = 207,\n} wifi_err_reason_t;\n\ntypedef struct {\n    char *ssid;\n    WiFiAuthMode auth;\n    int32_t rssi;\n    WiFiMacAddr bssid;\n    int32_t channel;\n} WiFiScanAP;\n\ntypedef struct {\n    bool running          = false;\n    unsigned long timeout = 0;\n    uint8_t count         = 0;\n    WiFiScanAP *ap        = NULL;\n} WiFiScanData;\n\ntypedef enum {\n    WLMODE_NONE    = 0,\n    WLMODE_DISABLE = 1,\n    WLMODE_ENABLE  = 2,\n} WiFiModeAction;\n</code></pre>"},{"location":"ltapi/dir_72b077647078d252dd7f662896d48880/","title":"Dir arduino/libretuya/common","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common</p>"},{"location":"ltapi/dir_72b077647078d252dd7f662896d48880/#files","title":"Files","text":"Type Name     file WMath.cpp    file abi.cpp    file dtostrf.c    file hooks.c    file itoa.c    file serial_event.cpp    file wiring_shift.c      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/</code></p>"},{"location":"ltapi/_w_math_8cpp/","title":"File WMath.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; WMath.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_w_math_8cpp/#public-functions","title":"Public Functions","text":"Type Name     long random (long howbig)    long random (long howsmall, long howbig)    void randomSeed (uint32_t dwSeed)"},{"location":"ltapi/_w_math_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_w_math_8cpp/#function-random","title":"function random","text":"<pre><code>long random (\n    long howbig\n) \n</code></pre>"},{"location":"ltapi/_w_math_8cpp/#function-random_1","title":"function random","text":"<pre><code>long random (\n    long howsmall,\n    long howbig\n) \n</code></pre>"},{"location":"ltapi/_w_math_8cpp/#function-randomseed","title":"function randomSeed","text":"<pre><code>void randomSeed (\n    uint32_t dwSeed\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/WMath.cpp</code></p>"},{"location":"ltapi/_w_math_8cpp_source/","title":"File WMath.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; WMath.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;Arduino.h&gt;\n\nvoid randomSeed(uint32_t dwSeed) {\n    if (dwSeed != 0) {\n        srand(dwSeed);\n    }\n}\n\nlong random(long howbig) {\n    if (howbig == 0) {\n        return 0;\n    }\n\n    return rand() % howbig;\n}\n\nlong random(long howsmall, long howbig) {\n    if (howsmall &gt;= howbig) {\n        return howsmall;\n    }\n\n    long diff = howbig - howsmall;\n\n    return random(diff) + howsmall;\n}\n</code></pre>"},{"location":"ltapi/abi_8cpp/","title":"File abi.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; abi.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> </ul>"},{"location":"ltapi/abi_8cpp/#public-functions","title":"Public Functions","text":"Type Name     void __cxa_deleted_virtual (void)    void __cxa_pure_virtual (void)"},{"location":"ltapi/abi_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/abi_8cpp/#function-__cxa_deleted_virtual","title":"function __cxa_deleted_virtual","text":"<pre><code>void __cxa_deleted_virtual (\n    void\n) \n</code></pre>"},{"location":"ltapi/abi_8cpp/#function-__cxa_pure_virtual","title":"function __cxa_pure_virtual","text":"<pre><code>void __cxa_pure_virtual (\n    void\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/abi.cpp</code></p>"},{"location":"ltapi/abi_8cpp_source/","title":"File abi.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; abi.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino LLC.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;stdlib.h&gt;\n\nextern \"C\" void __cxa_pure_virtual(void) __attribute__((__noreturn__));\nextern \"C\" void __cxa_deleted_virtual(void) __attribute__((__noreturn__));\n\nvoid __cxa_pure_virtual(void) {\n    // We might want to write some diagnostics to uart in this case\n    // std::terminate();\n    while (1)\n        ;\n}\n\nvoid __cxa_deleted_virtual(void) {\n    // We might want to write some diagnostics to uart in this case\n    // std::terminate();\n    while (1)\n        ;\n}\n</code></pre>"},{"location":"ltapi/dtostrf_8c/","title":"File dtostrf.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; dtostrf.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/dtostrf_8c/#public-functions","title":"Public Functions","text":"Type Name     char * dtostrf (double val, signed char width, unsigned char prec, char * sout)"},{"location":"ltapi/dtostrf_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/dtostrf_8c/#function-dtostrf","title":"function dtostrf","text":"<pre><code>char * dtostrf (\n    double val,\n    signed char width,\n    unsigned char prec,\n    char * sout\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/dtostrf.c</code></p>"},{"location":"ltapi/dtostrf_8c_source/","title":"File dtostrf.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; dtostrf.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  dtostrf - Emulation for dtostrf function from avr-libc\n  Copyright (c) 2013 Arduino.  All rights reserved.\n  Written by Cristian Maglie &lt;c.maglie@arduino.cc&gt;\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;Arduino.h&gt;\n\nchar *dtostrf(double val, signed char width, unsigned char prec, char *sout) {\n    char fmt[20];\n    sprintf(fmt, \"%%%d.%df\", width, prec);\n    sprintf(sout, fmt, val);\n    return sout;\n}\n</code></pre>"},{"location":"ltapi/hooks_8c/","title":"File hooks.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; hooks.c</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/hooks_8c/#public-functions","title":"Public Functions","text":"Type Name     int sysTickHook (void)    void yield (void)"},{"location":"ltapi/hooks_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name     void __empty ()"},{"location":"ltapi/hooks_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/hooks_8c/#function-systickhook","title":"function sysTickHook","text":"<pre><code>int sysTickHook (\n    void\n) \n</code></pre> <p>SVC hook PendSV hook</p> <p>These functions are called from SVC handler, and PensSV handler. Default action is halting. </p>"},{"location":"ltapi/hooks_8c/#function-yield","title":"function yield","text":"<pre><code>void yield (\n    void\n) \n</code></pre> <p>SysTick hook</p> <p>This function is called from SysTick handler, before the default handler provided by Arduino. </p>"},{"location":"ltapi/hooks_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/hooks_8c/#function-__empty","title":"function __empty","text":"<pre><code>static void __empty () \n</code></pre> <p>Empty yield() hook.</p> <p>This function is intended to be used by library writers to build libraries or sketches that supports cooperative threads.</p> <p>Its defined as a weak symbol and it can be redefined to implement a real cooperative scheduler. </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/hooks.c</code></p>"},{"location":"ltapi/hooks_8c_source/","title":"File hooks.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; hooks.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2015 Arduino LLC.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\nstatic void __empty() {\n    // Empty\n}\n\nvoid yield(void) __attribute__((weak, alias(\"__empty\")));\n\nstatic int __false() {\n    // Return false\n    return 0;\n}\n\nint sysTickHook(void) __attribute__((weak, alias(\"__false\")));\n\nstatic void __halt() {\n    // Halts\n    while (1)\n        ;\n}\n\nvoid svcHook(void) __attribute__((weak, alias(\"__halt\")));\nvoid pendSVHook(void) __attribute__((weak, alias(\"__halt\")));\n</code></pre>"},{"location":"ltapi/itoa_8c/","title":"File itoa.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; itoa.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/itoa_8c/#public-functions","title":"Public Functions","text":"Type Name     char * itoa (int value, char * string, int radix)    char * ltoa (long value, char * string, int radix)    char * ultoa (unsigned long value, char * string, int radix)    char * utoa (unsigned int value, char * string, int radix)"},{"location":"ltapi/itoa_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/itoa_8c/#function-itoa","title":"function itoa","text":"<pre><code>char * itoa (\n    int value,\n    char * string,\n    int radix\n) \n</code></pre>"},{"location":"ltapi/itoa_8c/#function-ltoa","title":"function ltoa","text":"<pre><code>char * ltoa (\n    long value,\n    char * string,\n    int radix\n) \n</code></pre>"},{"location":"ltapi/itoa_8c/#function-ultoa","title":"function ultoa","text":"<pre><code>char * ultoa (\n    unsigned long value,\n    char * string,\n    int radix\n) \n</code></pre>"},{"location":"ltapi/itoa_8c/#function-utoa","title":"function utoa","text":"<pre><code>char * utoa (\n    unsigned int value,\n    char * string,\n    int radix\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/itoa.c</code></p>"},{"location":"ltapi/itoa_8c_source/","title":"File itoa.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; itoa.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino LLC.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;string.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nchar *ltoa(long value, char *string, int radix) {\n    char tmp[33];\n    char *tp = tmp;\n    long i;\n    unsigned long v;\n    int sign;\n    char *sp;\n\n    if (string == NULL) {\n        return 0;\n    }\n\n    if (radix &gt; 36 || radix &lt;= 1) {\n        return 0;\n    }\n\n    sign = (radix == 10 &amp;&amp; value &lt; 0);\n    if (sign) {\n        v = -value;\n    } else {\n        v = (unsigned long)value;\n    }\n\n    while (v || tp == tmp) {\n        i = v % radix;\n        v = v / radix;\n        if (i &lt; 10)\n            *tp++ = i + '0';\n        else\n            *tp++ = i + 'a' - 10;\n    }\n\n    sp = string;\n\n    if (sign)\n        *sp++ = '-';\n    while (tp &gt; tmp)\n        *sp++ = *--tp;\n    *sp = 0;\n\n    return string;\n}\n\nchar *ultoa(unsigned long value, char *string, int radix) {\n    char tmp[33];\n    char *tp = tmp;\n    long i;\n    unsigned long v = value;\n    char *sp;\n\n    if (string == NULL) {\n        return 0;\n    }\n\n    if (radix &gt; 36 || radix &lt;= 1) {\n        return 0;\n    }\n\n    while (v || tp == tmp) {\n        i = v % radix;\n        v = v / radix;\n        if (i &lt; 10)\n            *tp++ = i + '0';\n        else\n            *tp++ = i + 'a' - 10;\n    }\n\n    sp = string;\n\n    while (tp &gt; tmp)\n        *sp++ = *--tp;\n    *sp = 0;\n\n    return string;\n}\n\nchar *itoa(int value, char *string, int radix) {\n    return ltoa(value, string, radix);\n}\n\nchar *utoa(unsigned int value, char *string, int radix) {\n    return ultoa(value, string, radix);\n}\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/serial__event_8cpp/","title":"File serial_event.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; serial_event.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/serial__event_8cpp/#public-functions","title":"Public Functions","text":"Type Name     bool Serial_available ()    void serialEvent ()    void serialEventRun (void)"},{"location":"ltapi/serial__event_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/serial__event_8cpp/#function-serial_available","title":"function Serial_available","text":"<pre><code>bool Serial_available () \n</code></pre>"},{"location":"ltapi/serial__event_8cpp/#function-serialevent","title":"function serialEvent","text":"<pre><code>void serialEvent () \n</code></pre>"},{"location":"ltapi/serial__event_8cpp/#function-serialeventrun","title":"function serialEventRun","text":"<pre><code>void serialEventRun (\n    void\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/serial_event.cpp</code></p>"},{"location":"ltapi/serial__event_8cpp_source/","title":"File serial_event.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; serial_event.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-19. */\n\n#include &lt;Arduino.h&gt;\n\nvoid serialEvent() __attribute__((weak));\nbool Serial_available() __attribute__((weak));\n\nvoid serialEventRun(void) {\n    if (Serial_available &amp;&amp; serialEvent &amp;&amp; Serial_available())\n        serialEvent();\n}\n</code></pre>"},{"location":"ltapi/wiring__shift_8c/","title":"File wiring_shift.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; common &gt; wiring_shift.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/wiring__shift_8c/#public-functions","title":"Public Functions","text":"Type Name     uint8_t shiftIn (pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder)    void shiftOut (pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder, uint8_t ulVal)"},{"location":"ltapi/wiring__shift_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/wiring__shift_8c/#function-shiftin","title":"function shiftIn","text":"<pre><code>uint8_t shiftIn (\n    pin_size_t ulDataPin,\n    pin_size_t ulClockPin,\n    BitOrder ulBitOrder\n) \n</code></pre>"},{"location":"ltapi/wiring__shift_8c/#function-shiftout","title":"function shiftOut","text":"<pre><code>void shiftOut (\n    pin_size_t ulDataPin,\n    pin_size_t ulClockPin,\n    BitOrder ulBitOrder,\n    uint8_t ulVal\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/common/wiring_shift.c</code></p>"},{"location":"ltapi/wiring__shift_8c_source/","title":"File wiring_shift.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; common &gt; wiring_shift.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Copyright (c) 2014 Arduino.  All right reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include &lt;Arduino.h&gt;\n#include &lt;stdint.h&gt;\n\nuint8_t shiftIn(pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder) {\n    uint8_t value = 0;\n    uint8_t i;\n\n    for (i = 0; i &lt; 8; ++i) {\n        digitalWrite(ulClockPin, HIGH);\n\n        if (ulBitOrder == LSBFIRST) {\n            value |= digitalRead(ulDataPin) &lt;&lt; i;\n        } else {\n            value |= digitalRead(ulDataPin) &lt;&lt; (7 - i);\n        }\n\n        digitalWrite(ulClockPin, LOW);\n    }\n\n    return value;\n}\n\nvoid shiftOut(pin_size_t ulDataPin, pin_size_t ulClockPin, BitOrder ulBitOrder, uint8_t ulVal) {\n    uint8_t i;\n\n    for (i = 0; i &lt; 8; i++) {\n        if (ulBitOrder == LSBFIRST) {\n            digitalWrite(ulDataPin, !!(ulVal &amp; (1 &lt;&lt; i)));\n        } else {\n            digitalWrite(ulDataPin, !!(ulVal &amp; (1 &lt;&lt; (7 - i))));\n        }\n\n        digitalWrite(ulClockPin, HIGH);\n        digitalWrite(ulClockPin, LOW);\n    }\n}\n</code></pre>"},{"location":"ltapi/dir_dbe6cdcfbf2bf84e4400c6738463242d/","title":"Dir arduino/libretuya/compat","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat</p>"},{"location":"ltapi/dir_dbe6cdcfbf2bf84e4400c6738463242d/#files","title":"Files","text":"Type Name     file FS.h    file FSImpl.h    file WiFiAP.h    file md5.h    file pgmspace.h    file vfs_api.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/</code></p>"},{"location":"ltapi/compat_2_f_s_8h/","title":"File FS.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat &gt; FS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/FS.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/FS.h</code></p>"},{"location":"ltapi/compat_2_f_s_8h_source/","title":"File FS.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; compat &gt; FS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include &lt;api/FS.h&gt;\n</code></pre>"},{"location":"ltapi/_f_s_impl_8h/","title":"File FSImpl.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat &gt; FSImpl.h</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/FSImpl.h</code></p>"},{"location":"ltapi/_f_s_impl_8h_source/","title":"File FSImpl.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; compat &gt; FSImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n// nop\n</code></pre>"},{"location":"ltapi/_wi_fi_a_p_8h/","title":"File WiFiAP.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat &gt; WiFiAP.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;WiFi.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/WiFiAP.h</code></p>"},{"location":"ltapi/_wi_fi_a_p_8h_source/","title":"File WiFiAP.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; compat &gt; WiFiAP.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#pragma once\n\n// ESP32 WiFi examples use WiFiAP.h include\n\n#include &lt;WiFi.h&gt;\n</code></pre>"},{"location":"ltapi/compat_2_m_d5_8h/","title":"File md5.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat &gt; md5.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;MD5.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/md5.h</code></p>"},{"location":"ltapi/compat_2_m_d5_8h_source/","title":"File md5.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; compat &gt; md5.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-04. */\n\n#pragma once\n\n// lowercase \"md5.h\" to allow including actual MD5.h on case-sensitive OSes\n#include &lt;MD5.h&gt;\n</code></pre>"},{"location":"ltapi/pgmspace_8h/","title":"File pgmspace.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat &gt; pgmspace.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/deprecated-avr-comp/avr/pgmspace.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/pgmspace.h</code></p>"},{"location":"ltapi/pgmspace_8h_source/","title":"File pgmspace.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; compat &gt; pgmspace.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include &lt;api/deprecated-avr-comp/avr/pgmspace.h&gt;\n</code></pre>"},{"location":"ltapi/vfs__api_8h/","title":"File vfs_api.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; compat &gt; vfs_api.h</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/compat/vfs_api.h</code></p>"},{"location":"ltapi/vfs__api_8h_source/","title":"File vfs_api.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; compat &gt; vfs_api.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n// nop\n</code></pre>"},{"location":"ltapi/dir_347df1905c569d672c1c85d0b1221387/","title":"Dir arduino/libretuya/core","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core</p>"},{"location":"ltapi/dir_347df1905c569d672c1c85d0b1221387/#files","title":"Files","text":"Type Name     file ChipType.h    file LibreTuyaAPI.cpp    file LibreTuyaAPI.h    file LibreTuyaClass.cpp    file LibreTuyaClass.h    file LibreTuyaCompat.cpp    file LibreTuyaCompat.h    file LibreTuyaConfig.h    file LibreTuyaCustom.c    file LibreTuyaCustom.h    file SerialExtern.h    file lt_logger.c    file lt_logger.h    file main.cpp      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/</code></p>"},{"location":"ltapi/_chip_type_8h/","title":"File ChipType.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; ChipType.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_chip_type_8h/#public-types","title":"Public Types","text":"Type Name     enum ChipFamily    enum ChipType"},{"location":"ltapi/_chip_type_8h/#macros","title":"Macros","text":"Type Name     define CHIP_TYPE (family, chip_id) (((family &gt;&gt; 24) &lt;&lt; 8) | chip_id)   define CHIP_TYPE_ENUM (family, chip_id) (ChipType) CHIP_TYPE(family, chip_id)"},{"location":"ltapi/_chip_type_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_chip_type_8h/#enum-chipfamily","title":"enum ChipFamily","text":"<pre><code>enum ChipFamily {\n    F_RTL8710A = 0x9FFFD543,\n    F_RTL8710B = 0x22E0D6FC,\n    F_RTL8720C = 0xE08F7564,\n    F_RTL8720D = 0x3379CFE2,\n    F_BK7231U = 0x675A40B0,\n    F_BK7231N = 0x7B3EF230,\n    F_BK7251 = 0x6A82CC42,\n    F_BL602 = 0xDE1270B7,\n    F_XR809 = 0x51E903A8,\n    F_NATIVE = 0xDEADBEEF\n};\n</code></pre>"},{"location":"ltapi/_chip_type_8h/#enum-chiptype","title":"enum ChipType","text":"<pre><code>enum ChipType {\n    RTL8710BL = CHIP_TYPE(F_RTL8710B, 0xE0),\n    RTL8710BN = CHIP_TYPE(F_RTL8710B, 0xFF),\n    RTL8710BU = CHIP_TYPE(F_RTL8710B, 0xFE),\n    RTL8710BX = CHIP_TYPE(F_RTL8710B, 0xF6),\n    RTL8710L0 = CHIP_TYPE(F_RTL8710B, 0xFB),\n    RTL8711BN = CHIP_TYPE(F_RTL8710B, 0xFD),\n    RTL8711BU = CHIP_TYPE(F_RTL8710B, 0xFC),\n    BK7231T = CHIP_TYPE(F_BK7231U, 0x1A),\n    BK7231N = CHIP_TYPE(F_BK7231N, 0x1C),\n    BL2028N = CHIP_TYPE(F_BK7231N, 0x1C),\n    BK7252 = CHIP_TYPE(F_BK7251, 0x00)\n};\n</code></pre>"},{"location":"ltapi/_chip_type_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_chip_type_8h/#define-chip_type","title":"define CHIP_TYPE","text":"<pre><code>#define CHIP_TYPE (\n    family,\n    chip_id\n) (((family &gt;&gt; 24) &lt;&lt; 8) | chip_id)\n</code></pre>"},{"location":"ltapi/_chip_type_8h/#define-chip_type_enum","title":"define CHIP_TYPE_ENUM","text":"<pre><code>#define CHIP_TYPE_ENUM (\n    family,\n    chip_id\n) (ChipType) CHIP_TYPE(family, chip_id)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/ChipType.h</code></p>"},{"location":"ltapi/_chip_type_8h_source/","title":"File ChipType.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; ChipType.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-28. */\n\n#pragma once\n\n#define CHIP_TYPE(family, chip_id)      (((family &gt;&gt; 24) &lt;&lt; 8) | chip_id)\n#define CHIP_TYPE_ENUM(family, chip_id) (ChipType) CHIP_TYPE(family, chip_id)\n\nenum ChipFamily {\n    // used in UF2 Family ID\n    F_RTL8710A = 0x9FFFD543, // Realtek Ameba1\n    F_RTL8710B = 0x22E0D6FC, // Realtek AmebaZ (realtek-ambz)\n    F_RTL8720C = 0xE08F7564, // Realtek AmebaZ2\n    F_RTL8720D = 0x3379CFE2, // Realtek AmebaD\n    F_BK7231U  = 0x675A40B0, // Beken 7231U/7231T\n    F_BK7231N  = 0x7B3EF230, // Beken 7231N\n    F_BK7251   = 0x6A82CC42, // Beken 7251/7252\n    F_BL602    = 0xDE1270B7, // Boufallo 602\n    F_XR809    = 0x51E903A8, // Xradiotech 809\n    F_NATIVE   = 0xDEADBEEF, // Host-native\n};\n\nenum ChipType {\n    // Realtek AmebaZ\n    // IDs copied from rtl8710b_efuse.h\n    RTL8710BL = CHIP_TYPE(F_RTL8710B, 0xE0), // ???\n    RTL8710BN = CHIP_TYPE(F_RTL8710B, 0xFF), // CHIPID_8710BN / QFN32\n    RTL8710BU = CHIP_TYPE(F_RTL8710B, 0xFE), // CHIPID_8710BU / QFN48\n    RTL8710BX = CHIP_TYPE(F_RTL8710B, 0xF6), // found on an actual RTL8710BX\n    RTL8710L0 = CHIP_TYPE(F_RTL8710B, 0xFB), // CHIPID_8710BN_L0 / QFN32\n    RTL8711BN = CHIP_TYPE(F_RTL8710B, 0xFD), // CHIPID_8711BN / QFN48\n    RTL8711BU = CHIP_TYPE(F_RTL8710B, 0xFC), // CHIPID_8711BG / QFN68\n    // Beken 72XX\n    BK7231T = CHIP_TYPE(F_BK7231U, 0x1A), // *SCTRL_CHIP_ID = 0x7231a\n    BK7231N = CHIP_TYPE(F_BK7231N, 0x1C), // *SCTRL_CHIP_ID = 0x7231c\n    BL2028N = CHIP_TYPE(F_BK7231N, 0x1C), // *SCTRL_CHIP_ID = 0x7231c\n    BK7252  = CHIP_TYPE(F_BK7251, 0x00),  // TODO\n};\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8cpp/","title":"File LibreTuyaAPI.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaAPI.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaAPI.h\"</code></li> </ul>"},{"location":"ltapi/_libre_tuya_a_p_i_8cpp/#public-functions","title":"Public Functions","text":"Type Name     void hexdump (const uint8_t * buf, size_t len, uint32_t offset, uint8_t width) Print data pointed to by buf in hexdump-like format (hex+ASCII).   String ipToString (const IPAddress &amp; ip)    void lt_rand_bytes (uint8_t * buf, size_t len) Generate random bytes using rand()."},{"location":"ltapi/_libre_tuya_a_p_i_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_libre_tuya_a_p_i_8cpp/#function-hexdump","title":"function hexdump","text":"<p>Print data pointed to by buf in hexdump-like format (hex+ASCII). <pre><code>void hexdump (\n    const uint8_t * buf,\n    size_t len,\n    uint32_t offset,\n    uint8_t width\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> source pointer </li> <li><code>len</code> how many bytes to print </li> <li><code>offset</code> increment printed offset by this value </li> <li><code>width</code> how many bytes on a line </li> </ul>"},{"location":"ltapi/_libre_tuya_a_p_i_8cpp/#function-iptostring","title":"function ipToString","text":"<pre><code>String ipToString (\n    const IPAddress &amp; ip\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8cpp/#function-lt_rand_bytes","title":"function lt_rand_bytes","text":"<p>Generate random bytes using rand(). <pre><code>void lt_rand_bytes (\n    uint8_t * buf,\n    size_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> destination pointer </li> <li><code>len</code> how many bytes to generate </li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaAPI.cpp</code></p>"},{"location":"ltapi/_libre_tuya_a_p_i_8cpp_source/","title":"File LibreTuyaAPI.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaAPI.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#include \"LibreTuyaAPI.h\"\n\nString ipToString(const IPAddress &amp;ip) {\n    char szRet[16];\n    sprintf(szRet, \"%hhu.%hhu.%hhu.%hhu\", ip[0], ip[1], ip[2], ip[3]);\n    return String(szRet);\n}\n\nextern \"C\" {\nvoid lt_rand_bytes(uint8_t *buf, size_t len) {\n    int *data = (int *)buf;\n    size_t i;\n    for (i = 0; len &gt;= sizeof(int); len -= sizeof(int)) {\n        data[i++] = rand();\n    }\n    if (len) {\n        int rem             = rand();\n        unsigned char *pRem = (unsigned char *)&amp;rem;\n        memcpy(buf + i * sizeof(int), pRem, len);\n    }\n}\n\n#undef putchar\n\nvoid hexdump(const uint8_t *buf, size_t len, uint32_t offset, uint8_t width) {\n    uint16_t pos = 0;\n    while (pos &lt; len) {\n        // print hex offset\n        printf(\"%06x \", offset + pos);\n        // calculate current line width\n        uint8_t lineWidth = min(width, len - pos);\n        // print hexadecimal representation\n        for (uint8_t i = 0; i &lt; lineWidth; i++) {\n            if (i % 8 == 0) {\n                printf(\" \");\n            }\n            printf(\"%02x \", buf[pos + i]);\n        }\n        // print ascii representation\n        printf(\" |\");\n        for (uint8_t i = 0; i &lt; lineWidth; i++) {\n            char c = buf[pos + i];\n            putchar((c &gt;= 0x20 &amp;&amp; c &lt;= 0x7f) ? c : '.');\n        }\n        puts(\"|\\r\");\n        pos += lineWidth;\n    }\n}\n}\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/","title":"File LibreTuyaAPI.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaAPI.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;inttypes.h&gt;</code></li> <li><code>#include &lt;stdarg.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include \"LibreTuyaClass.h\"</code></li> <li><code>#include \"LibreTuyaCompat.h\"</code></li> <li><code>#include \"LibreTuyaConfig.h\"</code></li> <li><code>#include \"LibreTuyaCustom.h\"</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include \"lt_logger.h\"</code></li> <li><code>#include \"lt_posix_api.h\"</code></li> </ul>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#public-functions","title":"Public Functions","text":"Type Name     void hexdump (const uint8_t * buf, size_t len, uint32_t offset=0, uint8_t width=16) Print data pointed to by buf in hexdump-like format (hex+ASCII).   String ipToString (const IPAddress &amp; ip)    void lt_rand_bytes (uint8_t * buf, size_t len) Generate random bytes using rand()."},{"location":"ltapi/_libre_tuya_a_p_i_8h/#macros","title":"Macros","text":"Type Name     define LT_BANNER ()    define LT_BOARD  unknown   define LT_BOARD_STR  STRINGIFY_MACRO(LT_BOARD)   define LT_VERSION  1.0.0   define LT_VERSION_STR  STRINGIFY_MACRO(LT_VERSION)   define STRINGIFY (x) #x   define STRINGIFY_MACRO (x) STRINGIFY(x)"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_libre_tuya_a_p_i_8h/#function-hexdump","title":"function hexdump","text":"<p>Print data pointed to by buf in hexdump-like format (hex+ASCII). <pre><code>void hexdump (\n    const uint8_t * buf,\n    size_t len,\n    uint32_t offset=0,\n    uint8_t width=16\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> source pointer </li> <li><code>len</code> how many bytes to print </li> <li><code>offset</code> increment printed offset by this value </li> <li><code>width</code> how many bytes on a line </li> </ul>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#function-iptostring","title":"function ipToString","text":"<pre><code>String ipToString (\n    const IPAddress &amp; ip\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#function-lt_rand_bytes","title":"function lt_rand_bytes","text":"<p>Generate random bytes using rand(). <pre><code>void lt_rand_bytes (\n    uint8_t * buf,\n    size_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buf</code> destination pointer </li> <li><code>len</code> how many bytes to generate </li> </ul>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-lt_banner","title":"define LT_BANNER","text":"<pre><code>#define LT_BANNER (\n\n) LT_LOG(                                                                                                            \\\n        LT_LEVEL_INFO,                                                                                                 \\\n        __FUNCTION__,                                                                                                  \\\n        __LINE__,                                                                                                      \\\n        \"LibreTuya v\" LT_VERSION_STR \" on \" LT_BOARD_STR \", compiled at \" __DATE__ \" \" __TIME__                        \\\n    )\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-lt_board","title":"define LT_BOARD","text":"<pre><code>#define LT_BOARD unknown\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-lt_board_str","title":"define LT_BOARD_STR","text":"<pre><code>#define LT_BOARD_STR STRINGIFY_MACRO(LT_BOARD)\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-lt_version","title":"define LT_VERSION","text":"<pre><code>#define LT_VERSION 1.0.0\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-lt_version_str","title":"define LT_VERSION_STR","text":"<pre><code>#define LT_VERSION_STR STRINGIFY_MACRO(LT_VERSION)\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-stringify","title":"define STRINGIFY","text":"<pre><code>#define STRINGIFY (\n    x\n) #x\n</code></pre>"},{"location":"ltapi/_libre_tuya_a_p_i_8h/#define-stringify_macro","title":"define STRINGIFY_MACRO","text":"<pre><code>#define STRINGIFY_MACRO (\n    x\n) STRINGIFY(x)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaAPI.h</code></p>"},{"location":"ltapi/_libre_tuya_a_p_i_8h_source/","title":"File LibreTuyaAPI.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaAPI.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#pragma once\n\n// C standard libraries\n#include &lt;inttypes.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n// C++ standard libraries\n#ifdef __cplusplus\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\nusing ::round;\nusing std::abs;\nusing std::isinf;\nusing std::isnan;\nusing std::max;\nusing std::min;\n#endif\n\n// LibreTuya version macros\n#ifndef LT_VERSION\n#define LT_VERSION 1.0.0\n#endif\n#ifndef LT_BOARD\n#define LT_BOARD unknown\n#endif\n#define STRINGIFY(x)       #x\n#define STRINGIFY_MACRO(x) STRINGIFY(x)\n#define LT_VERSION_STR     STRINGIFY_MACRO(LT_VERSION)\n#define LT_BOARD_STR       STRINGIFY_MACRO(LT_BOARD)\n\n// Includes\n#include \"LibreTuyaClass.h\"  // global LT class\n#include \"LibreTuyaCompat.h\" // compatibility methods\n#include \"LibreTuyaConfig.h\" // configuration macros\n#include \"LibreTuyaCustom.h\" // family-defined methods (Wiring custom)\n#include &lt;Arduino.h&gt;\n\n// C includes\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\n#include \"lt_logger.h\"\n#include \"lt_posix_api.h\"\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n// Functional macros\n#define LT_BANNER()                                                                                                    \\\n    LT_LOG(                                                                                                            \\\n        LT_LEVEL_INFO,                                                                                                 \\\n        __FUNCTION__,                                                                                                  \\\n        __LINE__,                                                                                                      \\\n        \"LibreTuya v\" LT_VERSION_STR \" on \" LT_BOARD_STR \", compiled at \" __DATE__ \" \" __TIME__                        \\\n    )\n\n#ifdef __cplusplus\nString ipToString(const IPAddress &amp;ip);\n\nextern \"C\" {\nvoid lt_rand_bytes(uint8_t *buf, size_t len);\nvoid hexdump(const uint8_t *buf, size_t len, uint32_t offset = 0, uint8_t width = 16);\n}\n\n#else\n\nvoid lt_rand_bytes(uint8_t *buf, size_t len);\nvoid hexdump(const uint8_t *buf, size_t len, uint32_t offset, uint8_t width);\n\n#endif\n</code></pre>"},{"location":"ltapi/_libre_tuya_class_8cpp/","title":"File LibreTuyaClass.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaClass.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaClass.h\"</code></li> </ul>"},{"location":"ltapi/_libre_tuya_class_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     char * deviceName   = = NULL"},{"location":"ltapi/_libre_tuya_class_8cpp/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak)) Get flash chip total size. The default implementation uses the least significant byte of the chip ID to determine the size."},{"location":"ltapi/_libre_tuya_class_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/_libre_tuya_class_8cpp/#variable-devicename","title":"variable deviceName","text":"<pre><code>char* deviceName;\n</code></pre>"},{"location":"ltapi/_libre_tuya_class_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_libre_tuya_class_8cpp/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaClass.cpp</code></p>"},{"location":"ltapi/_libre_tuya_class_8cpp_source/","title":"File LibreTuyaClass.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaClass.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-06. */\n\n#include \"LibreTuyaClass.h\"\n\nconst char *LibreTuya::getVersion() {\n    return LT_VERSION_STR;\n}\n\nconst char *LibreTuya::getBoard() {\n    return LT_BOARD_STR;\n}\n\nChipFamily LibreTuya::getChipFamily() {\n    return FAMILY;\n}\n\nconst char *LibreTuya::getChipFamilyName() {\n    return STRINGIFY_MACRO(FAMILY) + 2;\n}\n\nstatic char *deviceName = NULL;\n\nconst char *LibreTuya::getDeviceName() {\n    if (deviceName)\n        return deviceName;\n    uint32_t chipId = getChipId();\n    uint8_t *id     = (uint8_t *)&amp;chipId;\n\n    const char *board = getBoard();\n    uint8_t boardLen  = strlen(board);\n    deviceName        = (char *)malloc(3 + boardLen + 1 + 6 + 1);\n\n    sprintf(deviceName, \"LT-%s-%02x%02x%02x\", board, id[0], id[1], id[2]);\n    return deviceName;\n}\n\nconst char *LibreTuya::getResetReasonName(ResetReason reason) {\n    if (reason &gt;= RESET_REASON_MAX)\n        reason = getResetReason();\n    switch (reason) {\n        case RESET_REASON_POWER:\n            return \"Power-On\";\n        case RESET_REASON_BROWNOUT:\n            return \"Brownout\";\n        case RESET_REASON_HARDWARE:\n            return \"HW Reboot\";\n        case RESET_REASON_SOFTWARE:\n            return \"SW Reboot\";\n        case RESET_REASON_WATCHDOG:\n            return \"WDT Reset\";\n        case RESET_REASON_CRASH:\n            return \"Crash\";\n        case RESET_REASON_SLEEP:\n            return \"Sleep Wakeup\";\n    }\n    return \"Unknown\";\n}\n\nuint32_t LibreTuya::getCpuFreqMHz() {\n    return getCpuFreq() / 1000000;\n}\n\n__attribute__((weak)) uint32_t LibreTuya::getFlashChipSize() {\n    FlashId id = getFlashChipId();\n    if (id.chipSizeId &gt;= 0x14 &amp;&amp; id.chipSizeId &lt;= 0x19) {\n        return (1 &lt;&lt; id.chipSizeId);\n    }\n#ifdef FLASH_LENGTH\n    return FLASH_LENGTH;\n#else\n    return 0;\n#endif\n}\n\nuint8_t LibreTuya::otaGetTarget() {\n    if (!otaSupportsDual())\n        return 1;\n    return otaGetRunning() ^ 0b11;\n}\n\nbool LibreTuya::otaRollback() {\n    if (!otaCanRollback())\n        return false;\n    if (otaGetRunning() != otaGetStoredIndex())\n        // force switching back to current image\n        return otaSwitch(true);\n    return true;\n}\n\nbool LibreTuya::otaCanRollback() {\n    if (!otaSupportsDual())\n        return false;\n    if (otaGetRunning() == otaGetStoredIndex())\n        return true;\n    if (otaGetRunning() == 1 &amp;&amp; otaHasImage1())\n        return true;\n    if (otaGetRunning() == 2 &amp;&amp; otaHasImage2())\n        return true;\n    return false;\n}\n\n__attribute__((weak)) void LibreTuya::gpioRecover() {\n    // nop by default\n}\n</code></pre>"},{"location":"ltapi/_libre_tuya_class_8h/","title":"File LibreTuyaClass.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaClass.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaAPI.h\"</code></li> <li><code>#include &lt;core/ChipType.h&gt;</code></li> </ul>"},{"location":"ltapi/_libre_tuya_class_8h/#classes","title":"Classes","text":"Type Name     struct FlashId Flash chip ID structure.   class LibreTuya Main LibreTuya API class."},{"location":"ltapi/_libre_tuya_class_8h/#public-types","title":"Public Types","text":"Type Name     enum ResetReason"},{"location":"ltapi/_libre_tuya_class_8h/#public-attributes","title":"Public Attributes","text":"Type Name     LibreTuya ESP    LibreTuya LT"},{"location":"ltapi/_libre_tuya_class_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_libre_tuya_class_8h/#enum-resetreason","title":"enum ResetReason","text":"<pre><code>enum ResetReason {\n    RESET_REASON_UNKNOWN = 0,\n    RESET_REASON_POWER = 1,\n    RESET_REASON_BROWNOUT = 2,\n    RESET_REASON_HARDWARE = 3,\n    RESET_REASON_SOFTWARE = 4,\n    RESET_REASON_WATCHDOG = 5,\n    RESET_REASON_CRASH = 6,\n    RESET_REASON_SLEEP = 7,\n    RESET_REASON_MAX = 8\n};\n</code></pre>"},{"location":"ltapi/_libre_tuya_class_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_libre_tuya_class_8h/#variable-esp","title":"variable ESP","text":"<pre><code>LibreTuya ESP;\n</code></pre>"},{"location":"ltapi/_libre_tuya_class_8h/#variable-lt","title":"variable LT","text":"<pre><code>LibreTuya LT;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaClass.h</code></p>"},{"location":"ltapi/_libre_tuya_class_8h_source/","title":"File LibreTuyaClass.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaClass.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-06. */\n\n#pragma once\n\n#ifdef __cplusplus\n\n#include \"LibreTuyaAPI.h\"\n#include &lt;core/ChipType.h&gt;\n\ntypedef enum {\n    RESET_REASON_UNKNOWN  = 0,\n    RESET_REASON_POWER    = 1,\n    RESET_REASON_BROWNOUT = 2,\n    RESET_REASON_HARDWARE = 3,\n    RESET_REASON_SOFTWARE = 4,\n    RESET_REASON_WATCHDOG = 5,\n    RESET_REASON_CRASH    = 6,\n    RESET_REASON_SLEEP    = 7,\n    RESET_REASON_MAX      = 8,\n} ResetReason;\n\ntypedef struct {\n    uint8_t manufacturerId;\n    uint8_t chipId;\n    uint8_t chipSizeId;\n} FlashId;\n\nclass LibreTuya {\n  public: /* Common methods - note: these are documented in LibreTuyaAPI.cpp */\n    const char *getVersion();\n    const char *getBoard();\n    ChipFamily getChipFamily();\n    const char *getChipFamilyName();\n    const char *getDeviceName();\n    const char *getResetReasonName(ResetReason reason = RESET_REASON_MAX);\n    uint32_t getCpuFreqMHz();\n    uint32_t getFlashChipSize();\n    uint8_t otaGetTarget();\n    bool otaRollback();\n    bool otaCanRollback();\n\n  public: /* Compatibility methods */\n    inline uint32_t getMaxFreeBlockSize() {\n        return getMaxAllocHeap();\n    }\n\n  public: /* Family-defined methods */\n    void restart();\n    void restartDownloadMode();\n    ResetReason getResetReason();\n    void gpioRecover();\n\n  public: /* CPU-related */\n    ChipType getChipType();\n    const char *getChipModel();\n    uint32_t getChipId();\n    uint8_t getChipCores();\n    const char *getChipCoreType();\n    uint32_t getCpuFreq();\n    uint32_t getCycleCount();\n\n  public: /* Flash memory utilities */\n    FlashId getFlashChipId();\n\n  public: /* Memory management */\n    uint32_t getRamSize();\n    uint32_t getHeapSize();\n    uint32_t getFreeHeap();\n    uint32_t getMinFreeHeap();\n    uint32_t getMaxAllocHeap();\n\n  public: /* OTA-related */\n    uint8_t otaGetRunning();\n    uint8_t otaGetStoredIndex();\n    bool otaSupportsDual();\n    bool otaHasImage1();\n    bool otaHasImage2();\n    bool otaSwitch(bool force = false);\n\n  public: /* Watchdog */\n    bool wdtEnable(uint32_t timeout = 10000);\n    void wdtDisable();\n    void wdtFeed();\n};\n\nextern LibreTuya LT;\nextern LibreTuya ESP;\n\n#endif\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8cpp/","title":"File LibreTuyaCompat.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCompat.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaCompat.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaCompat.cpp</code></p>"},{"location":"ltapi/_libre_tuya_compat_8cpp_source/","title":"File LibreTuyaCompat.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCompat.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-04. */\n\n#include \"LibreTuyaCompat.h\"\n\n#if LT_HAS_FREERTOS\nBaseType_t xTaskCreateUniversal(\n    TaskFunction_t pxTaskCode,\n    const char *const pcName,\n    const uint32_t usStackDepth,\n    void *const pvParameters,\n    UBaseType_t uxPriority,\n    TaskHandle_t *const pxCreatedTask,\n    const BaseType_t xCoreID\n) {\n    // #ifndef CONFIG_FREERTOS_UNICORE\n    //  if (xCoreID &gt;= 0 &amp;&amp; xCoreID &lt; 2) {\n    //      return xTaskCreatePinnedToCore(\n    //          pxTaskCode,\n    //          pcName,\n    //          usStackDepth,\n    //          pvParameters,\n    //          uxPriority,\n    //          pxCreatedTask,\n    //          xCoreID\n    //      );\n    //  } else {\n    // #endif\n    return xTaskCreate(pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask);\n    // #ifndef CONFIG_FREERTOS_UNICORE\n    //  }\n    // #endif\n}\n#endif\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/","title":"File LibreTuyaCompat.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCompat.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_libre_tuya_compat_8h/#macros","title":"Macros","text":"Type Name     define CONFIG_LWIP_MAX_ACTIVE_TCP  16   define ESP_FAIL  -1   define ESP_OK  0   define FPSTR (pstr_pointer) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))   define OUTPUT_OPEN_DRAIN  OUTPUT_OPENDRAIN   define PGM_VOID_P  const void *   define attachInterruptArg  attachInterruptParam   define esp_err_t  int   define voidFuncPtrArg  voidFuncPtrParam   define vsnprintf_P  vsnprintf"},{"location":"ltapi/_libre_tuya_compat_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_libre_tuya_compat_8h/#define-config_lwip_max_active_tcp","title":"define CONFIG_LWIP_MAX_ACTIVE_TCP","text":"<pre><code>#define CONFIG_LWIP_MAX_ACTIVE_TCP 16\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-esp_fail","title":"define ESP_FAIL","text":"<pre><code>#define ESP_FAIL -1\n</code></pre> <p>Generic esp_err_t code indicating failure </p>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-esp_ok","title":"define ESP_OK","text":"<pre><code>#define ESP_OK 0\n</code></pre> <p>esp_err_t value indicating success (no error) </p>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-fpstr","title":"define FPSTR","text":"<pre><code>#define FPSTR (\n    pstr_pointer\n) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-output_open_drain","title":"define OUTPUT_OPEN_DRAIN","text":"<pre><code>#define OUTPUT_OPEN_DRAIN OUTPUT_OPENDRAIN\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-pgm_void_p","title":"define PGM_VOID_P","text":"<pre><code>#define PGM_VOID_P const void *\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-attachinterruptarg","title":"define attachInterruptArg","text":"<pre><code>#define attachInterruptArg attachInterruptParam\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-esp_err_t","title":"define esp_err_t","text":"<pre><code>#define esp_err_t int\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-voidfuncptrarg","title":"define voidFuncPtrArg","text":"<pre><code>#define voidFuncPtrArg voidFuncPtrParam\n</code></pre>"},{"location":"ltapi/_libre_tuya_compat_8h/#define-vsnprintf_p","title":"define vsnprintf_P","text":"<pre><code>#define vsnprintf_P vsnprintf\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaCompat.h</code></p>"},{"location":"ltapi/_libre_tuya_compat_8h_source/","title":"File LibreTuyaCompat.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCompat.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-04. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#if LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#include &lt;task.h&gt;\n#endif\n\n// Definitions for error constants.\n#define esp_err_t int\n#define ESP_OK    0  \n#define ESP_FAIL  -1 \n// ArduinoCore-API doesn't define these anymore\n#define FPSTR(pstr_pointer) (reinterpret_cast&lt;const __FlashStringHelper *&gt;(pstr_pointer))\n#define PGM_VOID_P          const void *\n#define vsnprintf_P         vsnprintf\n#define OUTPUT_OPEN_DRAIN   OUTPUT_OPENDRAIN\n#define attachInterruptArg  attachInterruptParam\n#define voidFuncPtrArg      voidFuncPtrParam\n\n// FreeRTOS utilities\n#if LT_HAS_FREERTOS\n// if xCoreID &lt; 0 or CPU is unicore, it will use xTaskCreate, else xTaskCreatePinnedToCore\n// allows to easily handle all possible situations without repetitive code\nBaseType_t xTaskCreateUniversal(\n    TaskFunction_t pxTaskCode,\n    const char *const pcName,\n    const uint32_t usStackDepth,\n    void *const pvParameters,\n    UBaseType_t uxPriority,\n    TaskHandle_t *const pxCreatedTask,\n    const BaseType_t xCoreID\n);\n#define xTaskCreatePinnedToCore xTaskCreateUniversal\n#endif\n\n// Default values from sdkconfig.h\n#define CONFIG_LWIP_MAX_ACTIVE_TCP 16\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/","title":"File LibreTuyaConfig.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaConfig.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_libre_tuya_config_8h/#macros","title":"Macros","text":"Type Name     define LT_AUTO_DOWNLOAD_REBOOT  1   define LT_DEBUG_ALL  0   define LT_DEBUG_CLIENT  LT_DEBUG_ALL   define LT_DEBUG_FDB  0   define LT_DEBUG_LWIP  0   define LT_DEBUG_LWIP_ASSERT  0   define LT_DEBUG_MDNS  LT_DEBUG_ALL   define LT_DEBUG_OTA  1   define LT_DEBUG_SERVER  LT_DEBUG_ALL   define LT_DEBUG_SSL  LT_DEBUG_ALL   define LT_DEBUG_WIFI  1   define LT_LEVEL_DEBUG  1   define LT_LEVEL_ERROR  4   define LT_LEVEL_FATAL  5   define LT_LEVEL_INFO  2   define LT_LEVEL_NONE  6   define LT_LEVEL_TRACE  0   define LT_LEVEL_VERBOSE  LT_LEVEL_TRACE   define LT_LEVEL_WARN  3   define LT_LOGGER  1   define LT_LOGGER_CALLER  0   define LT_LOGGER_COLOR  0   define LT_LOGGER_TASK  0   define LT_LOGGER_TIMESTAMP  1   define LT_LOGLEVEL  LT_LEVEL_INFO   define LT_LOG_ERRNO  0   define LT_LOG_HEAP  0   define LT_MICROS_HIGH_RES  1   define LT_PRINTF_BROKEN  0   define LT_UART_DEFAULT_LOGGER  LT_UART_DEFAULT_PORT   define LT_UART_DEFAULT_SERIAL  LT_UART_DEFAULT_PORT   define LT_UART_SILENT_ALL  0   define LT_UART_SILENT_ENABLED  1   define LT_USE_TIME  0"},{"location":"ltapi/_libre_tuya_config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_auto_download_reboot","title":"define LT_AUTO_DOWNLOAD_REBOOT","text":"<pre><code>#define LT_AUTO_DOWNLOAD_REBOOT 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_all","title":"define LT_DEBUG_ALL","text":"<pre><code>#define LT_DEBUG_ALL 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_client","title":"define LT_DEBUG_CLIENT","text":"<pre><code>#define LT_DEBUG_CLIENT LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_fdb","title":"define LT_DEBUG_FDB","text":"<pre><code>#define LT_DEBUG_FDB 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_lwip","title":"define LT_DEBUG_LWIP","text":"<pre><code>#define LT_DEBUG_LWIP 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_lwip_assert","title":"define LT_DEBUG_LWIP_ASSERT","text":"<pre><code>#define LT_DEBUG_LWIP_ASSERT 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_mdns","title":"define LT_DEBUG_MDNS","text":"<pre><code>#define LT_DEBUG_MDNS LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_ota","title":"define LT_DEBUG_OTA","text":"<pre><code>#define LT_DEBUG_OTA 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_server","title":"define LT_DEBUG_SERVER","text":"<pre><code>#define LT_DEBUG_SERVER LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_ssl","title":"define LT_DEBUG_SSL","text":"<pre><code>#define LT_DEBUG_SSL LT_DEBUG_ALL\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_debug_wifi","title":"define LT_DEBUG_WIFI","text":"<pre><code>#define LT_DEBUG_WIFI 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_debug","title":"define LT_LEVEL_DEBUG","text":"<pre><code>#define LT_LEVEL_DEBUG 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_error","title":"define LT_LEVEL_ERROR","text":"<pre><code>#define LT_LEVEL_ERROR 4\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_fatal","title":"define LT_LEVEL_FATAL","text":"<pre><code>#define LT_LEVEL_FATAL 5\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_info","title":"define LT_LEVEL_INFO","text":"<pre><code>#define LT_LEVEL_INFO 2\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_none","title":"define LT_LEVEL_NONE","text":"<pre><code>#define LT_LEVEL_NONE 6\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_trace","title":"define LT_LEVEL_TRACE","text":"<pre><code>#define LT_LEVEL_TRACE 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_verbose","title":"define LT_LEVEL_VERBOSE","text":"<pre><code>#define LT_LEVEL_VERBOSE LT_LEVEL_TRACE\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_level_warn","title":"define LT_LEVEL_WARN","text":"<pre><code>#define LT_LEVEL_WARN 3\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_logger","title":"define LT_LOGGER","text":"<pre><code>#define LT_LOGGER 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_logger_caller","title":"define LT_LOGGER_CALLER","text":"<pre><code>#define LT_LOGGER_CALLER 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_logger_color","title":"define LT_LOGGER_COLOR","text":"<pre><code>#define LT_LOGGER_COLOR 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_logger_task","title":"define LT_LOGGER_TASK","text":"<pre><code>#define LT_LOGGER_TASK 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_logger_timestamp","title":"define LT_LOGGER_TIMESTAMP","text":"<pre><code>#define LT_LOGGER_TIMESTAMP 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_loglevel","title":"define LT_LOGLEVEL","text":"<pre><code>#define LT_LOGLEVEL LT_LEVEL_INFO\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_log_errno","title":"define LT_LOG_ERRNO","text":"<pre><code>#define LT_LOG_ERRNO 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_log_heap","title":"define LT_LOG_HEAP","text":"<pre><code>#define LT_LOG_HEAP 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_micros_high_res","title":"define LT_MICROS_HIGH_RES","text":"<pre><code>#define LT_MICROS_HIGH_RES 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_printf_broken","title":"define LT_PRINTF_BROKEN","text":"<pre><code>#define LT_PRINTF_BROKEN 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_uart_default_logger","title":"define LT_UART_DEFAULT_LOGGER","text":"<pre><code>#define LT_UART_DEFAULT_LOGGER LT_UART_DEFAULT_PORT\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_uart_default_serial","title":"define LT_UART_DEFAULT_SERIAL","text":"<pre><code>#define LT_UART_DEFAULT_SERIAL LT_UART_DEFAULT_PORT\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_uart_silent_all","title":"define LT_UART_SILENT_ALL","text":"<pre><code>#define LT_UART_SILENT_ALL 0\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_uart_silent_enabled","title":"define LT_UART_SILENT_ENABLED","text":"<pre><code>#define LT_UART_SILENT_ENABLED 1\n</code></pre>"},{"location":"ltapi/_libre_tuya_config_8h/#define-lt_use_time","title":"define LT_USE_TIME","text":"<pre><code>#define LT_USE_TIME 0\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaConfig.h</code></p>"},{"location":"ltapi/_libre_tuya_config_8h_source/","title":"File LibreTuyaConfig.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaConfig.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#pragma once\n\n// see docs/API Configuration\n\n// Loglevels\n#define LT_LEVEL_VERBOSE LT_LEVEL_TRACE\n#define LT_LEVEL_TRACE   0\n#define LT_LEVEL_DEBUG   1\n#define LT_LEVEL_INFO    2\n#define LT_LEVEL_WARN    3\n#define LT_LEVEL_ERROR   4\n#define LT_LEVEL_FATAL   5\n#define LT_LEVEL_NONE    6\n\n// Logger enabled/disabled\n#ifndef LT_LOGGER\n#define LT_LOGGER 1\n#endif\n\n// Logger format options\n#ifndef LT_LOGGER_TIMESTAMP\n#define LT_LOGGER_TIMESTAMP 1\n#endif\n\n#ifndef LT_LOGGER_CALLER\n#define LT_LOGGER_CALLER 0\n#endif\n\n#ifndef LT_LOGGER_TASK\n#define LT_LOGGER_TASK 0\n#endif\n\n#ifndef LT_LOGGER_COLOR\n#define LT_LOGGER_COLOR 0\n#endif\n\n#ifndef LT_PRINTF_BROKEN\n#define LT_PRINTF_BROKEN 0\n#endif\n\n// Global loglevel\n#ifndef LT_LOGLEVEL\n#define LT_LOGLEVEL LT_LEVEL_INFO\n#endif\n\n#if !LT_LOGGER\n#undef LT_LOGLEVEL\n#define LT_LOGLEVEL LT_LEVEL_NONE\n#endif\n\n// Free heap size debugging\n#ifndef LT_LOG_HEAP\n#define LT_LOG_HEAP 0\n#endif\n\n// Debug errno values using LT_ERRNO()\n#ifndef LT_LOG_ERRNO\n#define LT_LOG_ERRNO 0\n#endif\n\n// Serial output options\n#ifndef LT_UART_SILENT_ENABLED\n#define LT_UART_SILENT_ENABLED 1\n#endif\n\n#ifndef LT_UART_SILENT_ALL\n#define LT_UART_SILENT_ALL 0\n#endif\n\n#ifndef LT_UART_DEFAULT_LOGGER\n#define LT_UART_DEFAULT_LOGGER LT_UART_DEFAULT_PORT\n#endif\n\n#ifndef LT_UART_DEFAULT_SERIAL\n#define LT_UART_DEFAULT_SERIAL LT_UART_DEFAULT_PORT\n#endif\n\n// Misc options\n#ifndef LT_USE_TIME\n#define LT_USE_TIME 0\n#endif\n\n#ifndef LT_MICROS_HIGH_RES // NOTE: this is also defined in fixups/clock_rtos.c\n#define LT_MICROS_HIGH_RES 1\n#endif\n\n#ifndef LT_AUTO_DOWNLOAD_REBOOT\n#define LT_AUTO_DOWNLOAD_REBOOT 1\n#endif\n\n// Per-module logging output - applies to all loglevels\n#ifndef LT_DEBUG_ALL\n#define LT_DEBUG_ALL 0\n#endif\n\n#ifndef LT_DEBUG_WIFI\n#define LT_DEBUG_WIFI 1\n#endif\n\n#ifndef LT_DEBUG_CLIENT\n#define LT_DEBUG_CLIENT LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_SERVER\n#define LT_DEBUG_SERVER LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_SSL\n#define LT_DEBUG_SSL LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_OTA\n#define LT_DEBUG_OTA 1\n#endif\n\n#ifndef LT_DEBUG_FDB\n#define LT_DEBUG_FDB 0\n#endif\n\n#ifndef LT_DEBUG_MDNS\n#define LT_DEBUG_MDNS LT_DEBUG_ALL\n#endif\n\n#ifndef LT_DEBUG_LWIP\n#define LT_DEBUG_LWIP 0\n#endif\n\n#ifndef LT_DEBUG_LWIP_ASSERT\n#define LT_DEBUG_LWIP_ASSERT 0\n#endif\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/","title":"File LibreTuyaCustom.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCustom.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaCustom.h\"</code></li> </ul>"},{"location":"ltapi/_libre_tuya_custom_8c/#public-attributes","title":"Public Attributes","text":"Type Name     int _analogReadResolution   = = 10   int _analogWritePeriod   = = 20000   int _analogWriteResolution   = = 8"},{"location":"ltapi/_libre_tuya_custom_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))    int analogRead (pin_size_t pinNumber) Read voltage from ADC and return a value between 0 and the current reading resolution.   void analogReadResolution (int res) Set resolution of values (in bits) returned by analogRead(). Defaults to 10 bit (0-1023).   void analogWriteFrequency (int hz) Set PWM output frequency (in Hz). Defaults to 50 Hz (20,000 uS).   void analogWritePeriod (int us) Set PWM output frequency (cycle period) in microseconds. Defaults to 20,000 uS (50 Hz).   void analogWriteResolution (int res) Set resolution of values (in bits) expected by analogWrite(). Defaults to 8 bit (0-255).   bool pinEnabled (PinInfo * pin, uint32_t mask) Check if pin has all features represented by 'mask' enabled.   PinInfo * pinInfo (pin_size_t pinNumber) Get PinInfo struct for the specified number. Returns NULL if pin number is invalid.   bool pinInvalid (pin_size_t pinNumber) Check if pin is invalid (too low or too high).   bool pinIsInput (PinInfo * pin) Check if GPIO pin is configured as output.   bool pinIsOutput (PinInfo * pin) Check if GPIO pin is configured as output.   bool pinSupported (PinInfo * pin, uint32_t mask) Check if pin supports all features represented by 'mask'."},{"location":"ltapi/_libre_tuya_custom_8c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_libre_tuya_custom_8c/#variable-_analogreadresolution","title":"variable _analogReadResolution","text":"<pre><code>int _analogReadResolution;\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#variable-_analogwriteperiod","title":"variable _analogWritePeriod","text":"<pre><code>int _analogWritePeriod;\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#variable-_analogwriteresolution","title":"variable _analogWriteResolution","text":"<pre><code>int _analogWriteResolution;\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_libre_tuya_custom_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-analogread","title":"function analogRead","text":"<pre><code>int analogRead (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-analogreadresolution","title":"function analogReadResolution","text":"<pre><code>void analogReadResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-analogwritefrequency","title":"function analogWriteFrequency","text":"<pre><code>void analogWriteFrequency (\n    int hz\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-analogwriteperiod","title":"function analogWritePeriod","text":"<pre><code>void analogWritePeriod (\n    int us\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-analogwriteresolution","title":"function analogWriteResolution","text":"<pre><code>void analogWriteResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-pinenabled","title":"function pinEnabled","text":"<pre><code>bool pinEnabled (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-pininfo","title":"function pinInfo","text":"<pre><code>PinInfo * pinInfo (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-pininvalid","title":"function pinInvalid","text":"<pre><code>bool pinInvalid (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-pinisinput","title":"function pinIsInput","text":"<pre><code>bool pinIsInput (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-pinisoutput","title":"function pinIsOutput","text":"<pre><code>bool pinIsOutput (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8c/#function-pinsupported","title":"function pinSupported","text":"<pre><code>bool pinSupported (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaCustom.c</code></p>"},{"location":"ltapi/_libre_tuya_custom_8c_source/","title":"File LibreTuyaCustom.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCustom.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-20. */\n\n#include \"LibreTuyaCustom.h\"\n\nint _analogReadResolution  = 10;    // 0-1023\nint _analogWriteResolution = 8;     // 0-255\nint _analogWritePeriod     = 20000; // 50 Hz\n\nbool pinInvalid(pin_size_t pinNumber) {\n#ifdef PINS_COUNT\n    return pinNumber &lt; 0 || pinNumber &gt;= PINS_COUNT;\n#else\n    return false;\n#endif\n}\n\nPinInfo *pinInfo(pin_size_t pinNumber) {\n    if (pinInvalid(pinNumber))\n        return NULL;\n    return &amp;(pinTable[pinNumber]);\n}\n\nbool pinSupported(PinInfo *pin, uint32_t mask) {\n    return (pin-&gt;supported &amp; mask) == mask;\n}\n\nbool pinEnabled(PinInfo *pin, uint32_t mask) {\n    return (pin-&gt;enabled &amp; mask) == mask;\n}\n\nbool pinIsOutput(PinInfo *pin) {\n    return pin-&gt;mode == OUTPUT || pin-&gt;mode == OUTPUT_OPENDRAIN;\n}\n\nbool pinIsInput(PinInfo *pin) {\n    return pin-&gt;mode == INPUT || pin-&gt;mode == INPUT_PULLUP || pin-&gt;mode == INPUT_PULLDOWN;\n}\n\nint analogRead(pin_size_t pinNumber) {\n    float voltage    = analogReadVoltage(pinNumber);\n    float maxVoltage = analogReadMaxVoltage(pinNumber);\n    uint16_t ret     = round((1 &lt;&lt; _analogReadResolution) * voltage / maxVoltage);\n    if (ret &gt;= (1 &lt;&lt; _analogReadResolution))\n        ret = (1 &lt;&lt; _analogReadResolution) - 1;\n    return ret;\n}\n\nvoid analogReadResolution(int res) {\n    _analogReadResolution = res;\n}\n\nvoid analogWriteResolution(int res) {\n    _analogWriteResolution = res;\n}\n\nvoid analogWriteFrequency(int hz) {\n    _analogWritePeriod = 1E6 / hz;\n}\n\nvoid analogWritePeriod(int us) {\n    _analogWritePeriod = us;\n}\n\n__attribute__((weak)) void analogReference(uint8_t mode) {}\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/","title":"File LibreTuyaCustom.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCustom.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaAPI.h\"</code></li> </ul>"},{"location":"ltapi/_libre_tuya_custom_8h/#classes","title":"Classes","text":"Type Name     struct PinInfo"},{"location":"ltapi/_libre_tuya_custom_8h/#public-attributes","title":"Public Attributes","text":"Type Name     int _analogReadResolution    int _analogWritePeriod    int _analogWriteResolution    PinInfo pinTable"},{"location":"ltapi/_libre_tuya_custom_8h/#public-functions","title":"Public Functions","text":"Type Name     int analogRead (pin_size_t pinNumber) Read voltage from ADC and return a value between 0 and the current reading resolution.   uint16_t analogReadMaxVoltage (pin_size_t pinNumber) Get max reading voltage for the specified pin (millivolts).   void analogReadResolution (int res) Set resolution of values (in bits) returned by analogRead(). Defaults to 10 bit (0-1023).   uint16_t analogReadVoltage (pin_size_t pinNumber) Read voltage from analog input (in millivolts).   void analogWriteFrequency (int hz) Set PWM output frequency (in Hz). Defaults to 50 Hz (20,000 uS).   void analogWritePeriod (int us) Set PWM output frequency (cycle period) in microseconds. Defaults to 20,000 uS (50 Hz).   void analogWriteResolution (int res) Set resolution of values (in bits) expected by analogWrite(). Defaults to 8 bit (0-255).   void mainTask (const void * arg) Main setup() and loop() task. Not to be called directly.   bool pinEnabled (PinInfo * pin, uint32_t mask) Check if pin has all features represented by 'mask' enabled.   PinInfo * pinInfo (pin_size_t pinNumber) Get PinInfo struct for the specified number. Returns NULL if pin number is invalid.   bool pinInvalid (pin_size_t pinNumber) Check if pin is invalid (too low or too high).   bool pinIsInput (PinInfo * pin) Check if GPIO pin is configured as output.   bool pinIsOutput (PinInfo * pin) Check if GPIO pin is configured as output.   bool pinSupported (PinInfo * pin, uint32_t mask) Check if pin supports all features represented by 'mask'.   void runPeriodicTasks () Run periodic tasks, like printing free heap or checking millis() overflow.   bool startMainTask () Run mainTask &amp; start OS kernel (family-defined). Return false if an error occured; else do not return and and keep the OS kernel running."},{"location":"ltapi/_libre_tuya_custom_8h/#macros","title":"Macros","text":"Type Name     define PIN_ADC  (1 &lt;&lt; 4)   define PIN_DAC  (1 &lt;&lt; 5)   define PIN_GPIO  (1 &lt;&lt; 1)   define PIN_I2C  (1 &lt;&lt; 6)   define PIN_I2S  (1 &lt;&lt; 7)   define PIN_IRQ  (1 &lt;&lt; 2)   define PIN_JTAG  (1 &lt;&lt; 8)   define PIN_NONE  (1 &lt;&lt; 0)   define PIN_PWM  (1 &lt;&lt; 3)   define PIN_SPI  (1 &lt;&lt; 9)   define PIN_SWD  (1 &lt;&lt; 10)   define PIN_UART  (1 &lt;&lt; 11)"},{"location":"ltapi/_libre_tuya_custom_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_libre_tuya_custom_8h/#variable-_analogreadresolution","title":"variable _analogReadResolution","text":"<pre><code>int _analogReadResolution;\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#variable-_analogwriteperiod","title":"variable _analogWritePeriod","text":"<pre><code>int _analogWritePeriod;\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#variable-_analogwriteresolution","title":"variable _analogWriteResolution","text":"<pre><code>int _analogWriteResolution;\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#variable-pintable","title":"variable pinTable","text":"<pre><code>PinInfo pinTable[];\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogread","title":"function analogRead","text":"<pre><code>int analogRead (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogreadmaxvoltage","title":"function analogReadMaxVoltage","text":"<pre><code>uint16_t analogReadMaxVoltage (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogreadresolution","title":"function analogReadResolution","text":"<pre><code>void analogReadResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogreadvoltage","title":"function analogReadVoltage","text":"<pre><code>uint16_t analogReadVoltage (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogwritefrequency","title":"function analogWriteFrequency","text":"<pre><code>void analogWriteFrequency (\n    int hz\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogwriteperiod","title":"function analogWritePeriod","text":"<pre><code>void analogWritePeriod (\n    int us\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-analogwriteresolution","title":"function analogWriteResolution","text":"<pre><code>void analogWriteResolution (\n    int res\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-maintask","title":"function mainTask","text":"<pre><code>void mainTask (\n    const void * arg\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-pinenabled","title":"function pinEnabled","text":"<pre><code>bool pinEnabled (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-pininfo","title":"function pinInfo","text":"<pre><code>PinInfo * pinInfo (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-pininvalid","title":"function pinInvalid","text":"<pre><code>bool pinInvalid (\n    pin_size_t pinNumber\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-pinisinput","title":"function pinIsInput","text":"<pre><code>bool pinIsInput (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-pinisoutput","title":"function pinIsOutput","text":"<pre><code>bool pinIsOutput (\n    PinInfo * pin\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-pinsupported","title":"function pinSupported","text":"<pre><code>bool pinSupported (\n    PinInfo * pin,\n    uint32_t mask\n) \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-runperiodictasks","title":"function runPeriodicTasks","text":"<p>Run periodic tasks, like printing free heap or checking millis() overflow. <pre><code>void runPeriodicTasks () \n</code></pre></p> <p>This is called during delaying operations, like yield() or delay(). </p>"},{"location":"ltapi/_libre_tuya_custom_8h/#function-startmaintask","title":"function startMainTask","text":"<pre><code>bool startMainTask () \n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_adc","title":"define PIN_ADC","text":"<pre><code>#define PIN_ADC (1 &lt;&lt; 4)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_dac","title":"define PIN_DAC","text":"<pre><code>#define PIN_DAC (1 &lt;&lt; 5)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_gpio","title":"define PIN_GPIO","text":"<pre><code>#define PIN_GPIO (1 &lt;&lt; 1)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_i2c","title":"define PIN_I2C","text":"<pre><code>#define PIN_I2C (1 &lt;&lt; 6)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_i2s","title":"define PIN_I2S","text":"<pre><code>#define PIN_I2S (1 &lt;&lt; 7)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_irq","title":"define PIN_IRQ","text":"<pre><code>#define PIN_IRQ (1 &lt;&lt; 2)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_jtag","title":"define PIN_JTAG","text":"<pre><code>#define PIN_JTAG (1 &lt;&lt; 8)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_none","title":"define PIN_NONE","text":"<pre><code>#define PIN_NONE (1 &lt;&lt; 0)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_pwm","title":"define PIN_PWM","text":"<pre><code>#define PIN_PWM (1 &lt;&lt; 3)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_spi","title":"define PIN_SPI","text":"<pre><code>#define PIN_SPI (1 &lt;&lt; 9)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_swd","title":"define PIN_SWD","text":"<pre><code>#define PIN_SWD (1 &lt;&lt; 10)\n</code></pre>"},{"location":"ltapi/_libre_tuya_custom_8h/#define-pin_uart","title":"define PIN_UART","text":"<pre><code>#define PIN_UART (1 &lt;&lt; 11)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/LibreTuyaCustom.h</code></p>"},{"location":"ltapi/_libre_tuya_custom_8h_source/","title":"File LibreTuyaCustom.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; LibreTuyaCustom.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-06. */\n\n#pragma once\n\n#include \"LibreTuyaAPI.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern bool startMainTask();\n\nextern void mainTask(const void *arg);\n\nextern void runPeriodicTasks();\n\n#define PIN_NONE (1 &lt;&lt; 0)\n#define PIN_GPIO (1 &lt;&lt; 1)\n#define PIN_IRQ  (1 &lt;&lt; 2)\n#define PIN_PWM  (1 &lt;&lt; 3)\n#define PIN_ADC  (1 &lt;&lt; 4)\n#define PIN_DAC  (1 &lt;&lt; 5)\n#define PIN_I2C  (1 &lt;&lt; 6)\n#define PIN_I2S  (1 &lt;&lt; 7)\n#define PIN_JTAG (1 &lt;&lt; 8)\n#define PIN_SPI  (1 &lt;&lt; 9)\n#define PIN_SWD  (1 &lt;&lt; 10)\n#define PIN_UART (1 &lt;&lt; 11)\n\ntypedef struct {\n    uint32_t gpio;\n    uint32_t supported;\n    uint32_t enabled;\n    uint32_t mode;\n} PinInfo;\n\nextern PinInfo pinTable[];\n\n// Custom Wiring methods\n\nbool pinInvalid(pin_size_t pinNumber);\nPinInfo *pinInfo(pin_size_t pinNumber);\nbool pinSupported(PinInfo *pin, uint32_t mask);\nbool pinEnabled(PinInfo *pin, uint32_t mask);\nbool pinIsOutput(PinInfo *pin);\nbool pinIsInput(PinInfo *pin);\n\nint analogRead(pin_size_t pinNumber);\nvoid analogReadResolution(int res);\nvoid analogWriteResolution(int res);\nvoid analogWriteFrequency(int hz);\nvoid analogWritePeriod(int us);\n\nextern int _analogReadResolution;\nextern int _analogWriteResolution;\nextern int _analogWritePeriod;\n\nuint16_t analogReadVoltage(pin_size_t pinNumber);\n\nuint16_t analogReadMaxVoltage(pin_size_t pinNumber);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/_serial_extern_8h/","title":"File SerialExtern.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; SerialExtern.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/SerialExtern.h</code></p>"},{"location":"ltapi/_serial_extern_8h_source/","title":"File SerialExtern.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; SerialExtern.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-04. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\n#ifdef HAS_SERIAL_CLASS // failsafe for circular inclusion\n\n#ifdef PIN_SERIAL0_TX\nextern SerialClass Serial0;\n#endif\n\n#ifdef PIN_SERIAL1_TX\nextern SerialClass Serial1;\n#endif\n\n#ifdef PIN_SERIAL2_TX\nextern SerialClass Serial2;\n#endif\n\n#define SerialN(x) Serial##x\n#define SerialM(x) SerialN(x)\n#define Serial     SerialM(LT_UART_DEFAULT_SERIAL)\n\n#endif\n</code></pre>"},{"location":"ltapi/lt__logger_8c/","title":"File lt_logger.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; lt_logger.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"lt_logger.h\"</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;printf/printf.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__logger_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const char levels   = = {'V', 'D', 'I', 'W', 'E', 'F'}   uint32_t uart_port   = = LT_UART_DEFAULT_LOGGER"},{"location":"ltapi/lt__logger_8c/#public-functions","title":"Public Functions","text":"Type Name     void lt_log (const uint8_t level, const char * format, ...)    void lt_log_disable () Disable LT logger. Enable it back using lt_log_set_port(LT_UART_DEFAULT_LOGGER).   void lt_log_set_port (uint8_t port) Change log output port.   unsigned long millis (void)"},{"location":"ltapi/lt__logger_8c/#macros","title":"Macros","text":"Type Name     define COLOR_BLACK  0x00   define COLOR_BLUE  0x04   define COLOR_BRIGHT_BLACK  0x10   define COLOR_BRIGHT_BLUE  0x14   define COLOR_BRIGHT_CYAN  0x16   define COLOR_BRIGHT_GREEN  0x12   define COLOR_BRIGHT_MAGENTA  0x15   define COLOR_BRIGHT_RED  0x11   define COLOR_BRIGHT_WHITE  0x17   define COLOR_BRIGHT_YELLOW  0x13   define COLOR_CYAN  0x06   define COLOR_FMT  \"\\e[0;30m\"   define COLOR_GREEN  0x02   define COLOR_MAGENTA  0x05   define COLOR_RED  0x01   define COLOR_WHITE  0x07   define COLOR_YELLOW  0x03"},{"location":"ltapi/lt__logger_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/lt__logger_8c/#variable-levels","title":"variable levels","text":"<pre><code>const char levels[];\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#variable-uart_port","title":"variable uart_port","text":"<pre><code>uint32_t uart_port;\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__logger_8c/#function-lt_log","title":"function lt_log","text":"<pre><code>void lt_log (\n    const uint8_t level,\n    const char * format,\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8c/#function-lt_log_disable","title":"function lt_log_disable","text":"<pre><code>void lt_log_disable () \n</code></pre>"},{"location":"ltapi/lt__logger_8c/#function-lt_log_set_port","title":"function lt_log_set_port","text":"<p>Change log output port. <pre><code>void lt_log_set_port (\n    uint8_t port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>port</code> UART port index - can be 0, 1 or 2 </li> </ul>"},{"location":"ltapi/lt__logger_8c/#function-millis","title":"function millis","text":"<pre><code>unsigned long millis (\n    void\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__logger_8c/#define-color_black","title":"define COLOR_BLACK","text":"<pre><code>#define COLOR_BLACK 0x00\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_blue","title":"define COLOR_BLUE","text":"<pre><code>#define COLOR_BLUE 0x04\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_black","title":"define COLOR_BRIGHT_BLACK","text":"<pre><code>#define COLOR_BRIGHT_BLACK 0x10\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_blue","title":"define COLOR_BRIGHT_BLUE","text":"<pre><code>#define COLOR_BRIGHT_BLUE 0x14\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_cyan","title":"define COLOR_BRIGHT_CYAN","text":"<pre><code>#define COLOR_BRIGHT_CYAN 0x16\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_green","title":"define COLOR_BRIGHT_GREEN","text":"<pre><code>#define COLOR_BRIGHT_GREEN 0x12\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_magenta","title":"define COLOR_BRIGHT_MAGENTA","text":"<pre><code>#define COLOR_BRIGHT_MAGENTA 0x15\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_red","title":"define COLOR_BRIGHT_RED","text":"<pre><code>#define COLOR_BRIGHT_RED 0x11\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_white","title":"define COLOR_BRIGHT_WHITE","text":"<pre><code>#define COLOR_BRIGHT_WHITE 0x17\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_bright_yellow","title":"define COLOR_BRIGHT_YELLOW","text":"<pre><code>#define COLOR_BRIGHT_YELLOW 0x13\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_cyan","title":"define COLOR_CYAN","text":"<pre><code>#define COLOR_CYAN 0x06\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_fmt","title":"define COLOR_FMT","text":"<pre><code>#define COLOR_FMT \"\\e[0;30m\"\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_green","title":"define COLOR_GREEN","text":"<pre><code>#define COLOR_GREEN 0x02\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_magenta","title":"define COLOR_MAGENTA","text":"<pre><code>#define COLOR_MAGENTA 0x05\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_red","title":"define COLOR_RED","text":"<pre><code>#define COLOR_RED 0x01\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_white","title":"define COLOR_WHITE","text":"<pre><code>#define COLOR_WHITE 0x07\n</code></pre>"},{"location":"ltapi/lt__logger_8c/#define-color_yellow","title":"define COLOR_YELLOW","text":"<pre><code>#define COLOR_YELLOW 0x03\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/lt_logger.c</code></p>"},{"location":"ltapi/lt__logger_8c_source/","title":"File lt_logger.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; lt_logger.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#include \"lt_logger.h\"\n\n#include &lt;Arduino.h&gt;\n#include &lt;printf/printf.h&gt;\n\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n#include &lt;FreeRTOS.h&gt;\n#include &lt;task.h&gt;\n#endif\n\n#define COLOR_FMT            \"\\e[0;30m\"\n#define COLOR_BLACK          0x00\n#define COLOR_RED            0x01\n#define COLOR_GREEN          0x02\n#define COLOR_YELLOW         0x03\n#define COLOR_BLUE           0x04\n#define COLOR_MAGENTA        0x05\n#define COLOR_CYAN           0x06\n#define COLOR_WHITE          0x07\n#define COLOR_BRIGHT_BLACK   0x10\n#define COLOR_BRIGHT_RED     0x11\n#define COLOR_BRIGHT_GREEN   0x12\n#define COLOR_BRIGHT_YELLOW  0x13\n#define COLOR_BRIGHT_BLUE    0x14\n#define COLOR_BRIGHT_MAGENTA 0x15\n#define COLOR_BRIGHT_CYAN    0x16\n#define COLOR_BRIGHT_WHITE   0x17\n\nstatic uint32_t uart_port  = LT_UART_DEFAULT_LOGGER;\nstatic const char levels[] = {'V', 'D', 'I', 'W', 'E', 'F'};\n\n#if LT_LOGGER_COLOR\nstatic const uint8_t colors[] = {\n    COLOR_BRIGHT_CYAN,\n    COLOR_BRIGHT_BLUE,\n    COLOR_BRIGHT_GREEN,\n    COLOR_BRIGHT_YELLOW,\n    COLOR_BRIGHT_RED,\n    COLOR_BRIGHT_MAGENTA,\n};\n#endif\n\nunsigned long millis(void);\n\n#if LT_LOGGER_CALLER\nvoid lt_log(const uint8_t level, const char *caller, const unsigned short line, const char *format, ...) {\n#else\nvoid lt_log(const uint8_t level, const char *format, ...) {\n#endif\n\n    if (uart_port == 0xFF)\n        return;\n\n#if LT_LOGGER_TIMESTAMP\n    float seconds = millis() / 1000.0f;\n#if LT_PRINTF_BROKEN\n    char zero[4] = \"\\x00\\x30\\x30\";\n    if (seconds == 0.0f)\n        zero[0] = '0';\n#endif\n#endif\n\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n    char task_colon   = ':';\n    TaskHandle_t task = xTaskGetCurrentTaskHandle();\n    char *task_name   = pcTaskGetTaskName(task);\n    if (!task) {\n        task_name  = \"\";\n        task_colon = '-';\n    }\n#endif\n\n#if LT_LOGGER_COLOR\n    char c_bright = '0' + (colors[level] &gt;&gt; 4);\n    char c_value  = '0' + (colors[level] &amp; 0x7);\n#endif\n\n    fctprintf(\n        (void (*)(char, void *))putchar_p,\n        (void *)uart_port,\n    // format:\n#if LT_LOGGER_COLOR\n        \"\\e[%c;3%cm\"\n#endif\n        \"%c \"\n#if LT_LOGGER_TIMESTAMP\n#if LT_PRINTF_BROKEN\n        \"[%11.3f%s] \"\n#else\n        \"[%11.3f] \"\n#endif\n#endif\n#if LT_LOGGER_COLOR\n        \"\\e[0m\"\n#endif\n#if LT_LOGGER_CALLER\n        \"%s():%hu: \"\n#endif\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n        \"%s%c \"\n#endif\n        ,\n    // arguments:\n#if LT_LOGGER_COLOR\n        c_bright, // whether text is bright\n        c_value,  // text color\n#endif\n        levels[level]\n#if LT_LOGGER_TIMESTAMP\n        ,\n        seconds // float\n#if LT_PRINTF_BROKEN\n        ,\n        zero // append missing zeroes if printf \"%11.3f\" prints \"0.\"\n#endif\n#endif\n#if LT_LOGGER_CALLER\n        ,\n        caller,\n        line\n#endif\n#if LT_LOGGER_TASK &amp;&amp; LT_HAS_FREERTOS\n        ,\n        task_name,\n        task_colon // printing outside of tasks\n#endif\n    );\n\n    va_list va_args;\n    va_start(va_args, format);\n    vfctprintf((void (*)(char, void *))putchar_p, (void *)uart_port, format, va_args);\n    va_end(va_args);\n    putchar_p('\\r', uart_port);\n    putchar_p('\\n', uart_port);\n}\n\nvoid lt_log_set_port(uint8_t port) {\n    uart_port = port;\n}\n\nvoid lt_log_disable() {\n    uart_port = 0xFF;\n}\n</code></pre>"},{"location":"ltapi/lt__logger_8h/","title":"File lt_logger.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; lt_logger.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"LibreTuyaConfig.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__logger_8h/#public-functions","title":"Public Functions","text":"Type Name     void lt_log (const uint8_t level, const char * format, ...)    void lt_log_disable () Disable LT logger. Enable it back using lt_log_set_port(LT_UART_DEFAULT_LOGGER).   void void lt_log_set_port (uint8_t port) Change log output port."},{"location":"ltapi/lt__logger_8h/#macros","title":"Macros","text":"Type Name     define ESP_EARLY_LOGD (...) LT_D(__VA_ARGS__)   define ESP_EARLY_LOGE (...) LT_E(__VA_ARGS__)   define ESP_EARLY_LOGI (...) LT_I(__VA_ARGS__)   define ESP_EARLY_LOGV (...) LT_V(__VA_ARGS__)   define ESP_EARLY_LOGW (...) LT_W(__VA_ARGS__)   define ESP_LOGD (...) LT_D(__VA_ARGS__)   define ESP_LOGE (...) LT_E(__VA_ARGS__)   define ESP_LOGI (...) LT_I(__VA_ARGS__)   define ESP_LOGV (...) LT_V(__VA_ARGS__)   define ESP_LOGW (...) LT_W(__VA_ARGS__)   define ETS_PRINTF (...) LT_I(__VA_ARGS__)   define LT_D (...)    define LT_DM (...)    define LT_E (...) LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_EM (module, ...) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_ERRNO ()    define LT_ERRNO_LEZ (ret)    define LT_ERRNO_LZ (ret)    define LT_ERRNO_NZ (ret)    define LT_F (...) LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_FM (module, ...) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_HEAP_I ()    define LT_I (...) LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_IM (module, ...) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_LOG (level, caller, line, ...) lt_log(level, __VA_ARGS__)   define LT_LOGM (level, module, caller, line, ...)    define LT_RET (ret)    define LT_RET_LEZ (ret)    define LT_RET_LZ (ret)    define LT_RET_NZ (ret)    define LT_T (...)    define LT_TM (...)    define LT_V (...)    define LT_VM (...)    define LT_W (...) LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)   define LT_WM (module, ...) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)   define ets_printf (...) LT_I(__VA_ARGS__)   define isr_log_d (...) LT_D(__VA_ARGS__)   define isr_log_e (...) LT_E(__VA_ARGS__)   define isr_log_i (...) LT_I(__VA_ARGS__)   define isr_log_n (...) LT_E(__VA_ARGS__)   define isr_log_v (...) LT_V(__VA_ARGS__)   define isr_log_w (...) LT_W(__VA_ARGS__)   define log_d (...) LT_D(__VA_ARGS__)   define log_e (...) LT_E(__VA_ARGS__)   define log_i (...) LT_I(__VA_ARGS__)   define log_n (...) LT_E(__VA_ARGS__)   define log_printf (...) LT_I(__VA_ARGS__)   define log_v (...) LT_V(__VA_ARGS__)   define log_w (...) LT_W(__VA_ARGS__)"},{"location":"ltapi/lt__logger_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__logger_8h/#function-lt_log","title":"function lt_log","text":"<pre><code>void lt_log (\n    const uint8_t level,\n    const char * format,\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#function-lt_log_disable","title":"function lt_log_disable","text":"<pre><code>void lt_log_disable () \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#function-lt_log_set_port","title":"function lt_log_set_port","text":"<p>Change log output port. <pre><code>void void lt_log_set_port (\n    uint8_t port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>port</code> UART port index - can be 0, 1 or 2 </li> </ul>"},{"location":"ltapi/lt__logger_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/lt__logger_8h/#define-esp_early_logd","title":"define ESP_EARLY_LOGD","text":"<pre><code>#define ESP_EARLY_LOGD (\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_loge","title":"define ESP_EARLY_LOGE","text":"<pre><code>#define ESP_EARLY_LOGE (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_logi","title":"define ESP_EARLY_LOGI","text":"<pre><code>#define ESP_EARLY_LOGI (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_logv","title":"define ESP_EARLY_LOGV","text":"<pre><code>#define ESP_EARLY_LOGV (\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_early_logw","title":"define ESP_EARLY_LOGW","text":"<pre><code>#define ESP_EARLY_LOGW (\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logd","title":"define ESP_LOGD","text":"<pre><code>#define ESP_LOGD (\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_loge","title":"define ESP_LOGE","text":"<pre><code>#define ESP_LOGE (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logi","title":"define ESP_LOGI","text":"<pre><code>#define ESP_LOGI (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logv","title":"define ESP_LOGV","text":"<pre><code>#define ESP_LOGV (\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-esp_logw","title":"define ESP_LOGW","text":"<pre><code>#define ESP_LOGW (\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-ets_printf","title":"define ETS_PRINTF","text":"<pre><code>#define ETS_PRINTF (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_d","title":"define LT_D","text":"<pre><code>#define LT_D (\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_dm","title":"define LT_DM","text":"<pre><code>#define LT_DM (\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_e","title":"define LT_E","text":"<pre><code>#define LT_E (\n    ...\n) LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_em","title":"define LT_EM","text":"<pre><code>#define LT_EM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno","title":"define LT_ERRNO","text":"<pre><code>#define LT_ERRNO (\n\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno_lez","title":"define LT_ERRNO_LEZ","text":"<pre><code>#define LT_ERRNO_LEZ (\n    ret\n) if (ret &lt;= 0) {                                                                                                    \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret);                                                                          \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno_lz","title":"define LT_ERRNO_LZ","text":"<pre><code>#define LT_ERRNO_LZ (\n    ret\n) if (ret &lt; 0) {                                                                                                     \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret);                                                                          \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_errno_nz","title":"define LT_ERRNO_NZ","text":"<pre><code>#define LT_ERRNO_NZ (\n    ret\n) if (ret) {                                                                                                         \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret);                                                                          \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_f","title":"define LT_F","text":"<pre><code>#define LT_F (\n    ...\n) LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_fm","title":"define LT_FM","text":"<pre><code>#define LT_FM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_heap_i","title":"define LT_HEAP_I","text":"<pre><code>#define LT_HEAP_I (\n\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_i","title":"define LT_I","text":"<pre><code>#define LT_I (\n    ...\n) LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_im","title":"define LT_IM","text":"<pre><code>#define LT_IM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_log","title":"define LT_LOG","text":"<pre><code>#define LT_LOG (\n    level,\n    caller,\n    line,\n    ...\n) lt_log(level, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_logm","title":"define LT_LOGM","text":"<pre><code>#define LT_LOGM (\n    level,\n    module,\n    caller,\n    line,\n    ...\n) do {                                                                                                               \\\n        if (LT_DEBUG_##module) {                                                                                       \\\n            lt_log(level, #module \": \" __VA_ARGS__);                                                                   \\\n        }                                                                                                              \\\n    } while (0)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret","title":"define LT_RET","text":"<pre><code>#define LT_RET (\n    ret\n) LT_E(\"ret=%d\", ret);                                                                                               \\\n    return ret;\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret_lez","title":"define LT_RET_LEZ","text":"<pre><code>#define LT_RET_LEZ (\n    ret\n) if (ret &lt;= 0) {                                                                                                    \\\n        LT_E(\"ret=%d\", ret);                                                                                           \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret_lz","title":"define LT_RET_LZ","text":"<pre><code>#define LT_RET_LZ (\n    ret\n) if (ret &lt; 0) {                                                                                                     \\\n        LT_E(\"ret=%d\", ret);                                                                                           \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_ret_nz","title":"define LT_RET_NZ","text":"<pre><code>#define LT_RET_NZ (\n    ret\n) if (ret) {                                                                                                         \\\n        LT_E(\"ret=%d\", ret);                                                                                           \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_t","title":"define LT_T","text":"<pre><code>#define LT_T (\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_tm","title":"define LT_TM","text":"<pre><code>#define LT_TM (\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_v","title":"define LT_V","text":"<pre><code>#define LT_V (\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_vm","title":"define LT_VM","text":"<pre><code>#define LT_VM (\n    ...\n) \n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_w","title":"define LT_W","text":"<pre><code>#define LT_W (\n    ...\n) LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-lt_wm","title":"define LT_WM","text":"<pre><code>#define LT_WM (\n    module,\n    ...\n) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-ets_printf_1","title":"define ets_printf","text":"<pre><code>#define ets_printf (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_d","title":"define isr_log_d","text":"<pre><code>#define isr_log_d (\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_e","title":"define isr_log_e","text":"<pre><code>#define isr_log_e (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_i","title":"define isr_log_i","text":"<pre><code>#define isr_log_i (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_n","title":"define isr_log_n","text":"<pre><code>#define isr_log_n (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_v","title":"define isr_log_v","text":"<pre><code>#define isr_log_v (\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-isr_log_w","title":"define isr_log_w","text":"<pre><code>#define isr_log_w (\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_d","title":"define log_d","text":"<pre><code>#define log_d (\n    ...\n) LT_D(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_e","title":"define log_e","text":"<pre><code>#define log_e (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_i","title":"define log_i","text":"<pre><code>#define log_i (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_n","title":"define log_n","text":"<pre><code>#define log_n (\n    ...\n) LT_E(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_printf","title":"define log_printf","text":"<pre><code>#define log_printf (\n    ...\n) LT_I(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_v","title":"define log_v","text":"<pre><code>#define log_v (\n    ...\n) LT_V(__VA_ARGS__)\n</code></pre>"},{"location":"ltapi/lt__logger_8h/#define-log_w","title":"define log_w","text":"<pre><code>#define log_w (\n    ...\n) LT_W(__VA_ARGS__)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/lt_logger.h</code></p>"},{"location":"ltapi/lt__logger_8h_source/","title":"File lt_logger.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; lt_logger.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-28. */\n\n#pragma once\n\n#include \"LibreTuyaConfig.h\"\n#include &lt;stdint.h&gt;\n\n#if LT_LOGGER_CALLER\n#define LT_LOG(level, caller, line, ...) lt_log(level, caller, line, __VA_ARGS__)\n#define LT_LOGM(level, module, caller, line, ...)                                                                      \\\n    do {                                                                                                               \\\n        if (LT_DEBUG_##module) {                                                                                       \\\n            lt_log(level, caller, line, #module \": \" __VA_ARGS__);                                                     \\\n        }                                                                                                              \\\n    } while (0)\nvoid lt_log(const uint8_t level, const char *caller, const unsigned short line, const char *format, ...)\n    __attribute__((format(printf, 4, 5)));\n#else\n#define LT_LOG(level, caller, line, ...) lt_log(level, __VA_ARGS__)\n#define LT_LOGM(level, module, caller, line, ...)                                                                      \\\n    do {                                                                                                               \\\n        if (LT_DEBUG_##module) {                                                                                       \\\n            lt_log(level, #module \": \" __VA_ARGS__);                                                                   \\\n        }                                                                                                              \\\n    } while (0)\nvoid lt_log(const uint8_t level, const char *format, ...) __attribute__((format(printf, 2, 3)));\n#endif\n\nvoid lt_log_set_port(uint8_t port);\n\nvoid lt_log_disable();\n\n#if LT_LEVEL_TRACE &gt;= LT_LOGLEVEL\n#define LT_T(...)          LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_V(...)          LT_LOG(LT_LEVEL_TRACE, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_TM(module, ...) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_VM(module, ...) LT_LOGM(LT_LEVEL_TRACE, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_T(...)\n#define LT_V(...)\n#define LT_TM(...)\n#define LT_VM(...)\n#endif\n\n#if LT_LEVEL_DEBUG &gt;= LT_LOGLEVEL\n#define LT_D(...)          LT_LOG(LT_LEVEL_DEBUG, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_DM(module, ...) LT_LOGM(LT_LEVEL_DEBUG, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_D(...)\n#define LT_DM(...)\n#endif\n\n#if LT_LEVEL_INFO &gt;= LT_LOGLEVEL\n#define LT_I(...)          LT_LOG(LT_LEVEL_INFO, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_IM(module, ...) LT_LOGM(LT_LEVEL_INFO, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_I(...)\n#define LT_IM(...)\n#endif\n\n#if LT_LEVEL_WARN &gt;= LT_LOGLEVEL\n#define LT_W(...)          LT_LOG(LT_LEVEL_WARN, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_WM(module, ...) LT_LOGM(LT_LEVEL_WARN, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_W(...)\n#define LT_WM(...)\n#endif\n\n#if LT_LEVEL_ERROR &gt;= LT_LOGLEVEL\n#define LT_E(...)          LT_LOG(LT_LEVEL_ERROR, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_EM(module, ...) LT_LOGM(LT_LEVEL_ERROR, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_E(...)\n#define LT_EM(...)\n#endif\n\n#if LT_LEVEL_FATAL &gt;= LT_LOGLEVEL\n#define LT_F(...)          LT_LOG(LT_LEVEL_FATAL, __FUNCTION__, __LINE__, __VA_ARGS__)\n#define LT_FM(module, ...) LT_LOGM(LT_LEVEL_FATAL, module, __FUNCTION__, __LINE__, __VA_ARGS__)\n#else\n#define LT_F(...)\n#define LT_FM(...)\n#endif\n\n#if LT_LOG_HEAP\n#define LT_HEAP_I() LT_I(\"Free heap: %u\", LT_HEAP_FUNC());\n#else\n#define LT_HEAP_I()\n#endif\n\n// ESP32 compat\n#define log_printf(...)     LT_I(__VA_ARGS__)\n#define log_v(...)          LT_V(__VA_ARGS__)\n#define log_d(...)          LT_D(__VA_ARGS__)\n#define log_i(...)          LT_I(__VA_ARGS__)\n#define log_w(...)          LT_W(__VA_ARGS__)\n#define log_e(...)          LT_E(__VA_ARGS__)\n#define log_n(...)          LT_E(__VA_ARGS__)\n#define isr_log_v(...)      LT_V(__VA_ARGS__)\n#define isr_log_d(...)      LT_D(__VA_ARGS__)\n#define isr_log_i(...)      LT_I(__VA_ARGS__)\n#define isr_log_w(...)      LT_W(__VA_ARGS__)\n#define isr_log_e(...)      LT_E(__VA_ARGS__)\n#define isr_log_n(...)      LT_E(__VA_ARGS__)\n#define ESP_LOGV(...)       LT_V(__VA_ARGS__)\n#define ESP_LOGD(...)       LT_D(__VA_ARGS__)\n#define ESP_LOGI(...)       LT_I(__VA_ARGS__)\n#define ESP_LOGW(...)       LT_W(__VA_ARGS__)\n#define ESP_LOGE(...)       LT_E(__VA_ARGS__)\n#define ESP_EARLY_LOGV(...) LT_V(__VA_ARGS__)\n#define ESP_EARLY_LOGD(...) LT_D(__VA_ARGS__)\n#define ESP_EARLY_LOGI(...) LT_I(__VA_ARGS__)\n#define ESP_EARLY_LOGW(...) LT_W(__VA_ARGS__)\n#define ESP_EARLY_LOGE(...) LT_E(__VA_ARGS__)\n#define ets_printf(...)     LT_I(__VA_ARGS__)\n#define ETS_PRINTF(...)     LT_I(__VA_ARGS__)\n\n#define LT_RET(ret)                                                                                                    \\\n    LT_E(\"ret=%d\", ret);                                                                                               \\\n    return ret;\n\n#define LT_RET_NZ(ret)                                                                                                 \\\n    if (ret) {                                                                                                         \\\n        LT_E(\"ret=%d\", ret);                                                                                           \\\n        return ret;                                                                                                    \\\n    }\n#define LT_RET_LZ(ret)                                                                                                 \\\n    if (ret &lt; 0) {                                                                                                     \\\n        LT_E(\"ret=%d\", ret);                                                                                           \\\n        return ret;                                                                                                    \\\n    }\n#define LT_RET_LEZ(ret)                                                                                                \\\n    if (ret &lt;= 0) {                                                                                                    \\\n        LT_E(\"ret=%d\", ret);                                                                                           \\\n        return ret;                                                                                                    \\\n    }\n\n#define LT_ERRNO_NZ(ret)                                                                                               \\\n    if (ret) {                                                                                                         \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret);                                                                          \\\n        return ret;                                                                                                    \\\n    }\n#define LT_ERRNO_LZ(ret)                                                                                               \\\n    if (ret &lt; 0) {                                                                                                     \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret);                                                                          \\\n        return ret;                                                                                                    \\\n    }\n#define LT_ERRNO_LEZ(ret)                                                                                              \\\n    if (ret &lt;= 0) {                                                                                                    \\\n        LT_E(\"errno=%d, ret=%d\", errno, ret);                                                                          \\\n        return ret;                                                                                                    \\\n    }\n\n#if LT_LOG_ERRNO\n#define LT_ERRNO()                                                                                                     \\\n    if (errno) {                                                                                                       \\\n        LT_E(\"errno=%d\", errno);                                                                                       \\\n        errno = 0;                                                                                                     \\\n    }\n#else\n#define LT_ERRNO()\n#endif\n</code></pre>"},{"location":"ltapi/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; core &gt; main.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/HardwareSerial.h&gt;</code></li> <li><code>#include &lt;fal.h&gt;</code></li> </ul>"},{"location":"ltapi/main_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     fal_partition_t fal_root_part   = = NULLRoot partition table, representing the entire flash."},{"location":"ltapi/main_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     unsigned long periodicTasks   = = {0, 0}"},{"location":"ltapi/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name     void __libc_init_array (void)    void initArduino ()    void initVariant ()    int main (void)    void mainTask (const void * arg) Main setup() and loop() task. Not to be called directly.   void runPeriodicTasks () Run periodic tasks, like printing free heap or checking millis() overflow."},{"location":"ltapi/main_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/main_8cpp/#variable-fal_root_part","title":"variable fal_root_part","text":"<pre><code>fal_partition_t fal_root_part;\n</code></pre>"},{"location":"ltapi/main_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/main_8cpp/#variable-periodictasks","title":"variable periodicTasks","text":"<pre><code>unsigned long periodicTasks[];\n</code></pre>"},{"location":"ltapi/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/main_8cpp/#function-__libc_init_array","title":"function __libc_init_array","text":"<pre><code>void __libc_init_array (\n    void\n) \n</code></pre>"},{"location":"ltapi/main_8cpp/#function-initarduino","title":"function initArduino","text":"<pre><code>void initArduino () \n</code></pre>"},{"location":"ltapi/main_8cpp/#function-initvariant","title":"function initVariant","text":"<pre><code>void initVariant () \n</code></pre>"},{"location":"ltapi/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    void\n) \n</code></pre>"},{"location":"ltapi/main_8cpp/#function-maintask","title":"function mainTask","text":"<pre><code>void mainTask (\n    const void * arg\n) \n</code></pre>"},{"location":"ltapi/main_8cpp/#function-runperiodictasks","title":"function runPeriodicTasks","text":"<p>Run periodic tasks, like printing free heap or checking millis() overflow. <pre><code>void runPeriodicTasks () \n</code></pre></p> <p>This is called during delaying operations, like yield() or delay(). </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/core/main.cpp</code></p>"},{"location":"ltapi/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; core &gt; main.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-19. */\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/HardwareSerial.h&gt;\n\nusing namespace arduino;\n\nextern \"C\" {\n#include &lt;fal.h&gt;\nfal_partition_t fal_root_part = NULL;\n}\n\n// Arduino framework initialization.\n// May be redefined by family files.\nvoid initArduino() __attribute__((weak));\n\n// Weak empty variant initialization function.\n// May be redefined by variant files.\nvoid initVariant() __attribute__((weak));\n\n// Initialize C library\nextern \"C\" void __libc_init_array(void);\n\nvoid mainTask(const void *arg) {\n    setup();\n\n    for (;;) {\n        loop();\n        if (serialEventRun)\n            serialEventRun();\n        yield();\n    }\n}\n\nstatic unsigned long periodicTasks[] = {0, 0};\n\nvoid runPeriodicTasks() {\n#if LT_LOG_HEAP\n    if (millis() - periodicTasks[0] &gt; 1000) {\n        LT_HEAP_I();\n        periodicTasks[0] = millis();\n    }\n#endif\n#if LT_USE_TIME\n    if (millis() - periodicTasks[1] &gt; 10000) {\n        gettimeofday(NULL, NULL);\n        periodicTasks[1] = millis();\n    }\n#endif\n}\n\nint main(void) {\n    // print a startup banner\n    LT_BANNER();\n    // initialize C library\n    __libc_init_array();\n    // inform about the reset reason\n    LT_I(\"Reset reason: %u\", LT.getResetReason());\n    // initialize Arduino framework\n    initArduino();\n    // optionally initialize per-variant code\n    initVariant();\n    // initialize FAL\n    fal_init();\n    // provide root partition\n    fal_root_part = (fal_partition_t)fal_partition_find(\"root\");\n    // start the main task and OS kernel\n    if (!startMainTask()) {\n        LT_F(\"Couldn't start the main task\");\n    }\n\n    while (1) {}\n    return 0;\n}\n</code></pre>"},{"location":"ltapi/dir_4d74fadbf69f28bbde6a2e12bcb2f84d/","title":"Dir arduino/libretuya/libraries","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries</p>"},{"location":"ltapi/dir_4d74fadbf69f28bbde6a2e12bcb2f84d/#directories","title":"Directories","text":"Type Name     dir Flash    dir HTTPClient    dir MD5    dir NetUtils    dir StreamString    dir Update    dir WebServer    dir WiFiMulti    dir base64    dir cbuf    dir mDNS      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/</code></p>"},{"location":"ltapi/dir_bafb2e9c1f0d5e7c06ebc8ebbea58223/","title":"Dir arduino/libretuya/libraries/Flash","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Flash</p>"},{"location":"ltapi/dir_bafb2e9c1f0d5e7c06ebc8ebbea58223/#files","title":"Files","text":"Type Name     file Flash.cpp    file Flash.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Flash/</code></p>"},{"location":"ltapi/_flash_8cpp/","title":"File Flash.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Flash &gt; Flash.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Flash.h\"</code></li> <li><code>#include &lt;fal.h&gt;</code></li> </ul>"},{"location":"ltapi/_flash_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     FlashClass Flash"},{"location":"ltapi/_flash_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_flash_8cpp/#variable-flash","title":"variable Flash","text":"<pre><code>FlashClass Flash;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Flash/Flash.cpp</code></p>"},{"location":"ltapi/_flash_8cpp_source/","title":"File Flash.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; Flash &gt; Flash.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-24. */\n\n#include \"Flash.h\"\n\nextern \"C\" {\n#include &lt;fal.h&gt;\n}\n\n// Global Flash object.\nFlashClass Flash;\n\nFlashId FlashClass::getChipId() {\n    return LT.getFlashChipId();\n}\n\nuint32_t FlashClass::getSize() {\n    return LT.getFlashChipSize();\n}\n\nbool FlashClass::eraseSector(uint32_t offset) {\n    return fal_partition_erase(fal_root_part, offset, 1) &gt;= 0;\n}\n\nbool FlashClass::readBlock(uint32_t offset, uint8_t *data, size_t size) {\n    return fal_partition_read(fal_root_part, offset, data, size) &gt;= 0;\n}\n\nbool FlashClass::writeBlock(uint32_t offset, uint8_t *data, size_t size) {\n    return fal_partition_write(fal_root_part, offset, data, size) &gt;= 0;\n}\n</code></pre>"},{"location":"ltapi/_flash_8h/","title":"File Flash.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Flash &gt; Flash.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/_flash_8h/#classes","title":"Classes","text":"Type Name     class FlashClass"},{"location":"ltapi/_flash_8h/#public-attributes","title":"Public Attributes","text":"Type Name     FlashClass Flash"},{"location":"ltapi/_flash_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_flash_8h/#variable-flash","title":"variable Flash","text":"<pre><code>FlashClass Flash;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Flash/Flash.h</code></p>"},{"location":"ltapi/_flash_8h_source/","title":"File Flash.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; Flash &gt; Flash.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-24. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n\nclass FlashClass {\n  public:\n    FlashId getChipId();\n    uint32_t getSize();\n\n    bool eraseSector(uint32_t offset);\n    bool readBlock(uint32_t offset, uint8_t *data, size_t size);\n    bool writeBlock(uint32_t offset, uint8_t *data, size_t size);\n};\n\nextern FlashClass Flash;\n</code></pre>"},{"location":"ltapi/dir_7c1ce24c968275d4126655730bb60d80/","title":"Dir arduino/libretuya/libraries/HTTPClient","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient</p>"},{"location":"ltapi/dir_7c1ce24c968275d4126655730bb60d80/#files","title":"Files","text":"Type Name     file HTTPClient.cpp    file HTTPClient.h    file strptime.h"},{"location":"ltapi/dir_7c1ce24c968275d4126655730bb60d80/#directories","title":"Directories","text":"Type Name     dir strptime      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/</code></p>"},{"location":"ltapi/_h_t_t_p_client_8cpp/","title":"File HTTPClient.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; HTTPClient.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/HTTPClient.cpp</code></p>"},{"location":"ltapi/_h_t_t_p_client_8cpp_source/","title":"File HTTPClient.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; HTTPClient.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#if LT_ARD_HAS_WIFI\n\n#include &lt;Arduino.h&gt;\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n#include &lt;WiFi.h&gt;\n#include &lt;WiFiClientSecure.h&gt;\n#endif\n\n// #include &lt;StreamString.h&gt;\n#include &lt;base64.h&gt;\n\n#include \"HTTPClient.h\"\n\n#include &lt;time.h&gt;\n\nextern \"C\" {\n#include \"strptime.h\"\n}\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nclass TransportTraits {\n  public:\n    virtual ~TransportTraits() {}\n\n    virtual std::unique_ptr&lt;WiFiClient&gt; create() {\n        return std::unique_ptr&lt;WiFiClient&gt;(new WiFiClient());\n    }\n\n    virtual bool verify(WiFiClient &amp;client, const char *host) {\n        return true;\n    }\n};\n\nclass TLSTraits : public TransportTraits {\n  public:\n    TLSTraits(const char *CAcert, const char *clicert = nullptr, const char *clikey = nullptr)\n        : _cacert(CAcert), _clicert(clicert), _clikey(clikey) {}\n\n    std::unique_ptr&lt;WiFiClient&gt; create() override {\n        return std::unique_ptr&lt;WiFiClient&gt;(new WiFiClientSecure());\n    }\n\n    bool verify(WiFiClient &amp;client, const char *host) override {\n        WiFiClientSecure &amp;wcs = static_cast&lt;WiFiClientSecure &amp;&gt;(client);\n        if (_cacert == nullptr) {\n            wcs.setInsecure();\n        } else {\n            wcs.setCACert(_cacert);\n            wcs.setCertificate(_clicert);\n            wcs.setPrivateKey(_clikey);\n        }\n        return true;\n    }\n\n  protected:\n    const char *_cacert;\n    const char *_clicert;\n    const char *_clikey;\n};\n#endif // HTTPCLIENT_1_1_COMPATIBLE\n\nHTTPClient::HTTPClient() {}\n\nHTTPClient::~HTTPClient() {\n    if (_client) {\n        _client-&gt;stop();\n    }\n    if (_currentHeaders) {\n        delete[] _currentHeaders;\n    }\n    if (_tcpDeprecated) {\n        _tcpDeprecated.reset(nullptr);\n    }\n    if (_transportTraits) {\n        _transportTraits.reset(nullptr);\n    }\n}\n\nvoid HTTPClient::clear() {\n    _returnCode = 0;\n    _size       = -1;\n    _headers    = \"\";\n}\n\nbool HTTPClient::begin(WiFiClient &amp;client, String url) {\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n#endif\n\n    _client = &amp;client;\n\n    // check for : (http: or https:)\n    int index = url.indexOf(':');\n    if (index &lt; 0) {\n        log_d(\"failed to parse protocol\");\n        return false;\n    }\n\n    String protocol = url.substring(0, index);\n    if (protocol != \"http\" &amp;&amp; protocol != \"https\") {\n        log_d(\"unknown protocol '%s'\", protocol.c_str());\n        return false;\n    }\n\n    _port   = (protocol == \"https\" ? 443 : 80);\n    _secure = (protocol == \"https\");\n    return beginInternal(url, protocol.c_str());\n}\n\nbool HTTPClient::begin(WiFiClient &amp;client, String host, uint16_t port, String uri, bool https) {\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n#endif\n\n    _client = &amp;client;\n\n    clear();\n    _host     = host;\n    _port     = port;\n    _uri      = uri;\n    _protocol = (https ? \"https\" : \"http\");\n    _secure   = https;\n    return true;\n}\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nbool HTTPClient::begin(String url, const char *CAcert) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _port = 443;\n    if (!beginInternal(url, \"https\")) {\n        return false;\n    }\n    _secure          = true;\n    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert));\n    if (!_transportTraits) {\n        log_e(\"could not create transport traits\");\n        return false;\n    }\n\n    return true;\n}\n\nbool HTTPClient::begin(String url) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _port = 80;\n    if (!beginInternal(url, \"http\")) {\n        return begin(url, (const char *)NULL);\n    }\n    _transportTraits = TransportTraitsPtr(new TransportTraits());\n    if (!_transportTraits) {\n        log_e(\"could not create transport traits\");\n        return false;\n    }\n\n    return true;\n}\n#endif // HTTPCLIENT_1_1_COMPATIBLE\n\nbool HTTPClient::beginInternal(String url, const char *expectedProtocol) {\n    log_v(\"url: %s\", url.c_str());\n\n    // check for : (http: or https:\n    int index = url.indexOf(':');\n    if (index &lt; 0) {\n        log_e(\"failed to parse protocol\");\n        return false;\n    }\n\n    _protocol = url.substring(0, index);\n    if (_protocol != expectedProtocol) {\n        log_d(\"unexpected protocol: %s, expected %s\", _protocol.c_str(), expectedProtocol);\n        return false;\n    }\n\n    url.remove(0, (index + 3)); // remove http:// or https://\n\n    index = url.indexOf('/');\n    if (index == -1) {\n        index = url.length();\n        url += '/';\n    }\n    String host = url.substring(0, index);\n    url.remove(0, index); // remove host part\n\n    // get Authorization\n    index = host.indexOf('@');\n    if (index &gt;= 0) {\n        // auth info\n        String auth = host.substring(0, index);\n        host.remove(0, index + 1); // remove auth part including @\n        _base64Authorization = base64::encode(auth);\n    }\n\n    // get port\n    index = host.indexOf(':');\n    String the_host;\n    if (index &gt;= 0) {\n        the_host = host.substring(0, index); // hostname\n        host.remove(0, (index + 1));         // remove hostname + :\n        _port = host.toInt();                // get port\n    } else {\n        the_host = host;\n    }\n    if (_host != the_host &amp;&amp; connected()) {\n        log_d(\"switching host from '%s' to '%s'. disconnecting first\", _host.c_str(), the_host.c_str());\n        _canReuse = false;\n        disconnect(true);\n    }\n    _host = the_host;\n    _uri  = url;\n    log_d(\"protocol: %s, host: %s port: %d url: %s\", _protocol.c_str(), _host.c_str(), _port, _uri.c_str());\n    return true;\n}\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nbool HTTPClient::begin(String host, uint16_t port, String uri) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _host            = host;\n    _port            = port;\n    _uri             = uri;\n    _transportTraits = TransportTraitsPtr(new TransportTraits());\n    log_d(\"host: %s port: %d uri: %s\", host.c_str(), port, uri.c_str());\n    return true;\n}\n\nbool HTTPClient::begin(String host, uint16_t port, String uri, const char *CAcert) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _host = host;\n    _port = port;\n    _uri  = uri;\n\n    if (strlen(CAcert) == 0) {\n        return false;\n    }\n    _secure          = true;\n    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert));\n    return true;\n}\n\nbool HTTPClient::begin(\n    String host, uint16_t port, String uri, const char *CAcert, const char *cli_cert, const char *cli_key\n) {\n    if (_client &amp;&amp; !_tcpDeprecated) {\n        log_d(\"mix up of new and deprecated api\");\n        _canReuse = false;\n        end();\n    }\n\n    clear();\n    _host = host;\n    _port = port;\n    _uri  = uri;\n\n    if (strlen(CAcert) == 0) {\n        return false;\n    }\n    _secure          = true;\n    _transportTraits = TransportTraitsPtr(new TLSTraits(CAcert, cli_cert, cli_key));\n    return true;\n}\n#endif // HTTPCLIENT_1_1_COMPATIBLE\n\nvoid HTTPClient::end(void) {\n    disconnect(false);\n    clear();\n}\n\nvoid HTTPClient::disconnect(bool preserveClient) {\n    if (connected()) {\n        if (_client-&gt;available() &gt; 0) {\n            log_d(\"still data in buffer (%d), clean up.\\n\", _client-&gt;available());\n            _client-&gt;flush();\n        }\n\n        if (_reuse &amp;&amp; _canReuse) {\n            log_d(\"tcp keep open for reuse\");\n        } else {\n            log_d(\"tcp stop\");\n            _client-&gt;stop();\n            if (!preserveClient) {\n                _client = nullptr;\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n                if (_tcpDeprecated) {\n                    _transportTraits.reset(nullptr);\n                    _tcpDeprecated.reset(nullptr);\n                }\n#endif\n            }\n        }\n    } else {\n        log_d(\"tcp is closed\\n\");\n    }\n}\n\nbool HTTPClient::connected() {\n    if (_client) {\n        return ((_client-&gt;available() &gt; 0) || _client-&gt;connected());\n    }\n    return false;\n}\n\nvoid HTTPClient::setReuse(bool reuse) {\n    _reuse = reuse;\n}\n\nvoid HTTPClient::setUserAgent(const String &amp;userAgent) {\n    _userAgent = userAgent;\n}\n\nvoid HTTPClient::setAuthorization(const char *user, const char *password) {\n    if (user &amp;&amp; password) {\n        String auth = user;\n        auth += \":\";\n        auth += password;\n        _base64Authorization = base64::encode(auth);\n    }\n}\n\nvoid HTTPClient::setAuthorization(const char *auth) {\n    if (auth) {\n        _base64Authorization = auth;\n    }\n}\n\nvoid HTTPClient::setAuthorizationType(const char *authType) {\n    if (authType) {\n        _authorizationType = authType;\n    }\n}\n\nvoid HTTPClient::setConnectTimeout(int32_t connectTimeout) {\n    _connectTimeout = connectTimeout;\n}\n\nvoid HTTPClient::setTimeout(uint16_t timeout) {\n    _tcpTimeout = timeout;\n    if (connected()) {\n        _client-&gt;setTimeout((timeout + 500) / 1000);\n    }\n}\n\nvoid HTTPClient::useHTTP10(bool useHTTP10) {\n    _useHTTP10 = useHTTP10;\n    _reuse     = !useHTTP10;\n}\n\nint HTTPClient::GET() {\n    return sendRequest(\"GET\");\n}\n\nint HTTPClient::POST(uint8_t *payload, size_t size) {\n    return sendRequest(\"POST\", payload, size);\n}\n\nint HTTPClient::POST(String payload) {\n    return POST((uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::PATCH(uint8_t *payload, size_t size) {\n    return sendRequest(\"PATCH\", payload, size);\n}\n\nint HTTPClient::PATCH(String payload) {\n    return PATCH((uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::PUT(uint8_t *payload, size_t size) {\n    return sendRequest(\"PUT\", payload, size);\n}\n\nint HTTPClient::PUT(String payload) {\n    return PUT((uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::sendRequest(const char *type, String payload) {\n    return sendRequest(type, (uint8_t *)payload.c_str(), payload.length());\n}\n\nint HTTPClient::sendRequest(const char *type, uint8_t *payload, size_t size) {\n    int code;\n    bool redirect          = false;\n    uint16_t redirectCount = 0;\n    do {\n        // wipe out any existing headers from previous request\n        for (size_t i = 0; i &lt; _headerKeysCount; i++) {\n            if (_currentHeaders[i].value.length() &gt; 0) {\n                _currentHeaders[i].value = \"\"; // LT: changed from clear()\n            }\n        }\n\n        log_d(\"request type: '%s' redirCount: %d\\n\", type, redirectCount);\n\n        // connect to server\n        if (!connect()) {\n            return returnError(HTTPC_ERROR_CONNECTION_REFUSED);\n        }\n\n        if (payload &amp;&amp; size &gt; 0) {\n            addHeader(F(\"Content-Length\"), String(size));\n        }\n\n        // add cookies to header, if present\n        String cookie_string;\n        if (generateCookieString(&amp;cookie_string)) {\n            addHeader(\"Cookie\", cookie_string);\n        }\n\n        // send Header\n        if (!sendHeader(type)) {\n            return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);\n        }\n\n        // send Payload if needed\n        if (payload &amp;&amp; size &gt; 0) {\n            if (_client-&gt;write(&amp;payload[0], size) != size) {\n                return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n            }\n        }\n\n        code = handleHeaderResponse();\n        log_d(\"sendRequest code=%d\\n\", code);\n\n        // Handle redirections as stated in RFC document:\n        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\n        //\n        // Implementing HTTP_CODE_FOUND as redirection with GET method,\n        // to follow most of existing user agent implementations.\n        //\n        redirect = false;\n        if (_followRedirects != HTTPC_DISABLE_FOLLOW_REDIRECTS &amp;&amp; redirectCount &lt; _redirectLimit &amp;&amp;\n            _location.length() &gt; 0) {\n            switch (code) {\n                // redirecting using the same method\n                case HTTP_CODE_MOVED_PERMANENTLY:\n                case HTTP_CODE_TEMPORARY_REDIRECT: {\n                    if (\n                        // allow to force redirections on other methods\n                        // (the RFC require user to accept the redirection)\n                        _followRedirects == HTTPC_FORCE_FOLLOW_REDIRECTS ||\n                        // allow GET and HEAD methods without force\n                        !strcmp(type, \"GET\") ||\n                        !strcmp(type, \"HEAD\")\n                    ) {\n                        redirectCount += 1;\n                        log_d(\n                            \"following redirect (the same method): '%s' redirCount: %d\\n\",\n                            _location.c_str(),\n                            redirectCount\n                        );\n                        if (!setURL(_location)) {\n                            log_d(\"failed setting URL for redirection\\n\");\n                            // no redirection\n                            break;\n                        }\n                        // redirect using the same request method and payload, diffrent URL\n                        redirect = true;\n                    }\n                    break;\n                }\n                // redirecting with method dropped to GET or HEAD\n                // note: it does not need `HTTPC_FORCE_FOLLOW_REDIRECTS` for any method\n                case HTTP_CODE_FOUND:\n                case HTTP_CODE_SEE_OTHER: {\n                    redirectCount += 1;\n                    log_d(\n                        \"following redirect (dropped to GET/HEAD): '%s' redirCount: %d\\n\",\n                        _location.c_str(),\n                        redirectCount\n                    );\n                    if (!setURL(_location)) {\n                        log_d(\"failed setting URL for redirection\\n\");\n                        // no redirection\n                        break;\n                    }\n                    // redirect after changing method to GET/HEAD and dropping payload\n                    type     = \"GET\";\n                    payload  = nullptr;\n                    size     = 0;\n                    redirect = true;\n                    break;\n                }\n\n                default:\n                    break;\n            }\n        }\n\n    } while (redirect);\n    // handle Server Response (Header)\n    return returnError(code);\n}\n\nint HTTPClient::sendRequest(const char *type, Stream *stream, size_t size) {\n\n    if (!stream) {\n        return returnError(HTTPC_ERROR_NO_STREAM);\n    }\n\n    // connect to server\n    if (!connect()) {\n        return returnError(HTTPC_ERROR_CONNECTION_REFUSED);\n    }\n\n    if (size &gt; 0) {\n        addHeader(\"Content-Length\", String(size));\n    }\n\n    // add cookies to header, if present\n    String cookie_string;\n    if (generateCookieString(&amp;cookie_string)) {\n        addHeader(\"Cookie\", cookie_string);\n    }\n\n    // send Header\n    if (!sendHeader(type)) {\n        return returnError(HTTPC_ERROR_SEND_HEADER_FAILED);\n    }\n\n    int buff_size = HTTP_TCP_BUFFER_SIZE;\n\n    int len          = size;\n    int bytesWritten = 0;\n\n    if (len == 0) {\n        len = -1;\n    }\n\n    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE\n    if ((len &gt; 0) &amp;&amp; (len &lt; HTTP_TCP_BUFFER_SIZE)) {\n        buff_size = len;\n    }\n\n    // create buffer for read\n    uint8_t *buff = (uint8_t *)malloc(buff_size);\n\n    if (buff) {\n        // read all data from stream and send it to server\n        while (connected() &amp;&amp; (stream-&gt;available() &gt; -1) &amp;&amp; (len &gt; 0 || len == -1)) {\n\n            // get available data size\n            int sizeAvailable = stream-&gt;available();\n\n            if (sizeAvailable) {\n\n                int readBytes = sizeAvailable;\n\n                // read only the asked bytes\n                if (len &gt; 0 &amp;&amp; readBytes &gt; len) {\n                    readBytes = len;\n                }\n\n                // not read more the buffer can handle\n                if (readBytes &gt; buff_size) {\n                    readBytes = buff_size;\n                }\n\n                // read data\n                int bytesRead = stream-&gt;readBytes(buff, readBytes);\n\n                // write it to Stream\n                int bytesWrite = _client-&gt;write((const uint8_t *)buff, bytesRead);\n                bytesWritten += bytesWrite;\n\n                // are all Bytes a writen to stream ?\n                if (bytesWrite != bytesRead) {\n                    log_d(\"short write, asked for %d but got %d retry...\", bytesRead, bytesWrite);\n\n                    // check for write error\n                    if (_client-&gt;getWriteError()) {\n                        log_d(\"stream write error %d\", _client-&gt;getWriteError());\n\n                        // reset write error for retry\n                        _client-&gt;clearWriteError();\n                    }\n\n                    // some time for the stream\n                    delay(1);\n\n                    int leftBytes = (readBytes - bytesWrite);\n\n                    // retry to send the missed bytes\n                    bytesWrite = _client-&gt;write((const uint8_t *)(buff + bytesWrite), leftBytes);\n                    bytesWritten += bytesWrite;\n\n                    if (bytesWrite != leftBytes) {\n                        // failed again\n                        log_d(\"short write, asked for %d but got %d failed.\", leftBytes, bytesWrite);\n                        free(buff);\n                        return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n                    }\n                }\n\n                // check for write error\n                if (_client-&gt;getWriteError()) {\n                    log_d(\"stream write error %d\", _client-&gt;getWriteError());\n                    free(buff);\n                    return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n                }\n\n                // count bytes to read left\n                if (len &gt; 0) {\n                    len -= readBytes;\n                }\n\n                delay(0);\n            } else {\n                delay(1);\n            }\n        }\n\n        free(buff);\n\n        if (size &amp;&amp; (int)size != bytesWritten) {\n            log_d(\"Stream payload bytesWritten %d and size %d mismatch!.\", bytesWritten, size);\n            log_d(\"ERROR SEND PAYLOAD FAILED!\");\n            return returnError(HTTPC_ERROR_SEND_PAYLOAD_FAILED);\n        } else {\n            log_d(\"Stream payload written: %d\", bytesWritten);\n        }\n\n    } else {\n        log_d(\"too less ram! need %d\", HTTP_TCP_BUFFER_SIZE);\n        return returnError(HTTPC_ERROR_TOO_LESS_RAM);\n    }\n\n    // handle Server Response (Header)\n    return returnError(handleHeaderResponse());\n}\n\nint HTTPClient::getSize(void) {\n    return _size;\n}\n\nWiFiClient &amp;HTTPClient::getStream(void) {\n    if (connected()) {\n        return *_client;\n    }\n\n    log_w(\"getStream: not connected\");\n    static WiFiClient empty;\n    return empty;\n}\n\nWiFiClient *HTTPClient::getStreamPtr(void) {\n    if (connected()) {\n        return _client;\n    }\n\n    log_w(\"getStreamPtr: not connected\");\n    return nullptr;\n}\n\nint HTTPClient::writeToStream(Stream *stream) {\n\n    if (!stream) {\n        return returnError(HTTPC_ERROR_NO_STREAM);\n    }\n\n    if (!connected()) {\n        return returnError(HTTPC_ERROR_NOT_CONNECTED);\n    }\n\n    // get length of document (is -1 when Server sends no Content-Length header)\n    int len = _size;\n    int ret = 0;\n\n    if (_transferEncoding == HTTPC_TE_IDENTITY) {\n        ret = writeToStreamDataBlock(stream, len);\n\n        // have we an error?\n        if (ret &lt; 0) {\n            return returnError(ret);\n        }\n    } else if (_transferEncoding == HTTPC_TE_CHUNKED) {\n        int size = 0;\n        while (1) {\n            if (!connected()) {\n                return returnError(HTTPC_ERROR_CONNECTION_LOST);\n            }\n            String chunkHeader = _client-&gt;readStringUntil('\\n');\n\n            if (chunkHeader.length() &lt;= 0) {\n                return returnError(HTTPC_ERROR_READ_TIMEOUT);\n            }\n\n            chunkHeader.trim(); // remove \\r\n\n            // read size of chunk\n            len = (uint32_t)strtol((const char *)chunkHeader.c_str(), NULL, 16);\n            size += len;\n            log_d(\" read chunk len: %d\", len);\n\n            // data left?\n            if (len &gt; 0) {\n                int r = writeToStreamDataBlock(stream, len);\n                if (r &lt; 0) {\n                    // error in writeToStreamDataBlock\n                    return returnError(r);\n                }\n                ret += r;\n            } else {\n\n                // if no length Header use global chunk size\n                if (_size &lt;= 0) {\n                    _size = size;\n                }\n\n                // check if we have write all data out\n                if (ret != _size) {\n                    return returnError(HTTPC_ERROR_STREAM_WRITE);\n                }\n                break;\n            }\n\n            // read trailing \\r\\n at the end of the chunk\n            char buf[2];\n            auto trailing_seq_len = _client-&gt;readBytes((uint8_t *)buf, 2);\n            if (trailing_seq_len != 2 || buf[0] != '\\r' || buf[1] != '\\n') {\n                return returnError(HTTPC_ERROR_READ_TIMEOUT);\n            }\n\n            delay(0);\n        }\n    } else {\n        return returnError(HTTPC_ERROR_ENCODING);\n    }\n\n    //    end();\n    disconnect(true);\n    return ret;\n}\n\n/* String HTTPClient::getString(void) {\n    // _size can be -1 when Server sends no Content-Length header\n    if (_size &gt; 0 || _size == -1) {\n        StreamString sstring;\n        // try to reserve needed memory (noop if _size == -1)\n        if (sstring.reserve((_size + 1))) {\n            writeToStream(&amp;sstring);\n            return sstring;\n        } else {\n            log_d(\"not enough memory to reserve a string! need: %d\", (_size + 1));\n        }\n    }\n\n    return \"\";\n} */\n\nString HTTPClient::errorToString(int error) {\n    switch (error) {\n        case HTTPC_ERROR_CONNECTION_REFUSED:\n            return F(\"connection refused\");\n        case HTTPC_ERROR_SEND_HEADER_FAILED:\n            return F(\"send header failed\");\n        case HTTPC_ERROR_SEND_PAYLOAD_FAILED:\n            return F(\"send payload failed\");\n        case HTTPC_ERROR_NOT_CONNECTED:\n            return F(\"not connected\");\n        case HTTPC_ERROR_CONNECTION_LOST:\n            return F(\"connection lost\");\n        case HTTPC_ERROR_NO_STREAM:\n            return F(\"no stream\");\n        case HTTPC_ERROR_NO_HTTP_SERVER:\n            return F(\"no HTTP server\");\n        case HTTPC_ERROR_TOO_LESS_RAM:\n            return F(\"too less ram\");\n        case HTTPC_ERROR_ENCODING:\n            return F(\"Transfer-Encoding not supported\");\n        case HTTPC_ERROR_STREAM_WRITE:\n            return F(\"Stream write error\");\n        case HTTPC_ERROR_READ_TIMEOUT:\n            return F(\"read Timeout\");\n        default:\n            return String();\n    }\n}\n\nvoid HTTPClient::addHeader(const String &amp;name, const String &amp;value, bool first, bool replace) {\n    // not allow set of Header handled by code\n    if (!name.equalsIgnoreCase(F(\"Connection\")) &amp;&amp; !name.equalsIgnoreCase(F(\"User-Agent\")) &amp;&amp;\n        !name.equalsIgnoreCase(F(\"Host\")) &amp;&amp;\n        !(name.equalsIgnoreCase(F(\"Authorization\")) &amp;&amp; _base64Authorization.length())) {\n\n        String headerLine = name;\n        headerLine += \": \";\n\n        if (replace) {\n            int headerStart = _headers.indexOf(headerLine);\n            if (headerStart != -1 &amp;&amp; (headerStart == 0 || _headers[headerStart - 1] == '\\n')) {\n                int headerEnd = _headers.indexOf('\\n', headerStart);\n                _headers      = _headers.substring(0, headerStart) + _headers.substring(headerEnd + 1);\n            }\n        }\n\n        headerLine += value;\n        headerLine += \"\\r\\n\";\n        if (first) {\n            _headers = headerLine + _headers;\n        } else {\n            _headers += headerLine;\n        }\n    }\n}\n\nvoid HTTPClient::collectHeaders(const char *headerKeys[], const size_t headerKeysCount) {\n    _headerKeysCount = headerKeysCount;\n    if (_currentHeaders) {\n        delete[] _currentHeaders;\n    }\n    _currentHeaders = new RequestArgument[_headerKeysCount];\n    for (size_t i = 0; i &lt; _headerKeysCount; i++) {\n        _currentHeaders[i].key = headerKeys[i];\n    }\n}\n\nString HTTPClient::header(const char *name) {\n    for (size_t i = 0; i &lt; _headerKeysCount; ++i) {\n        if (_currentHeaders[i].key == name) {\n            return _currentHeaders[i].value;\n        }\n    }\n    return String();\n}\n\nString HTTPClient::header(size_t i) {\n    if (i &lt; _headerKeysCount) {\n        return _currentHeaders[i].value;\n    }\n    return String();\n}\n\nString HTTPClient::headerName(size_t i) {\n    if (i &lt; _headerKeysCount) {\n        return _currentHeaders[i].key;\n    }\n    return String();\n}\n\nint HTTPClient::headers() {\n    return _headerKeysCount;\n}\n\nbool HTTPClient::hasHeader(const char *name) {\n    for (size_t i = 0; i &lt; _headerKeysCount; ++i) {\n        if ((_currentHeaders[i].key == name) &amp;&amp; (_currentHeaders[i].value.length() &gt; 0)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool HTTPClient::connect(void) {\n    if (connected()) {\n        if (_reuse) {\n            log_d(\"already connected, reusing connection\");\n        } else {\n            log_d(\"already connected, try reuse!\");\n        }\n        while (_client-&gt;available() &gt; 0) {\n            _client-&gt;read();\n        }\n        return true;\n    }\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_transportTraits &amp;&amp; !_client) {\n        _tcpDeprecated = _transportTraits-&gt;create();\n        if (!_tcpDeprecated) {\n            log_e(\"failed to create client\");\n            return false;\n        }\n        _client = _tcpDeprecated.get();\n    }\n#endif\n\n    if (!_client) {\n        log_d(\"HTTPClient::begin was not called or returned error\");\n        return false;\n    }\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    if (_tcpDeprecated &amp;&amp; !_transportTraits-&gt;verify(*_client, _host.c_str())) {\n        log_d(\"transport level verify failed\");\n        _client-&gt;stop();\n        return false;\n    }\n#endif\n    if (!_client-&gt;connect(_host.c_str(), _port, _connectTimeout)) {\n        log_d(\"failed connect to %s:%u\", _host.c_str(), _port);\n        return false;\n    }\n\n    // set Timeout for WiFiClient and for Stream::readBytesUntil() and Stream::readStringUntil()\n    _client-&gt;setTimeout((_tcpTimeout + 500) / 1000);\n\n    log_d(\" connected to %s:%u\", _host.c_str(), _port);\n\n    /*\n    #ifdef ESP8266\n        _client-&gt;setNoDelay(true);\n    #endif\n     */\n    return connected();\n}\n\nbool HTTPClient::sendHeader(const char *type) {\n    if (!connected()) {\n        return false;\n    }\n\n    String header = String(type) + \" \" + _uri + F(\" HTTP/1.\");\n\n    if (_useHTTP10) {\n        header += \"0\";\n    } else {\n        header += \"1\";\n    }\n\n    header += String(F(\"\\r\\nHost: \")) + _host;\n    if (_port != 80 &amp;&amp; _port != 443) {\n        header += ':';\n        header += String(_port);\n    }\n    header += String(F(\"\\r\\nUser-Agent: \")) + _userAgent + F(\"\\r\\nConnection: \");\n\n    if (_reuse) {\n        header += F(\"keep-alive\");\n    } else {\n        header += F(\"close\");\n    }\n    header += \"\\r\\n\";\n\n    if (!_useHTTP10) {\n        header += F(\"Accept-Encoding: identity;q=1,chunked;q=0.1,*;q=0\\r\\n\");\n    }\n\n    if (_base64Authorization.length()) {\n        _base64Authorization.replace(\"\\n\", \"\");\n        header += F(\"Authorization: \");\n        header += _authorizationType;\n        header += \" \";\n        header += _base64Authorization;\n        header += \"\\r\\n\";\n    }\n\n    header += _headers + \"\\r\\n\";\n\n    return (_client-&gt;write((const uint8_t *)header.c_str(), header.length()) == header.length());\n}\n\nint HTTPClient::handleHeaderResponse() {\n\n    if (!connected()) {\n        return HTTPC_ERROR_NOT_CONNECTED;\n    }\n\n    _returnCode = 0;\n    _size       = -1;\n    _canReuse   = _reuse;\n\n    String transferEncoding;\n\n    _transferEncoding          = HTTPC_TE_IDENTITY;\n    unsigned long lastDataTime = millis();\n    bool firstLine             = true;\n    String date;\n\n    while (connected()) {\n        size_t len = _client-&gt;available();\n        if (len &gt; 0) {\n            String headerLine = _client-&gt;readStringUntil('\\n');\n            headerLine.trim(); // remove \\r\n\n            lastDataTime = millis();\n\n            log_v(\"RX: '%s'\", headerLine.c_str());\n\n            if (firstLine) {\n                firstLine = false;\n                if (_canReuse &amp;&amp; headerLine.startsWith(\"HTTP/1.\")) {\n                    _canReuse = (headerLine[sizeof \"HTTP/1.\" - 1] != '0');\n                }\n                int codePos = headerLine.indexOf(' ') + 1;\n                _returnCode = headerLine.substring(codePos, headerLine.indexOf(' ', codePos)).toInt();\n            } else if (headerLine.indexOf(':')) {\n                String headerName  = headerLine.substring(0, headerLine.indexOf(':'));\n                String headerValue = headerLine.substring(headerLine.indexOf(':') + 1);\n                headerValue.trim();\n\n                if (headerName.equalsIgnoreCase(\"Date\")) {\n                    date = headerValue;\n                }\n\n                if (headerName.equalsIgnoreCase(\"Content-Length\")) {\n                    _size = headerValue.toInt();\n                }\n\n                if (_canReuse &amp;&amp; headerName.equalsIgnoreCase(\"Connection\")) {\n                    if (headerValue.indexOf(\"close\") &gt;= 0 &amp;&amp; headerValue.indexOf(\"keep-alive\") &lt; 0) {\n                        _canReuse = false;\n                    }\n                }\n\n                if (headerName.equalsIgnoreCase(\"Transfer-Encoding\")) {\n                    transferEncoding = headerValue;\n                }\n\n                if (headerName.equalsIgnoreCase(\"Location\")) {\n                    _location = headerValue;\n                }\n\n                if (headerName.equalsIgnoreCase(\"Set-Cookie\")) {\n                    setCookie(date, headerValue);\n                }\n\n                for (size_t i = 0; i &lt; _headerKeysCount; i++) {\n                    if (_currentHeaders[i].key.equalsIgnoreCase(headerName)) {\n                        // Uncomment the following lines if you need to add support for multiple headers with the same\n                        // key: if (!_currentHeaders[i].value.isEmpty()) {\n                        //     // Existing value, append this one with a comma\n                        //     _currentHeaders[i].value += ',';\n                        //     _currentHeaders[i].value += headerValue;\n                        // } else {\n                        _currentHeaders[i].value = headerValue;\n                        // }\n                        break; // We found a match, stop looking\n                    }\n                }\n            }\n\n            if (headerLine == \"\") {\n                log_d(\"code: %d\", _returnCode);\n\n                if (_size &gt; 0) {\n                    log_d(\"size: %d\", _size);\n                }\n\n                if (transferEncoding.length() &gt; 0) {\n                    log_d(\"Transfer-Encoding: %s\", transferEncoding.c_str());\n                    if (transferEncoding.equalsIgnoreCase(\"chunked\")) {\n                        _transferEncoding = HTTPC_TE_CHUNKED;\n                    } else if (transferEncoding.equalsIgnoreCase(\"identity\")) {\n                        _transferEncoding = HTTPC_TE_IDENTITY;\n                    } else {\n                        return HTTPC_ERROR_ENCODING;\n                    }\n                } else {\n                    _transferEncoding = HTTPC_TE_IDENTITY;\n                }\n\n                if (_returnCode) {\n                    return _returnCode;\n                } else {\n                    log_d(\"Remote host is not an HTTP Server!\");\n                    return HTTPC_ERROR_NO_HTTP_SERVER;\n                }\n            }\n\n        } else {\n            if ((millis() - lastDataTime) &gt; _tcpTimeout) {\n                return HTTPC_ERROR_READ_TIMEOUT;\n            }\n            delay(10);\n        }\n    }\n\n    return HTTPC_ERROR_CONNECTION_LOST;\n}\n\nint HTTPClient::writeToStreamDataBlock(Stream *stream, int size) {\n    int buff_size    = HTTP_TCP_BUFFER_SIZE;\n    int len          = size;\n    int bytesWritten = 0;\n\n    // if possible create smaller buffer then HTTP_TCP_BUFFER_SIZE\n    if ((len &gt; 0) &amp;&amp; (len &lt; HTTP_TCP_BUFFER_SIZE)) {\n        buff_size = len;\n    }\n\n    // create buffer for read\n    uint8_t *buff = (uint8_t *)malloc(buff_size);\n\n    if (buff) {\n        // read all data from server\n        while (connected() &amp;&amp; (len &gt; 0 || len == -1)) {\n\n            // get available data size\n            size_t sizeAvailable = _client-&gt;available();\n\n            if (sizeAvailable) {\n\n                int readBytes = sizeAvailable;\n\n                // read only the asked bytes\n                if (len &gt; 0 &amp;&amp; readBytes &gt; len) {\n                    readBytes = len;\n                }\n\n                // not read more the buffer can handle\n                if (readBytes &gt; buff_size) {\n                    readBytes = buff_size;\n                }\n\n                // stop if no more reading\n                if (readBytes == 0)\n                    break;\n\n                // read data\n                int bytesRead = _client-&gt;readBytes(buff, readBytes);\n\n                // write it to Stream\n                int bytesWrite = stream-&gt;write(buff, bytesRead);\n                bytesWritten += bytesWrite;\n\n                // are all Bytes a writen to stream ?\n                if (bytesWrite != bytesRead) {\n                    log_d(\"short write asked for %d but got %d retry...\", bytesRead, bytesWrite);\n\n                    // check for write error\n                    if (stream-&gt;getWriteError()) {\n                        log_d(\"stream write error %d\", stream-&gt;getWriteError());\n\n                        // reset write error for retry\n                        stream-&gt;clearWriteError();\n                    }\n\n                    // some time for the stream\n                    delay(1);\n\n                    int leftBytes = (readBytes - bytesWrite);\n\n                    // retry to send the missed bytes\n                    bytesWrite = stream-&gt;write((buff + bytesWrite), leftBytes);\n                    bytesWritten += bytesWrite;\n\n                    if (bytesWrite != leftBytes) {\n                        // failed again\n                        log_w(\"short write asked for %d but got %d failed.\", leftBytes, bytesWrite);\n                        free(buff);\n                        return HTTPC_ERROR_STREAM_WRITE;\n                    }\n                }\n\n                // check for write error\n                if (stream-&gt;getWriteError()) {\n                    log_w(\"stream write error %d\", stream-&gt;getWriteError());\n                    free(buff);\n                    return HTTPC_ERROR_STREAM_WRITE;\n                }\n\n                // count bytes to read left\n                if (len &gt; 0) {\n                    len -= readBytes;\n                }\n\n                delay(0);\n            } else {\n                delay(1);\n            }\n        }\n\n        free(buff);\n\n        log_d(\"connection closed or file end (written: %d).\", bytesWritten);\n\n        if ((size &gt; 0) &amp;&amp; (size != bytesWritten)) {\n            log_d(\"bytesWritten %d and size %d mismatch!.\", bytesWritten, size);\n            return HTTPC_ERROR_STREAM_WRITE;\n        }\n\n    } else {\n        log_w(\"too less ram! need %d\", HTTP_TCP_BUFFER_SIZE);\n        return HTTPC_ERROR_TOO_LESS_RAM;\n    }\n\n    return bytesWritten;\n}\n\nint HTTPClient::returnError(int error) {\n    if (error &lt; 0) {\n        log_w(\"error(%d): %s\", error, errorToString(error).c_str());\n        if (connected()) {\n            log_d(\"tcp stop\");\n            _client-&gt;stop();\n        }\n    }\n    return error;\n}\n\nvoid HTTPClient::setFollowRedirects(followRedirects_t follow) {\n    _followRedirects = follow;\n}\n\nvoid HTTPClient::setRedirectLimit(uint16_t limit) {\n    _redirectLimit = limit;\n}\n\nbool HTTPClient::setURL(const String &amp;url) {\n    // if the new location is only a path then only update the URI\n    if (url &amp;&amp; url[0] == '/') {\n        _uri = url;\n        clear();\n        return true;\n    }\n\n    if (!url.startsWith(_protocol + ':')) {\n        log_d(\"new URL not the same protocol, expected '%s', URL: '%s'\\n\", _protocol.c_str(), url.c_str());\n        return false;\n    }\n\n    // check if the port is specified\n    int indexPort = url.indexOf(':', 6); // find the first ':' excluding the one from the protocol\n    int indexURI  = url.indexOf('/', 7); // find where the URI starts to make sure the ':' is not part of it\n    if (indexPort == -1 || indexPort &gt; indexURI) {\n        // the port is not specified\n        _port = (_protocol == \"https\" ? 443 : 80);\n    }\n\n    // disconnect but preserve _client.\n    // Also have to keep the connection otherwise it will free some of the memory used by _client\n    // and will blow up later when trying to do _client-&gt;available() or similar\n    _canReuse = true;\n    disconnect(true);\n    return beginInternal(url, _protocol.c_str());\n}\n\nconst String &amp;HTTPClient::getLocation(void) {\n    return _location;\n}\n\nvoid HTTPClient::setCookieJar(CookieJar *cookieJar) {\n    _cookieJar = cookieJar;\n}\n\nvoid HTTPClient::resetCookieJar() {\n    _cookieJar = nullptr;\n}\n\nvoid HTTPClient::clearAllCookies() {\n    if (_cookieJar)\n        _cookieJar-&gt;clear();\n}\n\nvoid HTTPClient::setCookie(String date, String headerValue) {\n    if (!_cookieJar) {\n        return;\n    }\n#define HTTP_TIME_PATTERN \"%a, %d %b %Y %H:%M:%S\"\n\n    Cookie cookie;\n    String value;\n    int pos1, pos2;\n\n    headerValue.toLowerCase();\n\n    struct tm tm;\n    strptime(date.c_str(), HTTP_TIME_PATTERN, &amp;tm);\n    cookie.date = mktime(&amp;tm);\n\n    pos1 = headerValue.indexOf('=');\n    pos2 = headerValue.indexOf(';');\n\n    if (pos1 &gt;= 0 &amp;&amp; pos2 &gt; pos1) {\n        cookie.name  = headerValue.substring(0, pos1);\n        cookie.value = headerValue.substring(pos1 + 1, pos2);\n    } else {\n        return; // invalid cookie header\n    }\n\n    // expires\n    if (headerValue.indexOf(\"expires=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"expires=\") + strlen(\"expires=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            value = headerValue.substring(pos1, pos2);\n        else\n            value = headerValue.substring(pos1);\n\n        strptime(value.c_str(), HTTP_TIME_PATTERN, &amp;tm);\n        cookie.expires.date  = mktime(&amp;tm);\n        cookie.expires.valid = true;\n    }\n\n    // max-age\n    if (headerValue.indexOf(\"max-age=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"max-age=\") + strlen(\"max-age=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            value = headerValue.substring(pos1, pos2);\n        else\n            value = headerValue.substring(pos1);\n\n        cookie.max_age.duration = value.toInt();\n        cookie.max_age.valid    = true;\n    }\n\n    // domain\n    if (headerValue.indexOf(\"domain=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"domain=\") + strlen(\"domain=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            value = headerValue.substring(pos1, pos2);\n        else\n            value = headerValue.substring(pos1);\n\n        if (value.startsWith(\".\"))\n            value.remove(0, 1);\n\n        if (_host.indexOf(value) &gt;= 0) {\n            cookie.domain = value;\n        } else {\n            return; // server tries to set a cookie on a different domain; ignore it\n        }\n    } else {\n        pos1 = _host.lastIndexOf('.', _host.lastIndexOf('.') - 1);\n        if (pos1 &gt;= 0)\n            cookie.domain = _host.substring(pos1 + 1);\n        else\n            cookie.domain = _host;\n    }\n\n    // path\n    if (headerValue.indexOf(\"path=\") &gt;= 0) {\n        pos1 = headerValue.indexOf(\"path=\") + strlen(\"path=\");\n        pos2 = headerValue.indexOf(';', pos1);\n\n        if (pos2 &gt; pos1)\n            cookie.path = headerValue.substring(pos1, pos2);\n        else\n            cookie.path = headerValue.substring(pos1);\n    }\n\n    // HttpOnly\n    cookie.http_only = (headerValue.indexOf(\"httponly\") &gt;= 0);\n\n    // secure\n    cookie.secure = (headerValue.indexOf(\"secure\") &gt;= 0);\n\n    // overwrite or delete cookie in/from cookie jar\n    time_t now_local = time(NULL);\n    time_t now_gmt   = mktime(gmtime(&amp;now_local));\n\n    bool found = false;\n\n    for (auto c = _cookieJar-&gt;begin(); c != _cookieJar-&gt;end(); ++c) {\n        if (c-&gt;domain == cookie.domain &amp;&amp; c-&gt;name == cookie.name) {\n            // when evaluating, max-age takes precedence over expires if both are defined\n            if ((cookie.max_age.valid &amp;&amp; ((cookie.date + cookie.max_age.duration) &lt; now_gmt)) ||\n                cookie.max_age.duration &lt;= 0 ||\n                (!cookie.max_age.valid &amp;&amp; cookie.expires.valid &amp;&amp; cookie.expires.date &lt; now_gmt)) {\n                _cookieJar-&gt;erase(c);\n                c--;\n            } else {\n                *c = cookie;\n            }\n            found = true;\n        }\n    }\n\n    // add cookie to jar\n    if (!found &amp;&amp; !(cookie.max_age.valid &amp;&amp; cookie.max_age.duration &lt;= 0))\n        _cookieJar-&gt;push_back(cookie);\n}\n\nbool HTTPClient::generateCookieString(String *cookieString) {\n    time_t now_local = time(NULL);\n    time_t now_gmt   = mktime(gmtime(&amp;now_local));\n\n    *cookieString = \"\";\n    bool found    = false;\n\n    if (!_cookieJar) {\n        return false;\n    }\n    for (auto c = _cookieJar-&gt;begin(); c != _cookieJar-&gt;end(); ++c) {\n        if ((c-&gt;max_age.valid &amp;&amp; ((c-&gt;date + c-&gt;max_age.duration) &lt; now_gmt)) ||\n            (!c-&gt;max_age.valid &amp;&amp; c-&gt;expires.valid &amp;&amp; c-&gt;expires.date &lt; now_gmt)) {\n            _cookieJar-&gt;erase(c);\n            c--;\n        } else if (_host.indexOf(c-&gt;domain) &gt;= 0 &amp;&amp; (!c-&gt;secure || _secure)) {\n            if (*cookieString == \"\")\n                *cookieString = c-&gt;name + \"=\" + c-&gt;value;\n            else\n                *cookieString += \" ;\" + c-&gt;name + \"=\" + c-&gt;value;\n            found = true;\n        }\n    }\n\n    return found;\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/","title":"File HTTPClient.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; HTTPClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;WiFiClient.h&gt;</code></li> <li><code>#include &lt;WiFiClientSecure.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_h_t_t_p_client_8h/#classes","title":"Classes","text":"Type Name     struct Cookie    class HTTPClient    struct RequestArgument"},{"location":"ltapi/_h_t_t_p_client_8h/#public-types","title":"Public Types","text":"Type Name     typedef std::vector&lt; Cookie &gt; CookieJar    typedef std::unique_ptr&lt; TransportTraits &gt; TransportTraitsPtr    enum followRedirects_t    enum t_http_codes HTTP codes see RFC7231.   enum transferEncoding_t"},{"location":"ltapi/_h_t_t_p_client_8h/#macros","title":"Macros","text":"Type Name     define HTTPCLIENT_1_1_COMPATIBLE    define HTTPCLIENT_DEFAULT_TCP_TIMEOUT  (5000)Cookie jar support.   define HTTPC_ERROR_CONNECTION_LOST  (-5)   define HTTPC_ERROR_CONNECTION_REFUSED  (-1)HTTP client errors.   define HTTPC_ERROR_ENCODING  (-9)   define HTTPC_ERROR_NOT_CONNECTED  (-4)   define HTTPC_ERROR_NO_HTTP_SERVER  (-7)   define HTTPC_ERROR_NO_STREAM  (-6)   define HTTPC_ERROR_READ_TIMEOUT  (-11)   define HTTPC_ERROR_SEND_HEADER_FAILED  (-2)   define HTTPC_ERROR_SEND_PAYLOAD_FAILED  (-3)   define HTTPC_ERROR_STREAM_WRITE  (-10)   define HTTPC_ERROR_TOO_LESS_RAM  (-8)   define HTTP_TCP_BUFFER_SIZE  (1460)size for the stream handling"},{"location":"ltapi/_h_t_t_p_client_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_h_t_t_p_client_8h/#typedef-cookiejar","title":"typedef CookieJar","text":"<pre><code>typedef std::vector&lt;Cookie&gt; CookieJar;\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#typedef-transporttraitsptr","title":"typedef TransportTraitsPtr","text":"<pre><code>typedef std::unique_ptr&lt;TransportTraits&gt; TransportTraitsPtr;\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#enum-followredirects_t","title":"enum followRedirects_t","text":"<pre><code>enum followRedirects_t {\n    HTTPC_DISABLE_FOLLOW_REDIRECTS,\n    HTTPC_STRICT_FOLLOW_REDIRECTS,\n    HTTPC_FORCE_FOLLOW_REDIRECTS\n};\n</code></pre> <p>redirection follow mode. * <code>HTTPC_DISABLE_FOLLOW_REDIRECTS</code> - no redirection will be followed. * <code>HTTPC_STRICT_FOLLOW_REDIRECTS</code> - strict RFC2616, only requests using GET or HEAD methods will be redirected (using the same method), since the RFC requires end-user confirmation in other cases. * <code>HTTPC_FORCE_FOLLOW_REDIRECTS</code> - all redirections will be followed, regardless of a used method. New request will use the same method, and they will include the same body data and the same headers. In the sense of the RFC, it's just like every redirection is confirmed. </p>"},{"location":"ltapi/_h_t_t_p_client_8h/#enum-t_http_codes","title":"enum t_http_codes","text":"<pre><code>enum t_http_codes {\n    HTTP_CODE_CONTINUE = 100,\n    HTTP_CODE_SWITCHING_PROTOCOLS = 101,\n    HTTP_CODE_PROCESSING = 102,\n    HTTP_CODE_OK = 200,\n    HTTP_CODE_CREATED = 201,\n    HTTP_CODE_ACCEPTED = 202,\n    HTTP_CODE_NON_AUTHORITATIVE_INFORMATION = 203,\n    HTTP_CODE_NO_CONTENT = 204,\n    HTTP_CODE_RESET_CONTENT = 205,\n    HTTP_CODE_PARTIAL_CONTENT = 206,\n    HTTP_CODE_MULTI_STATUS = 207,\n    HTTP_CODE_ALREADY_REPORTED = 208,\n    HTTP_CODE_IM_USED = 226,\n    HTTP_CODE_MULTIPLE_CHOICES = 300,\n    HTTP_CODE_MOVED_PERMANENTLY = 301,\n    HTTP_CODE_FOUND = 302,\n    HTTP_CODE_SEE_OTHER = 303,\n    HTTP_CODE_NOT_MODIFIED = 304,\n    HTTP_CODE_USE_PROXY = 305,\n    HTTP_CODE_TEMPORARY_REDIRECT = 307,\n    HTTP_CODE_PERMANENT_REDIRECT = 308,\n    HTTP_CODE_BAD_REQUEST = 400,\n    HTTP_CODE_UNAUTHORIZED = 401,\n    HTTP_CODE_PAYMENT_REQUIRED = 402,\n    HTTP_CODE_FORBIDDEN = 403,\n    HTTP_CODE_NOT_FOUND = 404,\n    HTTP_CODE_METHOD_NOT_ALLOWED = 405,\n    HTTP_CODE_NOT_ACCEPTABLE = 406,\n    HTTP_CODE_PROXY_AUTHENTICATION_REQUIRED = 407,\n    HTTP_CODE_REQUEST_TIMEOUT = 408,\n    HTTP_CODE_CONFLICT = 409,\n    HTTP_CODE_GONE = 410,\n    HTTP_CODE_LENGTH_REQUIRED = 411,\n    HTTP_CODE_PRECONDITION_FAILED = 412,\n    HTTP_CODE_PAYLOAD_TOO_LARGE = 413,\n    HTTP_CODE_URI_TOO_LONG = 414,\n    HTTP_CODE_UNSUPPORTED_MEDIA_TYPE = 415,\n    HTTP_CODE_RANGE_NOT_SATISFIABLE = 416,\n    HTTP_CODE_EXPECTATION_FAILED = 417,\n    HTTP_CODE_MISDIRECTED_REQUEST = 421,\n    HTTP_CODE_UNPROCESSABLE_ENTITY = 422,\n    HTTP_CODE_LOCKED = 423,\n    HTTP_CODE_FAILED_DEPENDENCY = 424,\n    HTTP_CODE_UPGRADE_REQUIRED = 426,\n    HTTP_CODE_PRECONDITION_REQUIRED = 428,\n    HTTP_CODE_TOO_MANY_REQUESTS = 429,\n    HTTP_CODE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\n    HTTP_CODE_INTERNAL_SERVER_ERROR = 500,\n    HTTP_CODE_NOT_IMPLEMENTED = 501,\n    HTTP_CODE_BAD_GATEWAY = 502,\n    HTTP_CODE_SERVICE_UNAVAILABLE = 503,\n    HTTP_CODE_GATEWAY_TIMEOUT = 504,\n    HTTP_CODE_HTTP_VERSION_NOT_SUPPORTED = 505,\n    HTTP_CODE_VARIANT_ALSO_NEGOTIATES = 506,\n    HTTP_CODE_INSUFFICIENT_STORAGE = 507,\n    HTTP_CODE_LOOP_DETECTED = 508,\n    HTTP_CODE_NOT_EXTENDED = 510,\n    HTTP_CODE_NETWORK_AUTHENTICATION_REQUIRED = 511\n};\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#enum-transferencoding_t","title":"enum transferEncoding_t","text":"<pre><code>enum transferEncoding_t {\n    HTTPC_TE_IDENTITY,\n    HTTPC_TE_CHUNKED\n};\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpclient_1_1_compatible","title":"define HTTPCLIENT_1_1_COMPATIBLE","text":"<pre><code>#define HTTPCLIENT_1_1_COMPATIBLE \n</code></pre> <p>HTTPClient.h</p> <p>Created on: 02.11.2015</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the HTTPClient for Arduino. Port to ESP32 by Evandro Luis Copercini (2017), changed fingerprints to CA verification.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpclient_default_tcp_timeout","title":"define HTTPCLIENT_DEFAULT_TCP_TIMEOUT","text":"<pre><code>#define HTTPCLIENT_DEFAULT_TCP_TIMEOUT (5000)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_connection_lost","title":"define HTTPC_ERROR_CONNECTION_LOST","text":"<pre><code>#define HTTPC_ERROR_CONNECTION_LOST (-5)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_connection_refused","title":"define HTTPC_ERROR_CONNECTION_REFUSED","text":"<pre><code>#define HTTPC_ERROR_CONNECTION_REFUSED (-1)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_encoding","title":"define HTTPC_ERROR_ENCODING","text":"<pre><code>#define HTTPC_ERROR_ENCODING (-9)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_not_connected","title":"define HTTPC_ERROR_NOT_CONNECTED","text":"<pre><code>#define HTTPC_ERROR_NOT_CONNECTED (-4)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_no_http_server","title":"define HTTPC_ERROR_NO_HTTP_SERVER","text":"<pre><code>#define HTTPC_ERROR_NO_HTTP_SERVER (-7)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_no_stream","title":"define HTTPC_ERROR_NO_STREAM","text":"<pre><code>#define HTTPC_ERROR_NO_STREAM (-6)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_read_timeout","title":"define HTTPC_ERROR_READ_TIMEOUT","text":"<pre><code>#define HTTPC_ERROR_READ_TIMEOUT (-11)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_send_header_failed","title":"define HTTPC_ERROR_SEND_HEADER_FAILED","text":"<pre><code>#define HTTPC_ERROR_SEND_HEADER_FAILED (-2)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_send_payload_failed","title":"define HTTPC_ERROR_SEND_PAYLOAD_FAILED","text":"<pre><code>#define HTTPC_ERROR_SEND_PAYLOAD_FAILED (-3)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_stream_write","title":"define HTTPC_ERROR_STREAM_WRITE","text":"<pre><code>#define HTTPC_ERROR_STREAM_WRITE (-10)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-httpc_error_too_less_ram","title":"define HTTPC_ERROR_TOO_LESS_RAM","text":"<pre><code>#define HTTPC_ERROR_TOO_LESS_RAM (-8)\n</code></pre>"},{"location":"ltapi/_h_t_t_p_client_8h/#define-http_tcp_buffer_size","title":"define HTTP_TCP_BUFFER_SIZE","text":"<pre><code>#define HTTP_TCP_BUFFER_SIZE (1460)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/HTTPClient.h</code></p>"},{"location":"ltapi/_h_t_t_p_client_8h_source/","title":"File HTTPClient.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; HTTPClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef HTTPClient_H_\n#define HTTPClient_H_\n\n#ifndef HTTPCLIENT_1_1_COMPATIBLE\n#define HTTPCLIENT_1_1_COMPATIBLE\n#endif\n\n#include &lt;Arduino.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;WiFiClientSecure.h&gt;\n#include &lt;memory&gt;\n\n#include &lt;vector&gt;\n\n#define HTTPCLIENT_DEFAULT_TCP_TIMEOUT (5000)\n\n#define HTTPC_ERROR_CONNECTION_REFUSED  (-1)\n#define HTTPC_ERROR_SEND_HEADER_FAILED  (-2)\n#define HTTPC_ERROR_SEND_PAYLOAD_FAILED (-3)\n#define HTTPC_ERROR_NOT_CONNECTED       (-4)\n#define HTTPC_ERROR_CONNECTION_LOST     (-5)\n#define HTTPC_ERROR_NO_STREAM           (-6)\n#define HTTPC_ERROR_NO_HTTP_SERVER      (-7)\n#define HTTPC_ERROR_TOO_LESS_RAM        (-8)\n#define HTTPC_ERROR_ENCODING            (-9)\n#define HTTPC_ERROR_STREAM_WRITE        (-10)\n#define HTTPC_ERROR_READ_TIMEOUT        (-11)\n\n#define HTTP_TCP_BUFFER_SIZE (1460)\n\ntypedef enum {\n    HTTP_CODE_CONTINUE                        = 100,\n    HTTP_CODE_SWITCHING_PROTOCOLS             = 101,\n    HTTP_CODE_PROCESSING                      = 102,\n    HTTP_CODE_OK                              = 200,\n    HTTP_CODE_CREATED                         = 201,\n    HTTP_CODE_ACCEPTED                        = 202,\n    HTTP_CODE_NON_AUTHORITATIVE_INFORMATION   = 203,\n    HTTP_CODE_NO_CONTENT                      = 204,\n    HTTP_CODE_RESET_CONTENT                   = 205,\n    HTTP_CODE_PARTIAL_CONTENT                 = 206,\n    HTTP_CODE_MULTI_STATUS                    = 207,\n    HTTP_CODE_ALREADY_REPORTED                = 208,\n    HTTP_CODE_IM_USED                         = 226,\n    HTTP_CODE_MULTIPLE_CHOICES                = 300,\n    HTTP_CODE_MOVED_PERMANENTLY               = 301,\n    HTTP_CODE_FOUND                           = 302,\n    HTTP_CODE_SEE_OTHER                       = 303,\n    HTTP_CODE_NOT_MODIFIED                    = 304,\n    HTTP_CODE_USE_PROXY                       = 305,\n    HTTP_CODE_TEMPORARY_REDIRECT              = 307,\n    HTTP_CODE_PERMANENT_REDIRECT              = 308,\n    HTTP_CODE_BAD_REQUEST                     = 400,\n    HTTP_CODE_UNAUTHORIZED                    = 401,\n    HTTP_CODE_PAYMENT_REQUIRED                = 402,\n    HTTP_CODE_FORBIDDEN                       = 403,\n    HTTP_CODE_NOT_FOUND                       = 404,\n    HTTP_CODE_METHOD_NOT_ALLOWED              = 405,\n    HTTP_CODE_NOT_ACCEPTABLE                  = 406,\n    HTTP_CODE_PROXY_AUTHENTICATION_REQUIRED   = 407,\n    HTTP_CODE_REQUEST_TIMEOUT                 = 408,\n    HTTP_CODE_CONFLICT                        = 409,\n    HTTP_CODE_GONE                            = 410,\n    HTTP_CODE_LENGTH_REQUIRED                 = 411,\n    HTTP_CODE_PRECONDITION_FAILED             = 412,\n    HTTP_CODE_PAYLOAD_TOO_LARGE               = 413,\n    HTTP_CODE_URI_TOO_LONG                    = 414,\n    HTTP_CODE_UNSUPPORTED_MEDIA_TYPE          = 415,\n    HTTP_CODE_RANGE_NOT_SATISFIABLE           = 416,\n    HTTP_CODE_EXPECTATION_FAILED              = 417,\n    HTTP_CODE_MISDIRECTED_REQUEST             = 421,\n    HTTP_CODE_UNPROCESSABLE_ENTITY            = 422,\n    HTTP_CODE_LOCKED                          = 423,\n    HTTP_CODE_FAILED_DEPENDENCY               = 424,\n    HTTP_CODE_UPGRADE_REQUIRED                = 426,\n    HTTP_CODE_PRECONDITION_REQUIRED           = 428,\n    HTTP_CODE_TOO_MANY_REQUESTS               = 429,\n    HTTP_CODE_REQUEST_HEADER_FIELDS_TOO_LARGE = 431,\n    HTTP_CODE_INTERNAL_SERVER_ERROR           = 500,\n    HTTP_CODE_NOT_IMPLEMENTED                 = 501,\n    HTTP_CODE_BAD_GATEWAY                     = 502,\n    HTTP_CODE_SERVICE_UNAVAILABLE             = 503,\n    HTTP_CODE_GATEWAY_TIMEOUT                 = 504,\n    HTTP_CODE_HTTP_VERSION_NOT_SUPPORTED      = 505,\n    HTTP_CODE_VARIANT_ALSO_NEGOTIATES         = 506,\n    HTTP_CODE_INSUFFICIENT_STORAGE            = 507,\n    HTTP_CODE_LOOP_DETECTED                   = 508,\n    HTTP_CODE_NOT_EXTENDED                    = 510,\n    HTTP_CODE_NETWORK_AUTHENTICATION_REQUIRED = 511\n} t_http_codes;\n\ntypedef enum { HTTPC_TE_IDENTITY, HTTPC_TE_CHUNKED } transferEncoding_t;\n\ntypedef enum {\n    HTTPC_DISABLE_FOLLOW_REDIRECTS,\n    HTTPC_STRICT_FOLLOW_REDIRECTS,\n    HTTPC_FORCE_FOLLOW_REDIRECTS\n} followRedirects_t;\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\nclass TransportTraits;\ntypedef std::unique_ptr&lt;TransportTraits&gt; TransportTraitsPtr;\n#endif\n\n// cookie jar support\ntypedef struct {\n    String host; // host which tries to set the cookie\n    time_t date; // timestamp of the response that set the cookie\n    String name;\n    String value;\n    String domain;\n    String path = \"\";\n\n    struct {\n        time_t date = 0;\n        bool valid  = false;\n    } expires;\n\n    struct {\n        time_t duration = 0;\n        bool valid      = false;\n    } max_age;\n\n    bool http_only = false;\n    bool secure    = false;\n} Cookie;\n\ntypedef std::vector&lt;Cookie&gt; CookieJar;\n\nclass HTTPClient {\n  public:\n    HTTPClient();\n    ~HTTPClient();\n\n    /*\n     * Since both begin() functions take a reference to client as a parameter, you need to\n     * ensure the client object lives the entire time of the HTTPClient\n     */\n    bool begin(WiFiClient &amp;client, String url);\n    bool begin(WiFiClient &amp;client, String host, uint16_t port, String uri = \"/\", bool https = false);\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    bool begin(String url);\n    bool begin(String url, const char *CAcert);\n    bool begin(String host, uint16_t port, String uri = \"/\");\n    bool begin(String host, uint16_t port, String uri, const char *CAcert);\n    bool begin(String host, uint16_t port, String uri, const char *CAcert, const char *cli_cert, const char *cli_key);\n#endif\n\n    void end(void);\n\n    bool connected(void);\n\n    void setReuse(bool reuse); \n    void setUserAgent(const String &amp;userAgent);\n    void setAuthorization(const char *user, const char *password);\n    void setAuthorization(const char *auth);\n    void setAuthorizationType(const char *authType);\n    void setConnectTimeout(int32_t connectTimeout);\n    void setTimeout(uint16_t timeout);\n\n    // Redirections\n    void setFollowRedirects(followRedirects_t follow);\n    void setRedirectLimit(uint16_t limit); // max redirects to follow for a single request\n\n    bool setURL(const String &amp;url);\n    void useHTTP10(bool usehttp10 = true);\n\n    int GET();\n    int PATCH(uint8_t *payload, size_t size);\n    int PATCH(String payload);\n    int POST(uint8_t *payload, size_t size);\n    int POST(String payload);\n    int PUT(uint8_t *payload, size_t size);\n    int PUT(String payload);\n    int sendRequest(const char *type, String payload);\n    int sendRequest(const char *type, uint8_t *payload = NULL, size_t size = 0);\n    int sendRequest(const char *type, Stream *stream, size_t size = 0);\n\n    void addHeader(const String &amp;name, const String &amp;value, bool first = false, bool replace = true);\n\n    void collectHeaders(const char *headerKeys[], const size_t headerKeysCount);\n    String header(const char *name);  // get request header value by name\n    String header(size_t i);          // get request header value by number\n    String headerName(size_t i);      // get request header name by number\n    int headers();                    // get header count\n    bool hasHeader(const char *name); // check if header exists\n\n    int getSize(void);\n    const String &amp;getLocation(void);\n\n    WiFiClient &amp;getStream(void);\n    WiFiClient *getStreamPtr(void);\n    int writeToStream(Stream *stream);\n    // String getString(void);\n\n    static String errorToString(int error);\n\n    void setCookieJar(CookieJar *cookieJar);\n    void resetCookieJar();\n    void clearAllCookies();\n\n  protected:\n    struct RequestArgument {\n        String key;\n        String value;\n    };\n\n    bool beginInternal(String url, const char *expectedProtocol);\n    void disconnect(bool preserveClient = false);\n    void clear();\n    int returnError(int error);\n    bool connect(void);\n    bool sendHeader(const char *type);\n    int handleHeaderResponse();\n    int writeToStreamDataBlock(Stream *stream, int len);\n\n    void setCookie(String date, String headerValue);\n    bool generateCookieString(String *cookieString);\n\n#ifdef HTTPCLIENT_1_1_COMPATIBLE\n    TransportTraitsPtr _transportTraits;\n    std::unique_ptr&lt;WiFiClient&gt; _tcpDeprecated;\n#endif\n\n    WiFiClient *_client = nullptr;\n\n    String _host;\n    uint16_t _port          = 0;\n    int32_t _connectTimeout = -1;\n    bool _reuse             = true;\n    uint16_t _tcpTimeout    = HTTPCLIENT_DEFAULT_TCP_TIMEOUT;\n    bool _useHTTP10         = false;\n    bool _secure            = false;\n\n    String _uri;\n    String _protocol;\n    String _headers;\n    String _userAgent = \"ESP32HTTPClient\";\n    String _base64Authorization;\n    String _authorizationType = \"Basic\";\n\n    RequestArgument *_currentHeaders = nullptr;\n    size_t _headerKeysCount          = 0;\n\n    int _returnCode                    = 0;\n    int _size                          = -1;\n    bool _canReuse                     = false;\n    followRedirects_t _followRedirects = HTTPC_DISABLE_FOLLOW_REDIRECTS;\n    uint16_t _redirectLimit            = 10;\n    String _location;\n    transferEncoding_t _transferEncoding = HTTPC_TE_IDENTITY;\n\n    CookieJar *_cookieJar = nullptr;\n};\n\n#endif /* HTTPClient_H_ */\n</code></pre>"},{"location":"ltapi/dir_889e4a9d55ccd19b237d3839d868520f/","title":"Dir arduino/libretuya/libraries/HTTPClient/strptime","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; strptime</p>"},{"location":"ltapi/dir_889e4a9d55ccd19b237d3839d868520f/#files","title":"Files","text":"Type Name     file strptime.c      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/strptime/</code></p>"},{"location":"ltapi/strptime_8c/","title":"File strptime.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; strptime &gt; strptime.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;langinfo.h&gt;</code></li> <li><code>#include &lt;time.h&gt;</code></li> <li><code>#include &lt;ctype.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> <li><code>#include &lt;strings.h&gt;</code></li> </ul>"},{"location":"ltapi/strptime_8c/#public-functions","title":"Public Functions","text":"Type Name     char * strptime (const char *restrict s, const char *restrict f, struct tm *restrict tm)"},{"location":"ltapi/strptime_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strptime_8c/#function-strptime","title":"function strptime","text":"<pre><code>char * strptime (\n    const char *restrict s,\n    const char *restrict f,\n    struct tm *restrict tm\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/strptime/strptime.c</code></p>"},{"location":"ltapi/strptime_8c_source/","title":"File strptime.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; strptime &gt; strptime.c</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;langinfo.h&gt;\n#include &lt;time.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;string.h&gt;\n#include &lt;strings.h&gt;\n\nchar *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)\n{\n    int i, w, neg, adj, min, range, *dest, dummy;\n    const char *ex;\n    size_t len;\n    int want_century = 0, century = 0;\n    while (*f) {\n        if (*f != '%') {\n            if (isspace(*f)) for (; *s &amp;&amp; isspace(*s); s++);\n            else if (*s != *f) return 0;\n            else s++;\n            f++;\n            continue;\n        }\n        f++;\n        if (*f == '+') f++;\n        if (isdigit(*f)) w=strtoul(f, (void *)&amp;f, 10);\n        else w=-1;\n        adj=0;\n        switch (*f++) {\n        case 'a': case 'A':\n            dest = &amp;tm-&gt;tm_wday;\n            min = ABDAY_1;\n            range = 7;\n            goto symbolic_range;\n        case 'b': case 'B': case 'h':\n            dest = &amp;tm-&gt;tm_mon;\n            min = ABMON_1;\n            range = 12;\n            goto symbolic_range;\n        case 'c':\n            s = strptime(s, nl_langinfo(D_T_FMT), tm);\n            if (!s) return 0;\n            break;\n        case 'C':\n            dest = &amp;century;\n            if (w&lt;0) w=2;\n            want_century |= 2;\n            goto numeric_digits;\n        case 'd': case 'e':\n            dest = &amp;tm-&gt;tm_mday;\n            min = 1;\n            range = 31;\n            goto numeric_range;\n        case 'D':\n            s = strptime(s, \"%m/%d/%y\", tm);\n            if (!s) return 0;\n            break;\n        case 'H':\n            dest = &amp;tm-&gt;tm_hour;\n            min = 0;\n            range = 24;\n            goto numeric_range;\n        case 'I':\n            dest = &amp;tm-&gt;tm_hour;\n            min = 1;\n            range = 12;\n            goto numeric_range;\n        case 'j':\n            dest = &amp;tm-&gt;tm_yday;\n            min = 1;\n            range = 366;\n            goto numeric_range;\n        case 'm':\n            dest = &amp;tm-&gt;tm_mon;\n            min = 1;\n            range = 12;\n            adj = 1;\n            goto numeric_range;\n        case 'M':\n            dest = &amp;tm-&gt;tm_min;\n            min = 0;\n            range = 60;\n            goto numeric_range;\n        case 'n': case 't':\n            for (; *s &amp;&amp; isspace(*s); s++);\n            break;\n        case 'p':\n            ex = nl_langinfo(AM_STR);\n            len = strlen(ex);\n            if (!strncasecmp(s, ex, len)) {\n                tm-&gt;tm_hour %= 12;\n                break;\n            }\n            ex = nl_langinfo(PM_STR);\n            len = strlen(ex);\n            if (!strncasecmp(s, ex, len)) {\n                tm-&gt;tm_hour %= 12;\n                tm-&gt;tm_hour += 12;\n                break;\n            }\n            return 0;\n        case 'r':\n            s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);\n            if (!s) return 0;\n            break;\n        case 'R':\n            s = strptime(s, \"%H:%M\", tm);\n            if (!s) return 0;\n            break;\n        case 'S':\n            dest = &amp;tm-&gt;tm_sec;\n            min = 0;\n            range = 61;\n            goto numeric_range;\n        case 'T':\n            s = strptime(s, \"%H:%M:%S\", tm);\n            if (!s) return 0;\n            break;\n        case 'U':\n        case 'W':\n            /* Throw away result, for now. (FIXME?) */\n            dest = &amp;dummy;\n            min = 0;\n            range = 54;\n            goto numeric_range;\n        case 'w':\n            dest = &amp;tm-&gt;tm_wday;\n            min = 0;\n            range = 7;\n            goto numeric_range;\n        case 'x':\n            s = strptime(s, nl_langinfo(D_FMT), tm);\n            if (!s) return 0;\n            break;\n        case 'X':\n            s = strptime(s, nl_langinfo(T_FMT), tm);\n            if (!s) return 0;\n            break;\n        case 'y':\n            dest = &amp;tm-&gt;tm_year;\n            w = 2;\n            want_century |= 1;\n            goto numeric_digits;\n        case 'Y':\n            dest = &amp;tm-&gt;tm_year;\n            if (w&lt;0) w=4;\n            adj = 1900;\n            want_century = 0;\n            goto numeric_digits;\n        case '%':\n            if (*s++ != '%') return 0;\n            break;\n        default:\n            return 0;\n        numeric_range:\n            if (!isdigit(*s)) return 0;\n            *dest = 0;\n            for (i=1; i&lt;=min+range &amp;&amp; isdigit(*s); i*=10)\n                *dest = *dest * 10 + *s++ - '0';\n            if (*dest - min &gt;= (unsigned)range) return 0;\n            *dest -= adj;\n            switch((char *)dest - (char *)tm) {\n            case offsetof(struct tm, tm_yday):\n                ;\n            }\n            goto update;\n        numeric_digits:\n            neg = 0;\n            if (*s == '+') s++;\n            else if (*s == '-') neg=1, s++;\n            if (!isdigit(*s)) return 0;\n            for (*dest=i=0; i&lt;w &amp;&amp; isdigit(*s); i++)\n                *dest = *dest * 10 + *s++ - '0';\n            if (neg) *dest = -*dest;\n            *dest -= adj;\n            goto update;\n        symbolic_range:\n            for (i=2*range-1; i&gt;=0; i--) {\n                ex = nl_langinfo(min+i);\n                len = strlen(ex);\n                if (strncasecmp(s, ex, len)) continue;\n                s += len;\n                *dest = i % range;\n                break;\n            }\n            if (i&lt;0) return 0;\n            goto update;\n        update:\n            //FIXME\n            ;\n        }\n    }\n    if (want_century) {\n        if (want_century &amp; 2) tm-&gt;tm_year += century * 100 - 1900;\n        else if (tm-&gt;tm_year &lt;= 68) tm-&gt;tm_year += 100;\n    }\n    return (char *)s;\n}\n</code></pre>"},{"location":"ltapi/strptime_8h/","title":"File strptime.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; strptime.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;time.h&gt;</code></li> </ul>"},{"location":"ltapi/strptime_8h/#public-functions","title":"Public Functions","text":"Type Name     char * strptime (const char * buf, const char * fmt, struct tm * tm)"},{"location":"ltapi/strptime_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strptime_8h/#function-strptime","title":"function strptime","text":"<pre><code>char * strptime (\n    const char * buf,\n    const char * fmt,\n    struct tm * tm\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/HTTPClient/strptime.h</code></p>"},{"location":"ltapi/strptime_8h_source/","title":"File strptime.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; HTTPClient &gt; strptime.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-29. */\n\n#pragma once\n\n#include &lt;time.h&gt;\n\nextern char *strptime(const char *buf, const char *fmt, struct tm *tm);\n</code></pre>"},{"location":"ltapi/dir_2f510b76086cfd87d2aff1f9e9455d35/","title":"Dir arduino/libretuya/libraries/MD5","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5</p>"},{"location":"ltapi/dir_2f510b76086cfd87d2aff1f9e9455d35/#files","title":"Files","text":"Type Name     file MD5.h    file MD5HostapdImpl.h    file MD5MbedTLSImpl.cpp    file MD5MbedTLSImpl.h    file MD5PolarSSLImpl.cpp    file MD5PolarSSLImpl.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/</code></p>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/","title":"File MD5.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;MD5Impl.h&gt;</code></li> </ul>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#public-types","title":"Public Types","text":"Type Name     typedef LT_MD5_CTX_T md5_context_t"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#public-functions","title":"Public Functions","text":"Type Name     void MD5Final (unsigned char digest, LT_MD5_CTX_T * context)    void MD5Init (LT_MD5_CTX_T * context)    void MD5Update (LT_MD5_CTX_T * context, const unsigned char * buf, unsigned len)"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T  void"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#typedef-md5_context_t","title":"typedef md5_context_t","text":"<pre><code>typedef LT_MD5_CTX_T md5_context_t;\n</code></pre>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#function-md5final","title":"function MD5Final","text":"<pre><code>void MD5Final (\n    unsigned char digest,\n    LT_MD5_CTX_T * context\n) \n</code></pre>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#function-md5init","title":"function MD5Init","text":"<pre><code>void MD5Init (\n    LT_MD5_CTX_T * context\n) \n</code></pre>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#function-md5update","title":"function MD5Update","text":"<pre><code>void MD5Update (\n    LT_MD5_CTX_T * context,\n    const unsigned char * buf,\n    unsigned len\n) \n</code></pre>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T void\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/MD5.h</code></p>"},{"location":"ltapi/libraries_2_m_d5_2_m_d5_8h_source/","title":"File MD5.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-03. */\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;MD5Impl.h&gt;\n\n// available built-in implementations\n#if LT_MD5_USE_POLARSSL\n#include \"MD5PolarSSLImpl.h\"\n#endif\n#if LT_MD5_USE_MBEDTLS\n#include \"MD5MbedTLSImpl.h\"\n#endif\n#if LT_MD5_USE_HOSTAPD\n#include \"MD5HostapdImpl.h\"\n#endif\n\n// common API\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifndef LT_MD5_CTX_T\n#define LT_MD5_CTX_T void\n#endif\n\n// for compatibility with ESP8266\ntypedef LT_MD5_CTX_T md5_context_t;\n\nvoid MD5Init(LT_MD5_CTX_T *context);\nvoid MD5Update(LT_MD5_CTX_T *context, const unsigned char *buf, unsigned len);\nvoid MD5Final(unsigned char digest[16], LT_MD5_CTX_T *context);\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>"},{"location":"ltapi/_m_d5_hostapd_impl_8h/","title":"File MD5HostapdImpl.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5HostapdImpl.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;crypto/md5_i.h&gt;</code></li> </ul>"},{"location":"ltapi/_m_d5_hostapd_impl_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T  struct MD5Context"},{"location":"ltapi/_m_d5_hostapd_impl_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_m_d5_hostapd_impl_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T struct MD5Context\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/MD5HostapdImpl.h</code></p>"},{"location":"ltapi/_m_d5_hostapd_impl_8h_source/","title":"File MD5HostapdImpl.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5HostapdImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-12. */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include &lt;crypto/md5_i.h&gt;\n#define LT_MD5_CTX_T struct MD5Context\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8cpp/","title":"File MD5MbedTLSImpl.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5MbedTLSImpl.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/MD5MbedTLSImpl.cpp</code></p>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8cpp_source/","title":"File MD5MbedTLSImpl.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5MbedTLSImpl.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-11. */\n\n#if LT_ARD_HAS_MD5\n\n#include \"MD5.h\"\n\n#if LT_MD5_USE_MBEDTLS\n\nextern \"C\" {\n\nvoid MD5Init(LT_MD5_CTX_T *context) {\n    mbedtls_md5_init(context);\n    mbedtls_md5_starts(context);\n}\n\nvoid MD5Update(LT_MD5_CTX_T *context, const unsigned char *buf, unsigned len) {\n    mbedtls_md5_update(context, buf, len);\n}\n\nvoid MD5Final(unsigned char digest[16], LT_MD5_CTX_T *context) {\n    mbedtls_md5_finish(context, digest);\n}\n\n} // extern \"C\"\n\n#endif // LT_MD5_USE_MBEDTLS\n\n#endif // LT_ARD_HAS_MD5\n</code></pre>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/","title":"File MD5MbedTLSImpl.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5MbedTLSImpl.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;mbedtls/md5.h&gt;</code></li> </ul>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T  mbedtls_md5_context"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T mbedtls_md5_context\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/MD5MbedTLSImpl.h</code></p>"},{"location":"ltapi/_m_d5_mbed_t_l_s_impl_8h_source/","title":"File MD5MbedTLSImpl.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5MbedTLSImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-07-11. */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include &lt;mbedtls/md5.h&gt;\n#define LT_MD5_CTX_T mbedtls_md5_context\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8cpp/","title":"File MD5PolarSSLImpl.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5PolarSSLImpl.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/MD5PolarSSLImpl.cpp</code></p>"},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8cpp_source/","title":"File MD5PolarSSLImpl.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5PolarSSLImpl.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-03. */\n\n#if LT_ARD_HAS_MD5\n\n#include \"MD5.h\"\n\n#if LT_MD5_USE_POLARSSL\n\nextern \"C\" {\n\nvoid MD5Init(LT_MD5_CTX_T *context) {\n    md5_init(context);\n    md5_starts(context);\n}\n\nvoid MD5Update(LT_MD5_CTX_T *context, const unsigned char *buf, unsigned len) {\n    md5_update(context, buf, len);\n}\n\nvoid MD5Final(unsigned char digest[16], LT_MD5_CTX_T *context) {\n    md5_finish(context, digest);\n}\n\n} // extern \"C\"\n\n#endif // LT_MD5_USE_POLARSSL\n\n#endif // LT_ARD_HAS_MD5\n</code></pre>"},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8h/","title":"File MD5PolarSSLImpl.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5PolarSSLImpl.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;polarssl/md5.h&gt;</code></li> </ul>"},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8h/#macros","title":"Macros","text":"Type Name     define LT_MD5_CTX_T  md5_context"},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8h/#define-lt_md5_ctx_t","title":"define LT_MD5_CTX_T","text":"<pre><code>#define LT_MD5_CTX_T md5_context\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/MD5/MD5PolarSSLImpl.h</code></p>"},{"location":"ltapi/_m_d5_polar_s_s_l_impl_8h_source/","title":"File MD5PolarSSLImpl.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; MD5 &gt; MD5PolarSSLImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-03. */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include &lt;polarssl/md5.h&gt;\n#define LT_MD5_CTX_T md5_context\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre>"},{"location":"ltapi/dir_6d84e4ebc3bbb9aa3386ce7a131f9e8b/","title":"Dir arduino/libretuya/libraries/NetUtils","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils</p>"},{"location":"ltapi/dir_6d84e4ebc3bbb9aa3386ce7a131f9e8b/#files","title":"Files","text":"Type Name     file IPv6Address.cpp    file IPv6Address.h"},{"location":"ltapi/dir_6d84e4ebc3bbb9aa3386ce7a131f9e8b/#directories","title":"Directories","text":"Type Name     dir api    dir lwip    dir ssl      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/</code></p>"},{"location":"ltapi/_i_pv6_address_8cpp/","title":"File IPv6Address.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; IPv6Address.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"IPv6Address.h\"</code></li> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/Print.h&gt;</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/IPv6Address.cpp</code></p>"},{"location":"ltapi/_i_pv6_address_8cpp_source/","title":"File IPv6Address.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; IPv6Address.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n IPv6Address.cpp - Base class that provides IPv6Address\n Copyright (c) 2011 Adrian McEwen.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"IPv6Address.h\"\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/Print.h&gt;\n\nIPv6Address::IPv6Address() {\n    memset(_address.bytes, 0, sizeof(_address.bytes));\n}\n\nIPv6Address::IPv6Address(const uint8_t *address) {\n    memcpy(_address.bytes, address, sizeof(_address.bytes));\n}\n\nIPv6Address::IPv6Address(const uint32_t *address) {\n    memcpy(_address.bytes, (const uint8_t *)address, sizeof(_address.bytes));\n}\n\nIPv6Address &amp;IPv6Address::operator=(const uint8_t *address) {\n    memcpy(_address.bytes, address, sizeof(_address.bytes));\n    return *this;\n}\n\nbool IPv6Address::operator==(const uint8_t *addr) const {\n    return memcmp(addr, _address.bytes, sizeof(_address.bytes)) == 0;\n}\n\nsize_t IPv6Address::printTo(Print &amp;p) const {\n    /* size_t n = 0;\n    for(int i = 0; i &lt; 16; i+=2) {\n        if(i){\n            n += p.print(':');\n        }\n        n += p.printf(\"%02x\", _address.bytes[i]);\n        n += p.printf(\"%02x\", _address.bytes[i+1]);\n\n    }\n    return n; */\n}\n\nString IPv6Address::toString() const {\n    char szRet[40];\n    sprintf(\n        szRet,\n        \"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\",\n        _address.bytes[0],\n        _address.bytes[1],\n        _address.bytes[2],\n        _address.bytes[3],\n        _address.bytes[4],\n        _address.bytes[5],\n        _address.bytes[6],\n        _address.bytes[7],\n        _address.bytes[8],\n        _address.bytes[9],\n        _address.bytes[10],\n        _address.bytes[11],\n        _address.bytes[12],\n        _address.bytes[13],\n        _address.bytes[14],\n        _address.bytes[15]\n    );\n    return String(szRet);\n}\n\nbool IPv6Address::fromString(const char *address) {\n    // format 0011:2233:4455:6677:8899:aabb:ccdd:eeff\n    if (strlen(address) != 39) {\n        return false;\n    }\n    char *pos = (char *)address;\n    size_t i  = 0;\n    for (i = 0; i &lt; 16; i += 2) {\n        if (!sscanf(pos, \"%2hhx\", &amp;_address.bytes[i]) || !sscanf(pos + 2, \"%2hhx\", &amp;_address.bytes[i + 1])) {\n            return false;\n        }\n        pos += 5;\n    }\n    return true;\n}\n</code></pre>"},{"location":"ltapi/_i_pv6_address_8h/","title":"File IPv6Address.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; IPv6Address.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/Print.h&gt;</code></li> <li><code>#include &lt;api/String.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/_i_pv6_address_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace arduino"},{"location":"ltapi/_i_pv6_address_8h/#classes","title":"Classes","text":"Type Name     class IPv6Address      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/IPv6Address.h</code></p>"},{"location":"ltapi/_i_pv6_address_8h_source/","title":"File IPv6Address.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; IPv6Address.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n IPv6Address.h - Base class that provides IPv6Address\n Copyright (c) 2011 Adrian McEwen.  All right reserved.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#pragma once\n\n#include &lt;api/Print.h&gt;\n#include &lt;api/String.h&gt;\n#include &lt;stdint.h&gt;\n\n// A class to make it easier to handle and pass around IP addresses\n\nnamespace arduino {\n\nclass IPv6Address : public Printable {\n  private:\n    union {\n        uint8_t bytes[16]; // IPv4 address\n        uint32_t dword[4];\n    } _address;\n\n    // Access the raw byte array containing the address.  Because this returns a pointer\n    // to the internal structure rather than a copy of the address this function should only\n    // be used when you know that the usage of the returned uint8_t* will be transient and not\n    // stored.\n    uint8_t *raw_address() {\n        return _address.bytes;\n    }\n\n  public:\n    // Constructors\n    IPv6Address();\n    IPv6Address(const uint8_t *address);\n    IPv6Address(const uint32_t *address);\n\n    virtual ~IPv6Address() {}\n\n    bool fromString(const char *address);\n\n    bool fromString(const String &amp;address) {\n        return fromString(address.c_str());\n    }\n\n    operator const uint8_t *() const {\n        return _address.bytes;\n    }\n\n    operator const uint32_t *() const {\n        return _address.dword;\n    }\n\n    bool operator==(const IPv6Address &amp;addr) const {\n        return (_address.dword[0] == addr._address.dword[0]) &amp;&amp; (_address.dword[1] == addr._address.dword[1]) &amp;&amp;\n               (_address.dword[2] == addr._address.dword[2]) &amp;&amp; (_address.dword[3] == addr._address.dword[3]);\n    }\n\n    bool operator==(const uint8_t *addr) const;\n\n    // Overloaded index operator to allow getting and setting individual octets of the address\n    uint8_t operator[](int index) const {\n        return _address.bytes[index];\n    }\n\n    uint8_t &amp;operator[](int index) {\n        return _address.bytes[index];\n    }\n\n    // Overloaded copy operators to allow initialisation of IPv6Address objects from other types\n    IPv6Address &amp;operator=(const uint8_t *address);\n\n    // TODO implement printTo()\n    virtual size_t printTo(Print &amp;p) const;\n    String toString() const;\n\n    friend class UDP;\n    friend class Client;\n    friend class Server;\n};\n\n} // namespace arduino\n\nusing arduino::IPv6Address;\n</code></pre>"},{"location":"ltapi/dir_4291063491c6be447c5ab754d3d23561/","title":"Dir arduino/libretuya/libraries/NetUtils/api","text":"<p>FileList &gt; api</p>"},{"location":"ltapi/dir_4291063491c6be447c5ab754d3d23561/#files","title":"Files","text":"Type Name     file IPv6Address.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/api/</code></p>"},{"location":"ltapi/api_2_i_pv6_address_8h/","title":"File IPv6Address.h","text":"<p>FileList &gt; api &gt; IPv6Address.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"../IPv6Address.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/api/IPv6Address.h</code></p>"},{"location":"ltapi/api_2_i_pv6_address_8h_source/","title":"File IPv6Address.h","text":"<p>File List &gt; api &gt; IPv6Address.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include \"../IPv6Address.h\"\n</code></pre>"},{"location":"ltapi/dir_f22e23ed6cda33ad0dcdbe810b16751d/","title":"Dir arduino/libretuya/libraries/NetUtils/lwip","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip</p>"},{"location":"ltapi/dir_f22e23ed6cda33ad0dcdbe810b16751d/#files","title":"Files","text":"Type Name     file LwIPClient.cpp    file LwIPClient.h    file LwIPRxBuffer.cpp    file LwIPRxBuffer.h    file LwIPServer.cpp    file LwIPServer.h    file LwIPUdp.cpp    file LwIPUdp.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/</code></p>"},{"location":"ltapi/_lw_i_p_client_8cpp/","title":"File LwIPClient.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPClient.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPClient.cpp</code></p>"},{"location":"ltapi/_lw_i_p_client_8cpp_source/","title":"File LwIPClient.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPClient.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n\n#include \"LwIPClient.h\"\n\n#define MAX_SOCK_NUM                4\n#define WIFI_CLIENT_CONNECT_TIMEOUT 3000\n#define WIFI_CLIENT_READ_TIMEOUT    3000\n#define WIFI_CLIENT_WRITE_RETRY     10\n#define WIFI_CLIENT_SELECT_TIMEOUT  1000\n#define WIFI_CLIENT_FLUSH_BUF_SIZE  1024\n\n// disable #defines removing lwip_ prefix\n#undef LWIP_COMPAT_SOCKETS\n#define LWIP_COMPAT_SOCKETS 0\n\nextern \"C\" {\n\n#include &lt;lwip/api.h&gt;\n#include &lt;lwip/dns.h&gt;\n#include &lt;lwip/err.h&gt;\n#include &lt;lwip/sockets.h&gt;\n#include &lt;sys/time.h&gt;\n\n} // extern \"C\"\n\nclass SocketHandle {\n  public:\n    int fd;\n\n    SocketHandle(int fd) : fd(fd) {}\n\n    ~SocketHandle() {\n        lwip_close(fd);\n    }\n};\n\nLwIPClient::LwIPClient() {\n    LT_VM(CLIENT, \"LwIPClient()\");\n    _connected = false;\n    _sock      = NULL;\n    _rxBuffer  = NULL;\n    _timeout   = WIFI_CLIENT_CONNECT_TIMEOUT;\n}\n\nLwIPClient::LwIPClient(int sock) {\n    LT_VM(CLIENT, \"LwIPClient(%d)\", sock);\n    _connected = true;\n    _sock      = std::make_shared&lt;SocketHandle&gt;(sock);\n    _rxBuffer  = std::make_shared&lt;LwIPRxBuffer&gt;(sock);\n    _timeout   = WIFI_CLIENT_CONNECT_TIMEOUT;\n}\n\nLwIPClient::~LwIPClient() {\n    LT_VM(CLIENT, \"~LwIPClient()\");\n    stop();\n}\n\nLwIPClient &amp;LwIPClient::operator=(const LwIPClient &amp;other) {\n    stop();\n    _connected = other._connected;\n    _sock      = other._sock;\n    _rxBuffer  = other._rxBuffer;\n    return *this;\n}\n\nbool IWiFiClient::operator==(const IWiFiClient &amp;other) const {\n    return fd() == other.fd() &amp;&amp; remoteIP() == other.remoteIP() &amp;&amp; remotePort() == other.remotePort();\n}\n\nint LwIPClient::connect(IPAddress ip, uint16_t port) {\n    return connect(ip, port, _timeout);\n}\n\nint LwIPClient::connect(const char *host, uint16_t port) {\n    return connect(host, port, _timeout);\n}\n\nint LwIPClient::connect(const char *host, uint16_t port, int32_t timeout) {\n    IPAddress ip = WiFi.hostByName(host);\n    if (!ip)\n        return 0;\n    return connect(ip, port, timeout);\n}\n\nint LwIPClient::connect(IPAddress ip, uint16_t port, int32_t timeout) {\n    if (_connected)\n        stop();\n    int sock = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock &lt; 0) {\n        LT_DM(CLIENT, \"socket failed\");\n        return -1;\n    }\n\n    if (timeout &lt;= 0)\n        timeout = _timeout; // use default when -1 passed as timeout\n\n    lwip_fcntl(sock, F_SETFL, lwip_fcntl(sock, F_GETFL, 0) | O_NONBLOCK);\n\n    LT_ERRNO();\n\n    struct sockaddr_in addr;\n    memset(&amp;addr, 0, sizeof(addr));\n    addr.sin_family      = AF_INET;\n    addr.sin_addr.s_addr = ip;\n    addr.sin_port        = htons(port);\n    fd_set fdset;\n    struct timeval tv;\n    FD_ZERO(&amp;fdset);\n    FD_SET(sock, &amp;fdset);\n    tv.tv_sec  = 0;\n    tv.tv_usec = timeout * 1000; // millis -&gt; micros\n\n    int res = lwip_connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr));\n    if (res &lt; 0 &amp;&amp; errno != EINPROGRESS) {\n        LT_EM(CLIENT, \"Connect failed; errno=%d\", errno);\n        lwip_close(sock);\n        return -1;\n    }\n\n    res = lwip_select(sock + 1, NULL, &amp;fdset, NULL, timeout &lt; 0 ? NULL : &amp;tv);\n    if (res &lt; 0) {\n        LT_EM(CLIENT, \"Select failed; errno=%d\", errno);\n        lwip_close(sock);\n        return 0;\n    }\n    if (res == 0) {\n        LT_EM(CLIENT, \"Select timeout; errno=%d\", errno);\n        lwip_close(sock);\n        return 0;\n    }\n\n    int sockerr;\n    socklen_t len = (socklen_t)sizeof(sockerr);\n    res           = lwip_getsockopt(sock, SOL_SOCKET, SO_ERROR, &amp;sockerr, &amp;len);\n\n    if (res &lt; 0 || sockerr != 0) {\n        LT_EM(CLIENT, \"Socket error; res=%d, sockerr=%d\", res, sockerr);\n        lwip_close(sock);\n        return 0;\n    }\n\n    int enable = 1;\n    lwip_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof(timeout));\n    lwip_setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, sizeof(timeout));\n    lwip_setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;enable, sizeof(enable));\n    lwip_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;enable, sizeof(enable));\n\n    LT_ERRNO();\n\n    lwip_fcntl(sock, F_SETFL, lwip_fcntl(sock, F_GETFL, 0) &amp; ~O_NONBLOCK);\n\n    LT_ERRNO();\n\n    _connected = true;\n    _sock      = std::make_shared&lt;SocketHandle&gt;(sock);\n    _rxBuffer  = std::make_shared&lt;LwIPRxBuffer&gt;(sock);\n    return 1;\n}\n\nsize_t LwIPClient::write(uint8_t data) {\n    return write(&amp;data, 1);\n}\n\nsize_t LwIPClient::write(Stream &amp;stream) {\n    uint8_t *buf = (uint8_t *)malloc(1360);\n    if (!buf) {\n        return 0;\n    }\n    size_t toRead = 0, toWrite = 0, written = 0;\n    size_t available = stream.available();\n    while (available) {\n        toRead  = (available &gt; 1360) ? 1360 : available;\n        toWrite = stream.readBytes(buf, toRead);\n        written += write(buf, toWrite);\n        available = stream.available();\n    }\n    free(buf);\n    return written;\n}\n\nsize_t LwIPClient::write(const uint8_t *buf, size_t size) {\n    if (_sock &lt; 0 || !_connected || !size) {\n        setWriteError();\n        return 0;\n    }\n\n    int retry   = WIFI_CLIENT_WRITE_RETRY;\n    int written = 0;\n    while (retry) {\n        fd_set fdset;\n        struct timeval tv;\n        FD_ZERO(&amp;fdset);\n        FD_SET(fd(), &amp;fdset);\n        tv.tv_sec  = 0;\n        tv.tv_usec = WIFI_CLIENT_SELECT_TIMEOUT * 1000;\n        retry--;\n\n        if (lwip_select(fd() + 1, NULL, &amp;fdset, NULL, &amp;tv) &lt; 0) {\n            LT_WM(CLIENT, \"Select failed; errno=%d\", errno);\n            return 0;\n        }\n\n        if (FD_ISSET(fd(), &amp;fdset)) {\n            int res = lwip_send(fd(), buf, size, MSG_DONTWAIT);\n            if (res &gt; 0) {\n                written += res;\n                if (res &gt;= size) {\n                    retry = 0;\n                } else {\n                    buf += res;\n                    size -= res;\n                    retry = WIFI_CLIENT_WRITE_RETRY;\n                }\n            } else if (res &lt; 0 &amp;&amp; errno != EAGAIN) {\n                LT_WM(CLIENT, \"Send failed; errno=%d\", errno);\n                setWriteError(res);\n                _connected = false;\n                retry      = 0;\n            } else {\n                // Try again\n            }\n        }\n    }\n    LT_DM(CLIENT, \"wrote %d bytes\", written);\n    return written;\n}\n\nint LwIPClient::available() {\n    if (!_connected || !_rxBuffer)\n        return 0;\n    int res = _rxBuffer-&gt;available();\n    if (_rxBuffer-&gt;failed()) {\n        LT_ERRNO();\n        stop();\n    }\n    return res;\n}\n\nint LwIPClient::fd() const {\n    if (!_sock)\n        return -1;\n    return _sock-&gt;fd;\n}\n\nint LwIPClient::socket() {\n    return fd();\n}\n\nint LwIPClient::setTimeout(uint32_t seconds) {\n    Client::setTimeout(seconds * 1000);\n    lwip_setsockopt(fd(), SOL_SOCKET, SO_RCVTIMEO, &amp;_timeout, sizeof(_timeout));\n    return lwip_setsockopt(fd(), SOL_SOCKET, SO_SNDTIMEO, &amp;_timeout, sizeof(_timeout));\n}\n\nint LwIPClient::read() {\n    uint8_t data;\n    int res = read(&amp;data, 1);\n    if (res &lt; 0)\n        return res;\n    if (res == 0)\n        return -1;\n    return data;\n}\n\nint LwIPClient::read(uint8_t *buf, size_t size) {\n    int res = -1;\n    if (_rxBuffer) {\n        res = _rxBuffer-&gt;read(buf, size);\n        if (_rxBuffer-&gt;failed()) {\n            stop();\n        }\n    }\n    return res;\n}\n\nint LwIPClient::peek() {\n    int res = -1;\n    if (_rxBuffer) {\n        res = _rxBuffer-&gt;peek();\n        if (_rxBuffer-&gt;failed()) {\n            stop();\n        }\n    }\n    return res;\n}\n\nvoid LwIPClient::flush() {\n    int res;\n    size_t len = available();\n    if (!len)\n        return;\n    uint8_t *buf = (uint8_t *)malloc(WIFI_CLIENT_FLUSH_BUF_SIZE);\n    if (!buf)\n        return;\n    while (len) {\n        res = lwip_recv(fd(), buf, LWIP_MIN(len, WIFI_CLIENT_FLUSH_BUF_SIZE), MSG_DONTWAIT);\n        if (res &lt; 0) {\n            stop();\n            break;\n        }\n        len -= res;\n    }\n    free(buf);\n}\n\nvoid LwIPClient::stop() {\n    LT_VM(CLIENT, \"Stopping TCP\");\n    _connected = false;\n    _sock      = NULL;\n    _rxBuffer  = NULL;\n}\n\nuint8_t LwIPClient::connected() {\n    if (_connected) {\n        uint8_t dummy;\n        if (lwip_recv(fd(), &amp;dummy, 0, MSG_DONTWAIT) &lt;= 0) {\n            switch (errno) {\n                case EWOULDBLOCK:\n                case ENOENT: // caused by vfs\n                case 0:\n                    _connected = true;\n                    break;\n                case ENOTCONN:\n                case EPIPE:\n                case ECONNRESET:\n                case ECONNREFUSED:\n                case ECONNABORTED:\n                    LT_IM(CLIENT, \"Connection closed; errno=%d\", errno);\n                    _connected = false;\n                    break;\n                default:\n                    LT_WM(CLIENT, \"Connection status unknown; errno=%d\", errno);\n                    _connected = true;\n                    break;\n            }\n        }\n    }\n    return _connected;\n}\n\nIPAddress __attribute__((noinline)) getaddr(int sock, int (*func)(int, struct sockaddr *, socklen_t *)) {\n    struct sockaddr addr;\n    socklen_t len = sizeof(addr);\n    func(sock, &amp;addr, &amp;len);\n    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;\n    return IPAddress((uint32_t)(s-&gt;sin_addr.s_addr));\n}\n\nuint16_t __attribute__((noinline)) getport(int sock, int (*func)(int, struct sockaddr *, socklen_t *)) {\n    struct sockaddr addr;\n    socklen_t len = sizeof(addr);\n    func(sock, &amp;addr, &amp;len);\n    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;\n    return ntohs(s-&gt;sin_port);\n}\n\nIPAddress LwIPClient::remoteIP() const {\n    return getaddr(fd(), lwip_getpeername);\n}\n\nIPAddress LwIPClient::remoteIP(int fd) const {\n    return getaddr(fd, lwip_getpeername);\n}\n\nuint16_t LwIPClient::remotePort() const {\n    return getport(fd(), lwip_getpeername);\n}\n\nuint16_t LwIPClient::remotePort(int fd) const {\n    return getport(fd, lwip_getpeername);\n}\n\nIPAddress LwIPClient::localIP() const {\n    return getaddr(fd(), lwip_getsockname);\n}\n\nIPAddress LwIPClient::localIP(int fd) const {\n    return getaddr(fd, lwip_getsockname);\n}\n\nuint16_t LwIPClient::localPort() const {\n    return getport(fd(), lwip_getsockname);\n}\n\nuint16_t LwIPClient::localPort(int fd) const {\n    return getport(fd, lwip_getsockname);\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_client_8h/","title":"File LwIPClient.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/WiFi/WiFi.h&gt;</code></li> <li><code>#include &lt;api/WiFiClient.h&gt;</code></li> <li><code>#include &lt;lwip/LwIPRxBuffer.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_client_8h/#classes","title":"Classes","text":"Type Name     class LwIPClient      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPClient.h</code></p>"},{"location":"ltapi/_lw_i_p_client_8h_source/","title":"File LwIPClient.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#pragma once\n\n#include &lt;api/WiFi/WiFi.h&gt;\n#include &lt;api/WiFiClient.h&gt;\n#include &lt;lwip/LwIPRxBuffer.h&gt;\n#include &lt;memory&gt;\n\nclass SocketHandle;\n\nclass LwIPClient : public IWiFiClient {\n  private:\n    bool _connected;\n    std::shared_ptr&lt;SocketHandle&gt; _sock;\n    std::shared_ptr&lt;LwIPRxBuffer&gt; _rxBuffer;\n\n  public:\n    LwIPClient();\n    LwIPClient(int sock);\n    ~LwIPClient();\n\n    int connect(IPAddress ip, uint16_t port);\n    int connect(const char *host, uint16_t port);\n    int connect(IPAddress ip, uint16_t port, int32_t timeout);\n    int connect(const char *host, uint16_t port, int32_t timeout);\n\n    size_t write(uint8_t data);\n    size_t write(const uint8_t *buf, size_t size);\n    size_t write(Stream &amp;stream);\n\n    int available();\n    int fd() const;\n    int socket();\n    int setTimeout(uint32_t seconds);\n\n    int read();\n    int read(uint8_t *buf, size_t size);\n    int peek();\n    void flush();\n    void stop();\n    uint8_t connected();\n\n    LwIPClient &amp;operator=(const LwIPClient &amp;other);\n\n    IPAddress remoteIP() const;\n    IPAddress remoteIP(int sock) const;\n    uint16_t remotePort() const;\n    uint16_t remotePort(int sock) const;\n    IPAddress localIP() const;\n    IPAddress localIP(int sock) const;\n    uint16_t localPort() const;\n    uint16_t localPort(int sock) const;\n\n    using Print::write;\n};\n</code></pre>"},{"location":"ltapi/_lw_i_p_rx_buffer_8cpp/","title":"File LwIPRxBuffer.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPRxBuffer.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPRxBuffer.cpp</code></p>"},{"location":"ltapi/_lw_i_p_rx_buffer_8cpp_source/","title":"File LwIPRxBuffer.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPRxBuffer.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#if LT_HAS_LWIP\n\n#include \"LwIPRxBuffer.h\"\n\n// disable #defines removing lwip_ prefix\n#undef LWIP_COMPAT_SOCKETS\n#define LWIP_COMPAT_SOCKETS 0\n\nextern \"C\" {\n\n#include &lt;lwip/sockets.h&gt;\n\n} // extern \"C\"\n\nsize_t LwIPRxBuffer::r_available() {\n    if (_sock &lt; 0) {\n        LT_DM(CLIENT, \"_sock &lt; 0\");\n        return 0;\n    }\n    int count = 0; // must be of same size as in lwip_ioctl()\n    int res   = lwip_ioctl(_sock, FIONREAD, &amp;count);\n    if (res &lt; 0) {\n        LT_DM(CLIENT, \"lwip_ioctl()=%d, errno=%d\", res, errno);\n        _failed = true;\n        return 0;\n    }\n    return count;\n}\n\nsize_t LwIPRxBuffer::fillBuffer() {\n    if (!_buffer) {\n        _buffer = (uint8_t *)malloc(_size);\n        if (!_buffer) {\n            LT_E(\"buffer alloc failed\");\n            _failed = true;\n            return 0;\n        }\n    }\n    if (_fill &amp;&amp; _pos == _fill) {\n        _fill = 0;\n        _pos  = 0;\n    }\n    if (!_buffer || _size &lt;= _fill || !r_available()) {\n        return 0;\n    }\n    int res = lwip_recv(_sock, _buffer + _fill, _size - _fill, MSG_DONTWAIT);\n    if (res &lt; 0) {\n        if (errno != EWOULDBLOCK) {\n            LT_ERRNO();\n            _failed = true;\n        }\n        return 0;\n    }\n    _fill += res;\n    return res;\n}\n\nLwIPRxBuffer::LwIPRxBuffer(int sock, size_t size)\n    : _size(size), _buffer(NULL), _pos(0), _fill(0), _sock(sock), _failed(false) {\n    //_buffer = (uint8_t *)malloc(_size);\n}\n\nLwIPRxBuffer::~LwIPRxBuffer() {\n    free(_buffer);\n}\n\nbool LwIPRxBuffer::failed() {\n    return _failed;\n}\n\nint LwIPRxBuffer::read(uint8_t *dst, size_t len) {\n    if (!dst || !len || (_pos == _fill &amp;&amp; !fillBuffer())) {\n        return _failed ? -1 : 0;\n    }\n    size_t a = _fill - _pos;\n    if (len &lt;= a || ((len - a) &lt;= (_size - _fill) &amp;&amp; fillBuffer() &gt;= (len - a))) {\n        if (len == 1) {\n            *dst = _buffer[_pos];\n        } else {\n            memcpy(dst, _buffer + _pos, len);\n        }\n        _pos += len;\n        return len;\n    }\n    size_t left   = len;\n    size_t toRead = a;\n    uint8_t *buf  = dst;\n    memcpy(buf, _buffer + _pos, toRead);\n    _pos += toRead;\n    left -= toRead;\n    buf += toRead;\n    while (left) {\n        if (!fillBuffer()) {\n            return len - left;\n        }\n        a      = _fill - _pos;\n        toRead = (a &gt; left) ? left : a;\n        memcpy(buf, _buffer + _pos, toRead);\n        _pos += toRead;\n        left -= toRead;\n        buf += toRead;\n    }\n    return len;\n}\n\nint LwIPRxBuffer::peek() {\n    if (_pos == _fill &amp;&amp; !fillBuffer()) {\n        return -1;\n    }\n    return _buffer[_pos];\n}\n\nsize_t LwIPRxBuffer::available() {\n    return _fill - _pos + r_available();\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_rx_buffer_8h/","title":"File LwIPRxBuffer.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPRxBuffer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_rx_buffer_8h/#classes","title":"Classes","text":"Type Name     class LwIPRxBuffer      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPRxBuffer.h</code></p>"},{"location":"ltapi/_lw_i_p_rx_buffer_8h_source/","title":"File LwIPRxBuffer.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPRxBuffer.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;stdlib.h&gt;\n\nclass LwIPRxBuffer {\n  private:\n    size_t _size;\n    uint8_t *_buffer;\n    size_t _pos;\n    size_t _fill;\n    int _sock;\n    bool _failed;\n    size_t r_available();\n    size_t fillBuffer();\n\n  public:\n    LwIPRxBuffer(int sock, size_t size = 1436);\n    ~LwIPRxBuffer();\n    bool failed();\n    int read(uint8_t *dst, size_t len);\n    int peek();\n    size_t available();\n};\n</code></pre>"},{"location":"ltapi/_lw_i_p_server_8cpp/","title":"File LwIPServer.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPServer.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPServer.cpp</code></p>"},{"location":"ltapi/_lw_i_p_server_8cpp_source/","title":"File LwIPServer.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPServer.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n\n#include \"LwIPServer.h\"\n\n// disable #defines removing lwip_ prefix\n#undef LWIP_COMPAT_SOCKETS\n#define LWIP_COMPAT_SOCKETS 0\n\nextern \"C\" {\n#include &lt;lwip/api.h&gt;\n// #include &lt;lwip/dns.h&gt;\n#include &lt;lwip/err.h&gt;\n#include &lt;lwip/sockets.h&gt;\n#include &lt;sys/time.h&gt;\n}\n\nLwIPServer::LwIPServer(uint32_t addr, uint16_t port, uint8_t maxClients)\n    : _sock(-1), _sockAccepted(-1), _addr(addr), _port(port), _maxClients(maxClients), _active(false), _noDelay(false) {\n}\n\nLwIPServer::operator bool() {\n    return _active;\n}\n\nbool LwIPServer::begin(uint16_t port, bool reuseAddr) {\n    if (_active)\n        return true;\n    if (port)\n        _port = port;\n\n    _sock = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (_sock &lt; 0) {\n        LT_EM(SERVER, \"Socket failed; errno=%d\", errno);\n        return false;\n    }\n\n    int enable = reuseAddr;\n    lwip_setsockopt(_sock, SOL_SOCKET, SO_REUSEADDR, &amp;enable, sizeof(enable));\n\n    struct sockaddr_in addr;\n    addr.sin_family      = AF_INET;\n    addr.sin_addr.s_addr = _addr;\n    addr.sin_port        = htons(_port);\n\n    if (lwip_bind(_sock, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) {\n        LT_EM(SERVER, \"Bind failed; errno=%d\", errno);\n        return false;\n    }\n\n    if (lwip_listen(_sock, _maxClients) &lt; 0) {\n        LT_EM(SERVER, \"Bind failed; errno=%d\", errno);\n        return false;\n    }\n\n    uint8_t *addrB = (uint8_t *)&amp;_addr;\n    LT_IM(SERVER, \"Server running on %hhu.%hhu.%hhu.%hhu:%hu\", addrB[0], addrB[1], addrB[2], addrB[3], _port);\n\n    lwip_fcntl(_sock, F_SETFL, O_NONBLOCK);\n    _active       = true;\n    _noDelay      = false;\n    _sockAccepted = -1;\n}\n\nvoid LwIPServer::end() {\n    if (_sock == -1)\n        return;\n    lwip_close(_sock);\n    _sock   = -1;\n    _active = -1;\n}\n\nWiFiClient LwIPServer::accept() {\n    if (!_active)\n        return WiFiClient();\n\n    int sock;\n    if (_sockAccepted &gt;= 0) {\n        sock          = _sockAccepted;\n        _sockAccepted = -1;\n    } else {\n        struct sockaddr_in addr;\n        socklen_t len = sizeof(addr);\n        sock          = lwip_accept(_sock, (struct sockaddr *)&amp;addr, &amp;len);\n    }\n\n    if (sock &gt;= 0) {\n        int enable = 1;\n        if (lwip_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &amp;enable, sizeof(enable)) == ERR_OK) {\n            enable = _noDelay;\n            if (lwip_setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &amp;enable, sizeof(enable)) == ERR_OK) {\n                // HOTFIX: allow the TCP thread to receive data\n                // I'm not sure what's happening there, so this should probably be fixed properly.\n                // When a connection arrives, sometimes TCP hasn't received anything yet. This causes\n                // calling WiFiClient::connected() check for lwip_recv(), which returns EWOULDBLOCK\n                // as the client is still connected. The problem is that there's basically an infinite loop\n                // created: nowhere in that code is a yield()/delay() that would allow TCP thread to work\n                // and receive data, so LwIP still sees a connected client that sends nothing. At least\n                // that's what I understand. And any loop that doesn't call delay() seems to block the TCP\n                // stack completely and prevents it from even being pinged.\n                LT_DM(SERVER, \"Got client\");\n                delay(5);\n                return WiFiClient(sock);\n            }\n        }\n    }\n\n    return WiFiClient();\n}\n\nint LwIPServer::setTimeout(uint32_t seconds) {\n    struct timeval tv;\n    tv.tv_sec  = seconds;\n    tv.tv_usec = 0;\n    if (lwip_setsockopt(_sock, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv)) &lt; 0)\n        return -1;\n    return lwip_setsockopt(_sock, SOL_SOCKET, SO_SNDTIMEO, &amp;tv, sizeof(tv));\n}\n\nvoid LwIPServer::setNoDelay(bool noDelay) {\n    _noDelay = noDelay;\n}\n\nbool LwIPServer::getNoDelay() {\n    return _noDelay;\n}\n\nbool LwIPServer::hasClient() {\n    if (_sockAccepted &gt;= 0) {\n        return true;\n    }\n    struct sockaddr_in addr;\n    socklen_t len = sizeof(addr);\n    _sockAccepted = lwip_accept(_sock, (struct sockaddr *)&amp;addr, &amp;len);\n    if (_sockAccepted &gt;= 0) {\n        return true;\n    }\n    return false;\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_server_8h/","title":"File LwIPServer.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPServer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/WiFi/WiFi.h&gt;</code></li> <li><code>#include &lt;api/WiFiServer.h&gt;</code></li> <li><code>#include &lt;WiFiClient.h&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_server_8h/#classes","title":"Classes","text":"Type Name     class LwIPServer      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPServer.h</code></p>"},{"location":"ltapi/_lw_i_p_server_8h_source/","title":"File LwIPServer.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPServer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-26. */\n\n#pragma once\n\n#include &lt;api/WiFi/WiFi.h&gt;\n#include &lt;api/WiFiServer.h&gt;\n\n#include &lt;WiFiClient.h&gt;\n\nclass LwIPServer : public IWiFiServer&lt;WiFiClient&gt; {\n  private:\n    int _sock;\n    int _sockAccepted;\n    uint32_t _addr;\n    uint16_t _port;\n    uint8_t _maxClients;\n    bool _active;\n    bool _noDelay = false;\n\n  private:\n    LwIPServer(uint32_t addr, uint16_t port = 80, uint8_t maxClients = 4);\n\n  public:\n    LwIPServer(uint16_t port = 80, uint8_t maxClients = 4) : LwIPServer((uint32_t)0, port, maxClients) {}\n\n    LwIPServer(int port = 80, uint8_t maxClients = 4) : LwIPServer((uint32_t)0, port, maxClients) {}\n\n    LwIPServer(const IPAddress &amp;addr, uint16_t port = 80, uint8_t maxClients = 4)\n        : LwIPServer((uint32_t)addr, port, maxClients) {}\n\n    operator bool();\n\n    bool begin(uint16_t port = 0, bool reuseAddr = true);\n    void end();\n    WiFiClient accept();\n\n    size_t write(const uint8_t *buffer, size_t size) {\n        return 0;\n    }\n\n    void stopAll() {}\n\n    int setTimeout(uint32_t seconds);\n    void setNoDelay(bool noDelay);\n    bool getNoDelay();\n    bool hasClient();\n};\n</code></pre>"},{"location":"ltapi/_lw_i_p_udp_8cpp/","title":"File LwIPUdp.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPUdp.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPUdp.cpp</code></p>"},{"location":"ltapi/_lw_i_p_udp_8cpp_source/","title":"File LwIPUdp.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPUdp.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Udp.cpp - UDP class for Raspberry Pi\n  Copyright (c) 2016 Hristo Gochkov  All right reserved.\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_LWIP\n\n#include \"LwIPUdp.h\"\n#include &lt;errno.h&gt;\n\nextern \"C\" {\n\n#include &lt;lwip/netdb.h&gt;\n#include &lt;lwip/sockets.h&gt;\n\n} // extern \"C\"\n\n#undef write\n#undef read\n\nLwIPUDP::LwIPUDP() : udp_server(-1), server_port(0), remote_port(0), tx_buffer(0), tx_buffer_len(0), rx_buffer(0) {}\n\nLwIPUDP::~LwIPUDP() {\n    stop();\n}\n\nuint8_t LwIPUDP::begin(IPAddress address, uint16_t port) {\n    stop();\n\n    server_port = port;\n\n    tx_buffer = new char[1460];\n    if (!tx_buffer) {\n        log_e(\"could not create tx buffer: %d\", errno);\n        return 0;\n    }\n\n    if ((udp_server = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {\n        log_e(\"could not create socket: %d\", errno);\n        return 0;\n    }\n\n    int yes = 1;\n    if (setsockopt(udp_server, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(yes)) &lt; 0) {\n        log_e(\"could not set socket option: %d\", errno);\n        stop();\n        return 0;\n    }\n\n    struct sockaddr_in addr;\n    memset((char *)&amp;addr, 0, sizeof(addr));\n    addr.sin_family      = AF_INET;\n    addr.sin_port        = htons(server_port);\n    addr.sin_addr.s_addr = (in_addr_t)address;\n    if (bind(udp_server, (struct sockaddr *)&amp;addr, sizeof(addr)) == -1) {\n        log_e(\"could not bind socket: %d\", errno);\n        stop();\n        return 0;\n    }\n    fcntl(udp_server, F_SETFL, O_NONBLOCK);\n    return 1;\n}\n\nuint8_t LwIPUDP::begin(uint16_t p) {\n    return begin(IPAddress(INADDR_ANY), p);\n}\n\nuint8_t LwIPUDP::beginMulticast(IPAddress a, uint16_t p) {\n    if (begin(IPAddress(INADDR_ANY), p)) {\n        if ((uint32_t)a != 0) {\n            struct ip_mreq mreq;\n            mreq.imr_multiaddr.s_addr = (in_addr_t)a;\n            mreq.imr_interface.s_addr = INADDR_ANY;\n            if (setsockopt(udp_server, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt; 0) {\n                log_e(\"could not join igmp: %d\", errno);\n                stop();\n                return 0;\n            }\n            multicast_ip = a;\n        }\n        return 1;\n    }\n    return 0;\n}\n\nvoid LwIPUDP::stop() {\n    if (tx_buffer) {\n        delete[] tx_buffer;\n        tx_buffer = NULL;\n    }\n    tx_buffer_len = 0;\n    if (rx_buffer) {\n        cbuf *b   = rx_buffer;\n        rx_buffer = NULL;\n        delete b;\n    }\n    if (udp_server == -1)\n        return;\n    if ((uint32_t)multicast_ip != 0) {\n        struct ip_mreq mreq;\n        mreq.imr_multiaddr.s_addr = (in_addr_t)multicast_ip;\n        mreq.imr_interface.s_addr = (in_addr_t)0;\n        setsockopt(udp_server, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq, sizeof(mreq));\n        multicast_ip = IPAddress(INADDR_ANY);\n    }\n    close(udp_server);\n    udp_server = -1;\n}\n\nint LwIPUDP::beginMulticastPacket() {\n    if (!server_port || multicast_ip == IPAddress(INADDR_ANY))\n        return 0;\n    remote_ip   = multicast_ip;\n    remote_port = server_port;\n    return beginPacket();\n}\n\nint LwIPUDP::beginPacket() {\n    if (!remote_port)\n        return 0;\n\n    // allocate tx_buffer if is necessary\n    if (!tx_buffer) {\n        tx_buffer = new char[1460];\n        if (!tx_buffer) {\n            log_e(\"could not create tx buffer: %d\", errno);\n            return 0;\n        }\n    }\n\n    tx_buffer_len = 0;\n\n    // check whereas socket is already open\n    if (udp_server != -1)\n        return 1;\n\n    if ((udp_server = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {\n        log_e(\"could not create socket: %d\", errno);\n        return 0;\n    }\n\n    fcntl(udp_server, F_SETFL, O_NONBLOCK);\n\n    return 1;\n}\n\nint LwIPUDP::beginPacket(IPAddress ip, uint16_t port) {\n    remote_ip   = ip;\n    remote_port = port;\n    return beginPacket();\n}\n\nint LwIPUDP::beginPacket(const char *host, uint16_t port) {\n    struct hostent *server;\n    server = gethostbyname(host);\n    if (server == NULL) {\n        log_e(\"could not get host from dns: %d\", errno);\n        return 0;\n    }\n    return beginPacket(IPAddress((const uint8_t *)(server-&gt;h_addr_list[0])), port);\n}\n\nint LwIPUDP::endPacket() {\n    struct sockaddr_in recipient;\n    recipient.sin_addr.s_addr = (uint32_t)remote_ip;\n    recipient.sin_family      = AF_INET;\n    recipient.sin_port        = htons(remote_port);\n    int sent = sendto(udp_server, tx_buffer, tx_buffer_len, 0, (struct sockaddr *)&amp;recipient, sizeof(recipient));\n    if (sent &lt; 0) {\n        log_e(\"could not send data: %d\", errno);\n        return 0;\n    }\n    return 1;\n}\n\nsize_t LwIPUDP::write(uint8_t data) {\n    if (tx_buffer_len == 1460) {\n        endPacket();\n        tx_buffer_len = 0;\n    }\n    tx_buffer[tx_buffer_len++] = data;\n    return 1;\n}\n\nsize_t LwIPUDP::write(const uint8_t *buffer, size_t size) {\n    size_t i;\n    for (i = 0; i &lt; size; i++)\n        write(buffer[i]);\n    return i;\n}\n\nint LwIPUDP::parsePacket() {\n    if (rx_buffer)\n        return 0;\n    struct sockaddr_in si_other;\n    int slen  = sizeof(si_other), len;\n    char *buf = new char[1460];\n    if (!buf) {\n        return 0;\n    }\n    if ((len = recvfrom(udp_server, buf, 1460, MSG_DONTWAIT, (struct sockaddr *)&amp;si_other, (socklen_t *)&amp;slen)) == -1) {\n        delete[] buf;\n        if (errno == EWOULDBLOCK) {\n            return 0;\n        }\n        log_e(\"could not receive data: %d\", errno);\n        return 0;\n    }\n    remote_ip   = IPAddress(si_other.sin_addr.s_addr);\n    remote_port = ntohs(si_other.sin_port);\n    if (len &gt; 0) {\n        rx_buffer = new cbuf(len);\n        rx_buffer-&gt;write(buf, len);\n    }\n    delete[] buf;\n    return len;\n}\n\nint LwIPUDP::available() {\n    if (!rx_buffer)\n        return 0;\n    return rx_buffer-&gt;available();\n}\n\nint LwIPUDP::read() {\n    if (!rx_buffer)\n        return -1;\n    int out = rx_buffer-&gt;read();\n    if (!rx_buffer-&gt;available()) {\n        cbuf *b   = rx_buffer;\n        rx_buffer = 0;\n        delete b;\n    }\n    return out;\n}\n\nint LwIPUDP::read(unsigned char *buffer, size_t len) {\n    return read((char *)buffer, len);\n}\n\nint LwIPUDP::read(char *buffer, size_t len) {\n    if (!rx_buffer)\n        return 0;\n    int out = rx_buffer-&gt;read(buffer, len);\n    if (!rx_buffer-&gt;available()) {\n        cbuf *b   = rx_buffer;\n        rx_buffer = 0;\n        delete b;\n    }\n    return out;\n}\n\nint LwIPUDP::peek() {\n    if (!rx_buffer)\n        return -1;\n    return rx_buffer-&gt;peek();\n}\n\nvoid LwIPUDP::flush() {\n    if (!rx_buffer)\n        return;\n    cbuf *b   = rx_buffer;\n    rx_buffer = 0;\n    delete b;\n}\n\nIPAddress LwIPUDP::remoteIP() {\n    return remote_ip;\n}\n\nuint16_t LwIPUDP::remotePort() {\n    return remote_port;\n}\n\n#endif\n</code></pre>"},{"location":"ltapi/_lw_i_p_udp_8h/","title":"File LwIPUdp.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPUdp.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/WiFi/WiFi.h&gt;</code></li> <li><code>#include &lt;api/WiFiUdp.h&gt;</code></li> <li><code>#include &lt;cbuf.h&gt;</code></li> </ul>"},{"location":"ltapi/_lw_i_p_udp_8h/#classes","title":"Classes","text":"Type Name     class LwIPUDP      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/lwip/LwIPUdp.h</code></p>"},{"location":"ltapi/_lw_i_p_udp_8h_source/","title":"File LwIPUdp.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; lwip &gt; LwIPUdp.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-09-10. */\n\n#pragma once\n\n#include &lt;api/WiFi/WiFi.h&gt;\n#include &lt;api/WiFiUdp.h&gt;\n#include &lt;cbuf.h&gt;\n\nclass LwIPUDP : public IWiFiUDP {\n  private:\n    int udp_server;\n    IPAddress multicast_ip;\n    IPAddress remote_ip;\n    uint16_t server_port;\n    uint16_t remote_port;\n    char *tx_buffer;\n    size_t tx_buffer_len;\n    cbuf *rx_buffer;\n\n  public:\n    LwIPUDP();\n    ~LwIPUDP();\n    uint8_t begin(IPAddress ip, uint16_t port);\n    uint8_t begin(uint16_t port);\n    uint8_t beginMulticast(IPAddress ip, uint16_t port);\n    void stop();\n    int beginMulticastPacket();\n    int beginPacket();\n    int beginPacket(IPAddress ip, uint16_t port);\n    int beginPacket(const char *host, uint16_t port);\n    int endPacket();\n    size_t write(uint8_t);\n    size_t write(const uint8_t *buffer, size_t size);\n    int parsePacket();\n    int available();\n    int read();\n    int read(unsigned char *buffer, size_t len);\n    int read(char *buffer, size_t len);\n    int peek();\n    void flush();\n    IPAddress remoteIP();\n    uint16_t remotePort();\n};\n</code></pre>"},{"location":"ltapi/dir_6797ab3357ce10f8479dd5f8d0c0688d/","title":"Dir arduino/libretuya/libraries/NetUtils/ssl","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; ssl</p>"},{"location":"ltapi/dir_6797ab3357ce10f8479dd5f8d0c0688d/#files","title":"Files","text":"Type Name     file MbedTLSClient.cpp    file MbedTLSClient.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/ssl/</code></p>"},{"location":"ltapi/_mbed_t_l_s_client_8cpp/","title":"File MbedTLSClient.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; ssl &gt; MbedTLSClient.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/ssl/MbedTLSClient.cpp</code></p>"},{"location":"ltapi/_mbed_t_l_s_client_8cpp_source/","title":"File MbedTLSClient.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; ssl &gt; MbedTLSClient.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#if LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_MBEDTLS\n\n#include \"MbedTLSClient.h\"\n\nextern \"C\" {\n\n#include &lt;mbedtls/debug.h&gt;\n#include &lt;mbedtls/platform.h&gt;\n#include &lt;mbedtls/sha256.h&gt;\n#include &lt;mbedtls/ssl.h&gt;\n\n} // extern \"C\"\n\nMbedTLSClient::MbedTLSClient() : WiFiClient() {\n    init(); // ensure the context is zero filled\n}\n\nMbedTLSClient::MbedTLSClient(int sock) : WiFiClient(sock) {\n    init(); // ensure the context is zero filled\n}\n\nMbedTLSClient::~MbedTLSClient() {\n    LT_VM(CLIENT, \"~MbedTLSClient()\");\n    stop();\n}\n\nvoid MbedTLSClient::stop() {\n    LT_VM(SSL, \"Stopping SSL\");\n\n    if (_sslCfg.ca_chain) {\n        mbedtls_x509_crt_free(&amp;_caCert);\n    }\n    if (_sslCfg.key_cert) {\n        mbedtls_x509_crt_free(&amp;_clientCert);\n        mbedtls_pk_free(&amp;_clientKey);\n    }\n    mbedtls_ssl_free(&amp;_sslCtx);\n    mbedtls_ssl_config_free(&amp;_sslCfg);\n    LT_HEAP_I();\n}\n\nvoid MbedTLSClient::init() {\n    // Realtek AmbZ: init platform here to ensure HW crypto is initialized in ssl_init\n    mbedtls_platform_set_calloc_free(calloc, free);\n    mbedtls_ssl_init(&amp;_sslCtx);\n    mbedtls_ssl_config_init(&amp;_sslCfg);\n}\n\nint MbedTLSClient::connect(IPAddress ip, uint16_t port, int32_t timeout) {\n    return connect(ipToString(ip).c_str(), port, timeout);\n}\n\nint MbedTLSClient::connect(const char *host, uint16_t port, int32_t timeout) {\n    if (_pskIdentStr &amp;&amp; _pskStr)\n        return connect(host, port, timeout, NULL, NULL, NULL, _pskIdentStr, _pskStr) == 0;\n    return connect(host, port, timeout, _caCertStr, _clientCertStr, _clientKeyStr, NULL, NULL) == 0;\n}\n\nint MbedTLSClient::connect(\n    IPAddress ip, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey\n) {\n    return connect(ipToString(ip).c_str(), port, 0, rootCABuf, clientCert, clientKey, NULL, NULL) == 0;\n}\n\nint MbedTLSClient::connect(\n    const char *host, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey\n) {\n    return connect(host, port, 0, rootCABuf, clientCert, clientKey, NULL, NULL) == 0;\n}\n\nint MbedTLSClient::connect(IPAddress ip, uint16_t port, const char *pskIdent, const char *psk) {\n    return connect(ipToString(ip).c_str(), port, 0, NULL, NULL, NULL, pskIdent, psk) == 0;\n}\n\nint MbedTLSClient::connect(const char *host, uint16_t port, const char *pskIdent, const char *psk) {\n    return connect(host, port, 0, NULL, NULL, NULL, pskIdent, psk) == 0;\n}\n\nstatic int ssl_random(void *data, unsigned char *output, size_t len) {\n    lt_rand_bytes((uint8_t *)output, len);\n    return 0;\n}\n\nvoid debug_cb(void *ctx, int level, const char *file, int line, const char *str) {\n    // do not print the trailing \\n\n    uint16_t len = strlen(str);\n    char *msg    = (char *)str;\n    msg[len - 1] = '\\0';\n    LT_IM(SSL, \"%04d: |%d| %s\", line, level, msg);\n}\n\nint MbedTLSClient::connect(\n    const char *host,\n    uint16_t port,\n    int32_t timeout,\n    const char *rootCABuf,\n    const char *clientCert,\n    const char *clientKey,\n    const char *pskIdent,\n    const char *psk\n) {\n    LT_HEAP_I();\n\n    if (!rootCABuf &amp;&amp; !pskIdent &amp;&amp; !psk &amp;&amp; !_insecure &amp;&amp; !_useRootCA)\n        return -1;\n\n    if (timeout &lt;= 0)\n        timeout = _timeout; // use default when -1 passed as timeout\n\n    IPAddress addr = WiFi.hostByName(host);\n    if (!(uint32_t)addr)\n        return -1;\n\n    int ret = WiFiClient::connect(addr, port, timeout);\n    if (ret &lt; 0) {\n        LT_EM(SSL, \"SSL socket failed\");\n        return ret;\n    }\n\n    char *uid = \"lt-ssl\"; // TODO\n\n    LT_VM(SSL, \"Init SSL\");\n    init();\n    LT_HEAP_I();\n\n    // mbedtls_debug_set_threshold(4);\n    // mbedtls_ssl_conf_dbg(&amp;_sslCfg, debug_cb, NULL);\n\n    ret = mbedtls_ssl_config_defaults(\n        &amp;_sslCfg,\n        MBEDTLS_SSL_IS_CLIENT,\n        MBEDTLS_SSL_TRANSPORT_STREAM,\n        MBEDTLS_SSL_PRESET_DEFAULT\n    );\n    LT_RET_NZ(ret);\n\n#ifdef MBEDTLS_SSL_ALPN\n    if (_alpnProtocols) {\n        ret = mbedtls_ssl_conf_alpn_protocols(&amp;_sslCfg, _alpnProtocols);\n        LT_RET_NZ(ret);\n    }\n#endif\n\n    if (_insecure) {\n        mbedtls_ssl_conf_authmode(&amp;_sslCfg, MBEDTLS_SSL_VERIFY_NONE);\n    } else if (rootCABuf) {\n        mbedtls_x509_crt_init(&amp;_caCert);\n        mbedtls_ssl_conf_authmode(&amp;_sslCfg, MBEDTLS_SSL_VERIFY_REQUIRED);\n        ret = mbedtls_x509_crt_parse(&amp;_caCert, (const unsigned char *)rootCABuf, strlen(rootCABuf) + 1);\n        mbedtls_ssl_conf_ca_chain(&amp;_sslCfg, &amp;_caCert, NULL);\n        if (ret &lt; 0) {\n            mbedtls_x509_crt_free(&amp;_caCert);\n            LT_RET(ret);\n        }\n    } else if (_useRootCA) {\n        return -1; // not implemented\n    } else if (pskIdent &amp;&amp; psk) {\n#ifdef MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED\n        uint16_t len = strlen(psk);\n        if ((len &amp; 1) != 0 || len &gt; 2 * MBEDTLS_PSK_MAX_LEN) {\n            LT_EM(SSL, \"PSK length invalid\");\n            return -1;\n        }\n        unsigned char pskBin[MBEDTLS_PSK_MAX_LEN] = {};\n        for (uint8_t i = 0; i &lt; len; i++) {\n            uint8_t c = psk[i];\n            c |= 0b00100000; // make lowercase\n            c -= '0' * (c &gt;= '0' &amp;&amp; c &lt;= '9');\n            c -= ('a' - 10) * (c &gt;= 'a' &amp;&amp; c &lt;= 'z');\n            if (c &gt; 0xf)\n                return -1;\n            pskBin[i / 2] |= c &lt;&lt; (4 * ((i &amp; 1) ^ 1));\n        }\n        ret = mbedtls_ssl_conf_psk(&amp;_sslCfg, pskBin, len / 2, (const unsigned char *)pskIdent, strlen(pskIdent));\n        LT_RET_NZ(ret);\n#else\n        return -1;\n#endif\n    } else {\n        return -1;\n    }\n\n    if (!_insecure &amp;&amp; clientCert &amp;&amp; clientKey) {\n        mbedtls_x509_crt_init(&amp;_clientCert);\n        mbedtls_pk_init(&amp;_clientKey);\n        LT_VM(SSL, \"Loading client cert\");\n        ret = mbedtls_x509_crt_parse(&amp;_clientCert, (const unsigned char *)clientCert, strlen(clientCert) + 1);\n        if (ret &lt; 0) {\n            mbedtls_x509_crt_free(&amp;_clientCert);\n            LT_RET(ret);\n        }\n        LT_VM(SSL, \"Loading private key\");\n        ret = mbedtls_pk_parse_key(&amp;_clientKey, (const unsigned char *)clientKey, strlen(clientKey) + 1, NULL, 0);\n        if (ret &lt; 0) {\n            mbedtls_x509_crt_free(&amp;_clientCert);\n            LT_RET(ret);\n        }\n        mbedtls_ssl_conf_own_cert(&amp;_sslCfg, &amp;_clientCert, &amp;_clientKey);\n    }\n\n    LT_VM(SSL, \"Setting TLS hostname\");\n    ret = mbedtls_ssl_set_hostname(&amp;_sslCtx, host);\n    LT_RET_NZ(ret);\n\n    mbedtls_ssl_conf_rng(&amp;_sslCfg, ssl_random, NULL);\n    ret = mbedtls_ssl_setup(&amp;_sslCtx, &amp;_sslCfg);\n    LT_RET_NZ(ret);\n\n    _sockTls = fd();\n    mbedtls_ssl_set_bio(&amp;_sslCtx, &amp;_sockTls, mbedtls_net_send, mbedtls_net_recv, NULL);\n    mbedtls_net_set_nonblock((mbedtls_net_context *)&amp;_sockTls);\n\n    LT_HEAP_I();\n\n    LT_VM(SSL, \"SSL handshake\");\n    if (_handshakeTimeout == 0)\n        _handshakeTimeout = timeout;\n    unsigned long start = millis();\n    while (ret = mbedtls_ssl_handshake(&amp;_sslCtx)) {\n        if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n            LT_RET(ret);\n        }\n        if ((millis() - start) &gt; _handshakeTimeout) {\n            LT_EM(SSL, \"SSL handshake timeout\");\n            return -1;\n        }\n        delay(2);\n    }\n\n    LT_HEAP_I();\n\n    if (clientCert &amp;&amp; clientKey) {\n        LT_DM(\n            SSL,\n            \"Protocol %s, ciphersuite %s\",\n            mbedtls_ssl_get_version(&amp;_sslCtx),\n            mbedtls_ssl_get_ciphersuite(&amp;_sslCtx)\n        );\n        ret = mbedtls_ssl_get_record_expansion(&amp;_sslCtx);\n        if (ret &gt;= 0)\n            LT_DM(SSL, \"Record expansion: %d\", ret);\n        else {\n            LT_WM(SSL, \"Record expansion unknown\");\n        }\n    }\n\n    LT_VM(SSL, \"Verifying certificate\");\n    ret = mbedtls_ssl_get_verify_result(&amp;_sslCtx);\n    if (ret) {\n        char buf[512];\n        memset(buf, 0, sizeof(buf));\n        mbedtls_x509_crt_verify_info(buf, sizeof(buf), \"  ! \", ret);\n        LT_EM(SSL, \"Failed to verify peer certificate! Verification info: %s\", buf);\n        return ret;\n    }\n\n    if (rootCABuf)\n        mbedtls_x509_crt_free(&amp;_caCert);\n    if (clientCert)\n        mbedtls_x509_crt_free(&amp;_clientCert);\n    if (clientKey != NULL)\n        mbedtls_pk_free(&amp;_clientKey);\n    return 0; // OK\n}\n\nsize_t MbedTLSClient::write(const uint8_t *buf, size_t size) {\n    int ret = -1;\n    while ((ret = mbedtls_ssl_write(&amp;_sslCtx, buf, size)) &lt;= 0) {\n        if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; ret != MBEDTLS_ERR_SSL_WANT_WRITE &amp;&amp; ret &lt; 0) {\n            LT_RET(ret);\n        }\n        delay(2);\n    }\n    return ret;\n}\n\nint MbedTLSClient::available() {\n    bool peeked = _peeked &gt;= 0;\n    if (!connected())\n        return peeked;\n\n    int ret = mbedtls_ssl_read(&amp;_sslCtx, NULL, 0);\n    if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; ret != MBEDTLS_ERR_SSL_WANT_WRITE &amp;&amp; ret &lt; 0) {\n        stop();\n        return peeked ? peeked : ret;\n    }\n    return mbedtls_ssl_get_bytes_avail(&amp;_sslCtx) + peeked;\n}\n\nint MbedTLSClient::read(uint8_t *buf, size_t size) {\n    bool peeked = false;\n    int toRead  = available();\n    if ((!buf &amp;&amp; size) || toRead &lt;= 0)\n        return -1;\n    if (!size)\n        return 0;\n    if (_peeked &gt;= 0) {\n        buf[0]  = _peeked;\n        _peeked = -1;\n        size--;\n        toRead--;\n        if (!size || !toRead)\n            return 1;\n        buf++;\n        peeked = true;\n    }\n\n    int ret = mbedtls_ssl_read(&amp;_sslCtx, buf, size);\n    if (ret &lt; 0) {\n        stop();\n        return peeked ? peeked : ret;\n    }\n    return ret + peeked;\n}\n\nint MbedTLSClient::peek() {\n    if (_peeked &gt;= 0)\n        return _peeked;\n    _peeked = timedRead();\n    return _peeked;\n}\n\nvoid MbedTLSClient::flush() {}\n\nint MbedTLSClient::lastError(char *buf, const size_t size) {\n    return 0; // TODO (?)\n}\n\nvoid MbedTLSClient::setInsecure() {\n    _caCertStr     = NULL;\n    _clientCertStr = NULL;\n    _clientKeyStr  = NULL;\n    _pskIdentStr   = NULL;\n    _pskStr        = NULL;\n    _insecure      = true;\n}\n\nvoid MbedTLSClient::setPreSharedKey(const char *pskIdent, const char *psk) {\n    _pskIdentStr = pskIdent;\n    _pskStr      = psk;\n}\n\nvoid MbedTLSClient::setCACert(const char *rootCA) {\n    _caCertStr = rootCA;\n}\n\nvoid MbedTLSClient::setCertificate(const char *clientCA) {\n    _clientCertStr = clientCA;\n}\n\nvoid MbedTLSClient::setPrivateKey(const char *privateKey) {\n    _clientKeyStr = privateKey;\n}\n\nchar *streamToStr(Stream &amp;stream, size_t size) {\n    char *buf = (char *)malloc(size + 1);\n    if (!buf)\n        return NULL;\n    if (size != stream.readBytes(buf, size)) {\n        free(buf);\n        return NULL;\n    }\n    buf[size] = '\\0';\n    return buf;\n}\n\nbool MbedTLSClient::loadCACert(Stream &amp;stream, size_t size) {\n    char *str = streamToStr(stream, size);\n    if (str) {\n        _caCertStr = str;\n        return true;\n    }\n    return false;\n}\n\nbool MbedTLSClient::loadCertificate(Stream &amp;stream, size_t size) {\n    char *str = streamToStr(stream, size);\n    if (str) {\n        _clientCertStr = str;\n        return true;\n    }\n    return false;\n}\n\nbool MbedTLSClient::loadPrivateKey(Stream &amp;stream, size_t size) {\n    char *str = streamToStr(stream, size);\n    if (str) {\n        _clientKeyStr = str;\n        return true;\n    }\n    return false;\n}\n\nbool MbedTLSClient::verify(const char *fingerprint, const char *domainName) {\n    uint8_t fpLocal[32] = {};\n    uint16_t len        = strlen(fingerprint);\n    uint8_t byte        = 0;\n    for (uint8_t i = 0; i &lt; len; i++) {\n        uint8_t c = fingerprint[i];\n        while ((c == ' ' || c == ':') &amp;&amp; i &lt; len) {\n            c = fingerprint[++i];\n        }\n        c |= 0b00100000; // make lowercase\n        c -= '0' * (c &gt;= '0' &amp;&amp; c &lt;= '9');\n        c -= ('a' - 10) * (c &gt;= 'a' &amp;&amp; c &lt;= 'z');\n        if (c &gt; 0xf)\n            return -1;\n        fpLocal[byte / 2] |= c &lt;&lt; (4 * ((byte &amp; 1) ^ 1));\n        byte++;\n        if (byte &gt;= 64)\n            break;\n    }\n\n    uint8_t fpRemote[32];\n    if (!getFingerprintSHA256(fpRemote))\n        return false;\n\n    if (memcmp(fpLocal, fpRemote, 32)) {\n        LT_DM(SSL, \"Fingerprints don't match\");\n        return false;\n    }\n\n    if (!domainName)\n        return true;\n    // TODO domain name verification\n    return true;\n}\n\nvoid MbedTLSClient::setHandshakeTimeout(unsigned long handshakeTimeout) {\n    _handshakeTimeout = handshakeTimeout * 1000;\n}\n\nvoid MbedTLSClient::setAlpnProtocols(const char **alpnProtocols) {\n    _alpnProtocols = alpnProtocols;\n}\n\nbool MbedTLSClient::getFingerprintSHA256(uint8_t result[32]) {\n    const mbedtls_x509_crt *cert = mbedtls_ssl_get_peer_cert(&amp;_sslCtx);\n    if (!cert) {\n        LT_EM(SSL, \"Failed to get peer certificate\");\n        return false;\n    }\n    mbedtls_sha256_context shaCtx;\n    mbedtls_sha256_init(&amp;shaCtx);\n    mbedtls_sha256_starts(&amp;shaCtx, false);\n    mbedtls_sha256_update(&amp;shaCtx, cert-&gt;raw.p, cert-&gt;raw.len);\n    mbedtls_sha256_finish(&amp;shaCtx, result);\n    return true;\n}\n\n#endif // LT_ARD_HAS_WIFI &amp;&amp; LT_HAS_MBEDTLS\n</code></pre>"},{"location":"ltapi/_mbed_t_l_s_client_8h/","title":"File MbedTLSClient.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; ssl &gt; MbedTLSClient.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;api/WiFi/WiFi.h&gt;</code></li> <li><code>#include &lt;api/WiFiClient.h&gt;</code></li> <li><code>#include &lt;api/WiFiClientSecure.h&gt;</code></li> <li><code>#include &lt;mbedtls/net.h&gt;</code></li> </ul>"},{"location":"ltapi/_mbed_t_l_s_client_8h/#classes","title":"Classes","text":"Type Name     class MbedTLSClient      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/NetUtils/ssl/MbedTLSClient.h</code></p>"},{"location":"ltapi/_mbed_t_l_s_client_8h_source/","title":"File MbedTLSClient.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; NetUtils &gt; ssl &gt; MbedTLSClient.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-04-30. */\n\n#pragma once\n\n#include &lt;api/WiFi/WiFi.h&gt;\n#include &lt;api/WiFiClient.h&gt;\n#include &lt;api/WiFiClientSecure.h&gt;\n\n#include &lt;WiFiClient.h&gt; // extend family's WiFiClient impl\n\nextern \"C\" {\n\n#include &lt;mbedtls/net.h&gt;\n\n} // extern \"C\"\n\nclass MbedTLSClient : public WiFiClient, public IWiFiClientSecure {\n  private:\n    mbedtls_ssl_context _sslCtx;\n    mbedtls_ssl_config _sslCfg;\n    mbedtls_x509_crt _caCert;\n    mbedtls_x509_crt _clientCert;\n    mbedtls_pk_context _clientKey;\n    uint32_t _handshakeTimeout = 0;\n\n    void init();\n    int _sockTls    = -1;\n    bool _insecure  = false;\n    bool _useRootCA = false;\n    int _peeked     = -1;\n\n    const char *_caCertStr;\n    const char *_clientCertStr;\n    const char *_clientKeyStr;\n    const char *_pskIdentStr;\n    const char *_pskStr;\n    const char **_alpnProtocols;\n\n    int connect(\n        const char *host,\n        uint16_t port,\n        int32_t timeout,\n        const char *rootCABuf,\n        const char *clientCert,\n        const char *clientKey,\n        const char *pskIdent,\n        const char *psk\n    );\n\n  public:\n    MbedTLSClient();\n    MbedTLSClient(int sock);\n    ~MbedTLSClient();\n\n    int connect(IPAddress ip, uint16_t port, int32_t timeout);\n    int connect(const char *host, uint16_t port, int32_t timeout);\n\n    int connect(IPAddress ip, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey);\n    int connect(const char *host, uint16_t port, const char *rootCABuf, const char *clientCert, const char *clientKey);\n    int connect(IPAddress ip, uint16_t port, const char *pskIdent, const char *psk);\n    int connect(const char *host, uint16_t port, const char *pskIdent, const char *psk);\n\n    size_t write(const uint8_t *buf, size_t size);\n\n    int available();\n\n    int read(uint8_t *buf, size_t size);\n    int peek();\n    void flush();\n    void stop();\n\n    int lastError(char *buf, const size_t size);\n    void setInsecure(); // Don't validate the chain, just accept whatever is given. VERY INSECURE!\n    void setPreSharedKey(const char *pskIdent, const char *psk); // psk in hex\n    void setCACert(const char *rootCA);\n    void setCertificate(const char *clientCA);\n    void setPrivateKey(const char *privateKey);\n    bool loadCACert(Stream &amp;stream, size_t size);\n    bool loadCertificate(Stream &amp;stream, size_t size);\n    bool loadPrivateKey(Stream &amp;stream, size_t size);\n    bool verify(const char *fingerprint, const char *domainName);\n    void setHandshakeTimeout(unsigned long handshakeTimeout);\n    void setAlpnProtocols(const char **alpnProtocols);\n    bool getFingerprintSHA256(uint8_t result[32]);\n\n    using WiFiClient::connect;\n    using WiFiClient::read;\n};\n</code></pre>"},{"location":"ltapi/dir_f2f7add1a2e52abf595ee4625832c60b/","title":"Dir arduino/libretuya/libraries/StreamString","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; StreamString</p>"},{"location":"ltapi/dir_f2f7add1a2e52abf595ee4625832c60b/#files","title":"Files","text":"Type Name     file StreamString.cpp    file StreamString.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/StreamString/</code></p>"},{"location":"ltapi/_stream_string_8cpp/","title":"File StreamString.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; StreamString &gt; StreamString.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include \"StreamString.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/StreamString/StreamString.cpp</code></p>"},{"location":"ltapi/_stream_string_8cpp_source/","title":"File StreamString.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; StreamString &gt; StreamString.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;Arduino.h&gt;\n#include \"StreamString.h\"\n\nsize_t StreamString::write(const uint8_t *data, size_t size) {\n    if(size &amp;&amp; data) {\n        concat(data, size);\n        return size;\n    }\n    return 0;\n}\n\nsize_t StreamString::write(uint8_t data) {\n    return concat((char) data);\n}\n\nint StreamString::available() {\n    return length();\n}\n\nint StreamString::read() {\n    if(length()) {\n        char c = charAt(0);\n        remove(0, 1);\n        return c;\n\n    }\n    return -1;\n}\n\nint StreamString::peek() {\n    if(length()) {\n        char c = charAt(0);\n        return c;\n    }\n    return -1;\n}\n\nvoid StreamString::flush() {\n}\n</code></pre>"},{"location":"ltapi/_stream_string_8h/","title":"File StreamString.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; StreamString &gt; StreamString.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_stream_string_8h/#classes","title":"Classes","text":"Type Name     class StreamString      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/StreamString/StreamString.h</code></p>"},{"location":"ltapi/_stream_string_8h_source/","title":"File StreamString.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; StreamString &gt; StreamString.h</p> <p>Go to the documentation of this file. </p> <pre><code>#ifndef STREAMSTRING_H_\n#define STREAMSTRING_H_\n\n\nclass StreamString: public Stream, public String\n{\npublic:\n    size_t write(const uint8_t *buffer, size_t size) override;\n    size_t write(uint8_t data) override;\n\n    int available() override;\n    int read() override;\n    int peek() override;\n    void flush() override;\n};\n\n\n#endif /* STREAMSTRING_H_ */\n</code></pre>"},{"location":"ltapi/dir_03e9b5095395998e8262a18a0a750306/","title":"Dir arduino/libretuya/libraries/Update","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Update</p>"},{"location":"ltapi/dir_03e9b5095395998e8262a18a0a750306/#files","title":"Files","text":"Type Name     file Update.cpp    file Update.h    file UpdateUtil.cpp      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Update/</code></p>"},{"location":"ltapi/_update_8cpp/","title":"File Update.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Update &gt; Update.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Update.h\"</code></li> </ul>"},{"location":"ltapi/_update_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name     UpdateClass Update"},{"location":"ltapi/_update_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_update_8cpp/#variable-update","title":"variable Update","text":"<pre><code>UpdateClass Update;\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Update/Update.cpp</code></p>"},{"location":"ltapi/_update_8cpp_source/","title":"File Update.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; Update &gt; Update.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-29. */\n\n#include \"Update.h\"\n\nUpdateClass::UpdateClass() : ctx(NULL), info(NULL), buf(NULL) {\n    cleanup();\n}\n\nbool UpdateClass::begin(size_t size, int command, int unused2, uint8_t unused3, const char *unused4) {\n    if (ctx)\n        return false;\n    cleanup();\n\n    LT_DM(OTA, \"begin(%u, ...) / OTA curr: %u, trgt: %u\", size, LT.otaGetRunning(), LT.otaGetTarget());\n\n    ctx  = uf2_ctx_init(LT.otaGetTarget(), FAMILY);\n    info = uf2_info_init();\n\n    if (!size) {\n        cleanup(UPDATE_ERROR_SIZE);\n        return false;\n    }\n\n    if (command != U_FLASH) {\n        cleanup(UPDATE_ERROR_BAD_ARGUMENT);\n        return false;\n    }\n\n    bytesTotal = size;\n    return true;\n}\n\nbool UpdateClass::end(bool evenIfRemaining) {\n    if (hasError() || !ctx)\n        // false if not running\n        return false;\n\n    if (!isFinished() &amp;&amp; !evenIfRemaining) {\n        // abort if not finished\n        cleanup(UPDATE_ERROR_ABORT);\n        return false;\n    }\n    // TODO what is evenIfRemaining for?\n    if (!LT.otaSwitch()) {\n        // try to activate the second OTA\n        cleanup(UPDATE_ERROR_ACTIVATE);\n        return false;\n    }\n\n    cleanup();\n    return true;\n}\n\nsize_t UpdateClass::write(uint8_t *data, size_t len) {\n    size_t written = 0;\n    if (hasError() || !ctx)\n        // 0 if not running\n        return 0;\n\n    LT_VM(OTA, \"write(%u) / buf %u/512\", len, bufSize());\n\n    /* while (buf == bufPos &amp;&amp; len &gt;= UF2_BLOCK_SIZE) {\n        // buffer empty and entire block is in data\n        if (!tryWriteData(data, UF2_BLOCK_SIZE)) {\n            // returns 0 if data contains an invalid block\n            return written;\n        }\n        data += UF2_BLOCK_SIZE;\n        len -= UF2_BLOCK_SIZE;\n        written += UF2_BLOCK_SIZE;\n    } */\n\n    // write until buffer space is available\n    uint16_t toWrite; // 1..512\n    while (len &amp;&amp; (toWrite = min(len, bufLeft()))) {\n        tryWriteData(data, toWrite);\n        if (hasError()) {\n            // return on errors\n            printErrorContext2(data, toWrite);\n            return written;\n        }\n        data += toWrite;\n        len -= toWrite;\n        written += toWrite;\n    }\n    return written;\n}\n\nsize_t UpdateClass::writeStream(Stream &amp;data) {\n    size_t written = 0;\n    if (hasError() || !ctx)\n        // 0 if not running\n        return 0;\n\n    uint32_t lastData = millis();\n    // loop until the update is complete\n    while (remaining()) {\n        // check stream availability\n        int available = data.available();\n        if (available &lt;= 0) {\n            if (millis() - lastData &gt; UPDATE_TIMEOUT_MS) {\n                // waited for data too long; abort with error\n                cleanup(UPDATE_ERROR_STREAM);\n                return written;\n            }\n            continue;\n        }\n        // available &gt; 0\n        lastData = millis();\n\n        // read data to fit in the remaining buffer space\n        bufAlloc();\n        uint16_t read = data.readBytes(bufPos, bufLeft());\n        bufPos += read;\n        written += read;\n        tryWriteData();\n        if (hasError()) {\n            // return on errors\n            printErrorContext2(NULL, read); // buf is not valid anymore\n            return written;\n        }\n    }\n    return written;\n}\n\nsize_t UpdateClass::tryWriteData(uint8_t *data, size_t len) {\n    uf2_block_t *block = NULL;\n\n    LT_VM(OTA, \"Writing %u to buffer (%u/512)\", len, bufSize());\n\n    if (len == UF2_BLOCK_SIZE) {\n        // data has a complete block\n        block = (uf2_block_t *)data;\n    } else if (data &amp;&amp; len) {\n        // data has a part of a block, copy it to buffer\n        bufAlloc();\n        memcpy(bufPos, data, len);\n        bufPos += len;\n    }\n\n    if (!block &amp;&amp; bufSize() == UF2_BLOCK_SIZE) {\n        // use buffer as block (only if not found above)\n        block = (uf2_block_t *)buf;\n    }\n\n    // a complete block has been found\n    if (block) {\n        if (checkUf2Error(uf2_check_block(ctx, block)))\n            // block is invalid\n            return 0;\n\n        if (errUf2 == UF2_ERR_IGNORE)\n            // treat ignored blocks as valid\n            return UF2_BLOCK_SIZE;\n\n        if (!bytesWritten) {\n            // parse header block to allow retrieving firmware info\n            if (checkUf2Error(uf2_parse_header(ctx, block, info)))\n                // header is invalid\n                return 0;\n\n            LT_IM(OTA, \"%s v%s - LT v%s @ %s\", info-&gt;fw_name, info-&gt;fw_version, info-&gt;lt_version, info-&gt;board);\n\n            if (bytesTotal == UPDATE_SIZE_UNKNOWN) {\n                // set total update size from block count info\n                bytesTotal = block-&gt;block_count * UF2_BLOCK_SIZE;\n            } else if (bytesTotal != block-&gt;block_count * UF2_BLOCK_SIZE) {\n                // given update size does not match the block count\n                LT_EM(OTA, \"Image size wrong; got %u, calculated %u\", bytesTotal, block-&gt;block_count * UF2_BLOCK_SIZE);\n                cleanup(UPDATE_ERROR_SIZE);\n                return 0;\n            }\n        } else {\n            // write data blocks normally\n            if (checkUf2Error(uf2_write(ctx, block)))\n                // block writing failed\n                return 0;\n        }\n\n        // increment total writing progress\n        bytesWritten += UF2_BLOCK_SIZE;\n        // call progress callback\n        if (callback)\n            callback(bytesWritten, bytesTotal);\n        // reset the buffer as it's used already\n        if (bufSize() == UF2_BLOCK_SIZE)\n            bufPos = buf;\n        return UF2_BLOCK_SIZE;\n    }\n\n    return 0;\n}\n\nUpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_8h/","title":"File Update.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Update &gt; Update.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;uf2ota/uf2ota.h&gt;</code></li> </ul>"},{"location":"ltapi/_update_8h/#classes","title":"Classes","text":"Type Name     class UpdateClass"},{"location":"ltapi/_update_8h/#public-attributes","title":"Public Attributes","text":"Type Name     UpdateClass Update"},{"location":"ltapi/_update_8h/#macros","title":"Macros","text":"Type Name     define ENCRYPTED_BLOCK_SIZE  16   define UPDATE_ERROR_ABORT  (12)   define UPDATE_ERROR_ACTIVATE  (9)   define UPDATE_ERROR_BAD_ARGUMENT  (11)   define UPDATE_ERROR_ERASE  (2)   define UPDATE_ERROR_MAGIC_BYTE  (8)   define UPDATE_ERROR_MD5  (7)   define UPDATE_ERROR_NO_PARTITION  (10)   define UPDATE_ERROR_OK  (0)   define UPDATE_ERROR_READ  (3)   define UPDATE_ERROR_SIZE  (5)   define UPDATE_ERROR_SPACE  (4)   define UPDATE_ERROR_STREAM  (6)   define UPDATE_ERROR_WRITE  (1)   define UPDATE_SIZE_UNKNOWN  0xFFFFFFFF   define UPDATE_TIMEOUT_MS  30 * 1000   define U_AUTH  200   define U_FLASH  0   define U_SPIFFS  100"},{"location":"ltapi/_update_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/_update_8h/#variable-update","title":"variable Update","text":"<pre><code>UpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_update_8h/#define-encrypted_block_size","title":"define ENCRYPTED_BLOCK_SIZE","text":"<pre><code>#define ENCRYPTED_BLOCK_SIZE 16\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_abort","title":"define UPDATE_ERROR_ABORT","text":"<pre><code>#define UPDATE_ERROR_ABORT (12)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_activate","title":"define UPDATE_ERROR_ACTIVATE","text":"<pre><code>#define UPDATE_ERROR_ACTIVATE (9)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_bad_argument","title":"define UPDATE_ERROR_BAD_ARGUMENT","text":"<pre><code>#define UPDATE_ERROR_BAD_ARGUMENT (11)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_erase","title":"define UPDATE_ERROR_ERASE","text":"<pre><code>#define UPDATE_ERROR_ERASE (2)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_magic_byte","title":"define UPDATE_ERROR_MAGIC_BYTE","text":"<pre><code>#define UPDATE_ERROR_MAGIC_BYTE (8)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_md5","title":"define UPDATE_ERROR_MD5","text":"<pre><code>#define UPDATE_ERROR_MD5 (7)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_no_partition","title":"define UPDATE_ERROR_NO_PARTITION","text":"<pre><code>#define UPDATE_ERROR_NO_PARTITION (10)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_ok","title":"define UPDATE_ERROR_OK","text":"<pre><code>#define UPDATE_ERROR_OK (0)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_read","title":"define UPDATE_ERROR_READ","text":"<pre><code>#define UPDATE_ERROR_READ (3)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_size","title":"define UPDATE_ERROR_SIZE","text":"<pre><code>#define UPDATE_ERROR_SIZE (5)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_space","title":"define UPDATE_ERROR_SPACE","text":"<pre><code>#define UPDATE_ERROR_SPACE (4)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_stream","title":"define UPDATE_ERROR_STREAM","text":"<pre><code>#define UPDATE_ERROR_STREAM (6)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_error_write","title":"define UPDATE_ERROR_WRITE","text":"<pre><code>#define UPDATE_ERROR_WRITE (1)\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_size_unknown","title":"define UPDATE_SIZE_UNKNOWN","text":"<pre><code>#define UPDATE_SIZE_UNKNOWN 0xFFFFFFFF\n</code></pre>"},{"location":"ltapi/_update_8h/#define-update_timeout_ms","title":"define UPDATE_TIMEOUT_MS","text":"<pre><code>#define UPDATE_TIMEOUT_MS 30 * 1000\n</code></pre>"},{"location":"ltapi/_update_8h/#define-u_auth","title":"define U_AUTH","text":"<pre><code>#define U_AUTH 200\n</code></pre>"},{"location":"ltapi/_update_8h/#define-u_flash","title":"define U_FLASH","text":"<pre><code>#define U_FLASH 0\n</code></pre>"},{"location":"ltapi/_update_8h/#define-u_spiffs","title":"define U_SPIFFS","text":"<pre><code>#define U_SPIFFS 100\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Update/Update.h</code></p>"},{"location":"ltapi/_update_8h_source/","title":"File Update.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; Update &gt; Update.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;functional&gt;\n#include &lt;uf2ota/uf2ota.h&gt;\n\n// No Error\n#define UPDATE_ERROR_OK           (0)\n// Flash Write Failed\n#define UPDATE_ERROR_WRITE        (1)\n// Flash Erase Failed\n#define UPDATE_ERROR_ERASE        (2)\n// Flash Read Failed\n#define UPDATE_ERROR_READ         (3)\n// Not Enough Space\n#define UPDATE_ERROR_SPACE        (4)\n// Bad Size Given\n#define UPDATE_ERROR_SIZE         (5)\n// Stream Read Timeout\n#define UPDATE_ERROR_STREAM       (6)\n// MD5 Check Failed\n#define UPDATE_ERROR_MD5          (7)\n// Wrong Magic Byte\n#define UPDATE_ERROR_MAGIC_BYTE   (8)\n// Could Not Activate The Firmware\n#define UPDATE_ERROR_ACTIVATE     (9)\n// Partition Could Not be Found\n#define UPDATE_ERROR_NO_PARTITION (10)\n// Bad Argument\n#define UPDATE_ERROR_BAD_ARGUMENT (11)\n// Aborted\n#define UPDATE_ERROR_ABORT        (12)\n\n#define UPDATE_SIZE_UNKNOWN 0xFFFFFFFF\n\n#define U_FLASH  0\n#define U_SPIFFS 100\n#define U_AUTH   200\n\n#define ENCRYPTED_BLOCK_SIZE 16\n\n#define UPDATE_TIMEOUT_MS 30 * 1000\n\nclass UpdateClass {\n  public:\n    typedef std::function&lt;void(size_t, size_t)&gt; THandlerFunction_Progress;\n\n  public: /* Update.cpp */\n    UpdateClass();\n    bool begin(\n        size_t size         = UPDATE_SIZE_UNKNOWN,\n        int command         = U_FLASH,\n        int unused2         = -1,\n        uint8_t unused3     = LOW,\n        const char *unused4 = NULL // this is for SPIFFS\n    );\n    bool end(bool evenIfRemaining = false);\n    size_t write(uint8_t *data, size_t len);\n    size_t writeStream(Stream &amp;data);\n    bool canRollBack();\n    bool rollBack();\n    // bool setMD5(const char *expected_md5);\n\n  private: /* Update.cpp */\n    size_t tryWriteData(uint8_t *data = NULL, size_t len = 0);\n\n  public: /* UpdateUtil.cpp */\n    UpdateClass &amp;onProgress(THandlerFunction_Progress callback);\n    void abort();\n    void printError(Print &amp;out);\n    const char *errorString();\n    const char *getFirmwareName();\n    const char *getFirmwareVersion();\n    const char *getLibreTuyaVersion();\n    const char *getBoardName();\n\n  private: /* UpdateUtil.cpp */\n    void cleanup(uint8_t ardErr = UPDATE_ERROR_OK, uf2_err_t uf2Err = UF2_ERR_OK);\n    bool checkUf2Error(uf2_err_t err);\n    void bufAlloc();\n    void printErrorContext1();\n    void printErrorContext2(const uint8_t *data, size_t len);\n    uint16_t bufLeft();\n    uint16_t bufSize();\n\n  private:\n    // uf2ota context\n    uf2_ota_t *ctx;\n    uf2_info_t *info;\n    // block buffer\n    uint8_t *buf;\n    uint8_t *bufPos;\n    // update progress - multiplies of 512 bytes\n    uint32_t bytesWritten;\n    uint32_t bytesTotal;\n    // errors\n    uf2_err_t errUf2;\n    uint8_t errArd;\n    // progress callback\n    THandlerFunction_Progress callback;\n    // String _target_md5;\n    // MD5Builder _md5;\n\n  public:\n    String md5String(void) {\n        // return _md5.toString();\n    }\n\n    void md5(uint8_t *result) {\n        // return _md5.getBytes(result);\n    }\n\n    uint8_t getError() {\n        return errArd;\n    }\n\n    uf2_err_t getUF2Error() {\n        return errUf2;\n    }\n\n    uint16_t getErrorCode() {\n        return (errArd &lt;&lt; 8) | errUf2;\n    }\n\n    void clearError() {\n        cleanup(UPDATE_ERROR_OK);\n    }\n\n    bool hasError() {\n        return errArd != UPDATE_ERROR_OK;\n    }\n\n    bool isRunning() {\n        return ctx != NULL;\n    }\n\n    bool isFinished() {\n        return bytesWritten == bytesTotal;\n    }\n\n    size_t size() {\n        return bytesTotal;\n    }\n\n    size_t progress() {\n        return bytesWritten;\n    }\n\n    size_t remaining() {\n        return bytesTotal - bytesWritten;\n    }\n};\n\nextern UpdateClass Update;\n</code></pre>"},{"location":"ltapi/_update_util_8cpp/","title":"File UpdateUtil.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; Update &gt; UpdateUtil.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Update.h\"</code></li> </ul>"},{"location":"ltapi/_update_util_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const uint8_t errorMap   = = {   UPDATE_ERROR_OK,    UPDATE_ERROR_OK,    UPDATE_ERROR_MAGIC_BYTE,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_MAGIC_BYTE,    UPDATE_ERROR_NO_PARTITION,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_BAD_ARGUMENT,    UPDATE_ERROR_ERASE,    UPDATE_ERROR_WRITE,    UPDATE_ERROR_WRITE    }    char errorStr"},{"location":"ltapi/_update_util_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/_update_util_8cpp/#variable-errormap","title":"variable errorMap","text":"<pre><code>const uint8_t errorMap[];\n</code></pre>"},{"location":"ltapi/_update_util_8cpp/#variable-errorstr","title":"variable errorStr","text":"<pre><code>char errorStr[14];\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/Update/UpdateUtil.cpp</code></p>"},{"location":"ltapi/_update_util_8cpp_source/","title":"File UpdateUtil.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; Update &gt; UpdateUtil.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-30. */\n\n#include \"Update.h\"\n\nstatic const uint8_t errorMap[] = {\n    UPDATE_ERROR_OK,           /* UF2_ERR_OK - no error */\n    UPDATE_ERROR_OK,           /* UF2_ERR_IGNORE - block should be ignored */\n    UPDATE_ERROR_MAGIC_BYTE,   /* UF2_ERR_MAGIC - wrong magic numbers */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_FAMILY - family ID mismatched */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_NOT_HEADER - block is not a header */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_OTA_VER - unknown/invalid OTA format version */\n    UPDATE_ERROR_MAGIC_BYTE,   /* UF2_ERR_OTA_WRONG - no data for current OTA index */\n    UPDATE_ERROR_NO_PARTITION, /* UF2_ERR_PART_404 - no partition with that name */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_PART_ONE - only one partition tag in a block */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_PART_UNSET - attempted to write without target partition */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_DATA_TOO_LONG - data too long - tags won't fit */\n    UPDATE_ERROR_BAD_ARGUMENT, /* UF2_ERR_SEQ_MISMATCH - sequence number mismatched */\n    UPDATE_ERROR_ERASE,        /* UF2_ERR_ERASE_FAILED - erasing flash failed */\n    UPDATE_ERROR_WRITE,        /* UF2_ERR_WRITE_FAILED - writing to flash failed */\n    UPDATE_ERROR_WRITE         /* UF2_ERR_WRITE_LENGTH - wrote fewer data than requested */\n};\n\nstatic char errorStr[14];\n\nUpdateClass &amp;UpdateClass::onProgress(THandlerFunction_Progress callback) {\n    this-&gt;callback = callback;\n    return *this;\n}\n\nvoid UpdateClass::cleanup(uint8_t ardErr, uf2_err_t uf2Err) {\n    errUf2 = uf2Err;\n    errArd = ardErr;\n\n#if LT_DEBUG_OTA\n    if (hasError())\n        printErrorContext1();\n#endif\n\n    free(ctx); // NULL in constructor\n    ctx = NULL;\n    uf2_info_free(info); // NULL in constructor\n    info = NULL;\n    free(buf); // NULL in constructor\n    buf = bufPos = NULL;\n\n    bytesWritten = 0;\n    bytesTotal   = 0;\n}\n\nbool UpdateClass::checkUf2Error(uf2_err_t err) {\n    if (err &lt;= UF2_ERR_IGNORE)\n        return false;\n    cleanup(errorMap[err], err);\n    return true;\n}\n\nvoid UpdateClass::abort() {\n    LT_DM(OTA, \"Aborting update\");\n    cleanup(UPDATE_ERROR_ABORT);\n}\n\nvoid UpdateClass::bufAlloc() {\n    if (!buf)\n        buf = bufPos = (uint8_t *)malloc(UF2_BLOCK_SIZE);\n}\n\nuint16_t UpdateClass::bufLeft() {\n    return buf + UF2_BLOCK_SIZE - bufPos;\n}\n\nuint16_t UpdateClass::bufSize() {\n    return bufPos - buf;\n}\n\nvoid UpdateClass::printError(Print &amp;out) {\n    out.println(errorString());\n}\n\nvoid UpdateClass::printErrorContext1() {\n#if LT_DEBUG_OTA\n    LT_EM(OTA, \"Error: %s\", errorString());\n    if (errArd == UPDATE_ERROR_ABORT)\n        return;\n\n    LT_EM(OTA, \"- written: %u of %u\", bytesWritten, bytesTotal);\n    LT_EM(OTA, \"- buf: size=%u, left=%u\", bufSize(), bufLeft());\n    hexdump(buf, bufSize());\n\n    if (ctx)\n        LT_EM(\n            OTA,\n            \"- ctx: seq=%u, part1=%s, part2=%s\",\n            ctx-&gt;seq - 1, // print last parsed block seq\n            ctx-&gt;part1 ? ctx-&gt;part1-&gt;name : NULL,\n            ctx-&gt;part2 ? ctx-&gt;part2-&gt;name : NULL\n        );\n\n    uf2_block_t *block = (uf2_block_t *)buf;\n    if (buf)\n        LT_EM(OTA, \"- buf: seq=%u/%u, addr=%u, len=%u\", block-&gt;block_seq, block-&gt;block_count, block-&gt;addr, block-&gt;len);\n#endif\n}\n\nvoid UpdateClass::printErrorContext2(const uint8_t *data, size_t len) {\n#if LT_DEBUG_OTA\n    LT_EM(OTA, \"- while writing %u bytes\", len);\n    if (data)\n        hexdump(data, len);\n#endif\n}\n\nconst char *UpdateClass::errorString() {\n    if (!errArd &amp;&amp; !errUf2)\n        return \"\";\n    sprintf(errorStr, \"ard=%u,uf2=%u\", errArd, errUf2);\n    return errorStr;\n}\n\nconst char *UpdateClass::getFirmwareName() {\n    if (info)\n        return info-&gt;fw_name;\n    return NULL;\n}\n\nconst char *UpdateClass::getFirmwareVersion() {\n    if (info)\n        return info-&gt;fw_version;\n    return NULL;\n}\n\nconst char *UpdateClass::getLibreTuyaVersion() {\n    if (info)\n        return info-&gt;lt_version;\n    return NULL;\n}\n\nconst char *UpdateClass::getBoardName() {\n    if (info)\n        return info-&gt;board;\n    return NULL;\n}\n\nbool UpdateClass::canRollBack() {\n    return LT.otaCanRollback();\n}\n\nbool UpdateClass::rollBack() {\n    return LT.otaRollback();\n}\n</code></pre>"},{"location":"ltapi/dir_f379af8e162090f0d80d0b7a3c25d056/","title":"Dir arduino/libretuya/libraries/WebServer","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer</p>"},{"location":"ltapi/dir_f379af8e162090f0d80d0b7a3c25d056/#files","title":"Files","text":"Type Name     file HTTP_Method.h    file Parsing.cpp    file Uri.h    file WebServer.cpp    file WebServer.h"},{"location":"ltapi/dir_f379af8e162090f0d80d0b7a3c25d056/#directories","title":"Directories","text":"Type Name     dir detail    dir uri      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/</code></p>"},{"location":"ltapi/_h_t_t_p___method_8h/","title":"File HTTP_Method.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; HTTP_Method.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/_h_t_t_p___method_8h/#public-types","title":"Public Types","text":"Type Name     typedef enum http_method HTTPMethod    enum http_method"},{"location":"ltapi/_h_t_t_p___method_8h/#macros","title":"Macros","text":"Type Name     define HTTP_ANY  (HTTPMethod)(255)   define HTTP_METHOD_MAP (XX)    define XX (num, name, string) HTTP_##name = num,"},{"location":"ltapi/_h_t_t_p___method_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_h_t_t_p___method_8h/#typedef-httpmethod","title":"typedef HTTPMethod","text":"<pre><code>typedef enum http_method HTTPMethod;\n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#enum-http_method","title":"enum http_method","text":"<pre><code>enum http_method;\n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_h_t_t_p___method_8h/#define-http_any","title":"define HTTP_ANY","text":"<pre><code>#define HTTP_ANY (HTTPMethod)(255)\n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#define-http_method_map","title":"define HTTP_METHOD_MAP","text":"<pre><code>#define HTTP_METHOD_MAP (\n    XX\n) \n</code></pre>"},{"location":"ltapi/_h_t_t_p___method_8h/#define-xx","title":"define XX","text":"<pre><code>#define XX (\n    num,\n    name,\n    string\n) HTTP_##name = num,\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/HTTP_Method.h</code></p>"},{"location":"ltapi/_h_t_t_p___method_8h_source/","title":"File HTTP_Method.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; HTTP_Method.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n/* Request Methods */\n#define HTTP_METHOD_MAP(XX)                                                                                            \\\n    XX(0, DELETE, DELETE)                                                                                              \\\n    XX(1, GET, GET)                                                                                                    \\\n    XX(2, HEAD, HEAD)                                                                                                  \\\n    XX(3, POST, POST)                                                                                                  \\\n    XX(4, PUT, PUT)                                                                                                    \\\n    /* pathological */                                                                                                 \\\n    XX(5, CONNECT, CONNECT)                                                                                            \\\n    XX(6, OPTIONS, OPTIONS)                                                                                            \\\n    XX(7, TRACE, TRACE)                                                                                                \\\n    /* WebDAV */                                                                                                       \\\n    XX(8, COPY, COPY)                                                                                                  \\\n    XX(9, LOCK, LOCK)                                                                                                  \\\n    XX(10, MKCOL, MKCOL)                                                                                               \\\n    XX(11, MOVE, MOVE)                                                                                                 \\\n    XX(12, PROPFIND, PROPFIND)                                                                                         \\\n    XX(13, PROPPATCH, PROPPATCH)                                                                                       \\\n    XX(14, SEARCH, SEARCH)                                                                                             \\\n    XX(15, UNLOCK, UNLOCK)                                                                                             \\\n    XX(16, BIND, BIND)                                                                                                 \\\n    XX(17, REBIND, REBIND)                                                                                             \\\n    XX(18, UNBIND, UNBIND)                                                                                             \\\n    XX(19, ACL, ACL)                                                                                                   \\\n    /* subversion */                                                                                                   \\\n    XX(20, REPORT, REPORT)                                                                                             \\\n    XX(21, MKACTIVITY, MKACTIVITY)                                                                                     \\\n    XX(22, CHECKOUT, CHECKOUT)                                                                                         \\\n    XX(23, MERGE, MERGE)                                                                                               \\\n    /* upnp */                                                                                                         \\\n    XX(24, MSEARCH, M - SEARCH)                                                                                        \\\n    XX(25, NOTIFY, NOTIFY)                                                                                             \\\n    XX(26, SUBSCRIBE, SUBSCRIBE)                                                                                       \\\n    XX(27, UNSUBSCRIBE, UNSUBSCRIBE)                                                                                   \\\n    /* RFC-5789 */                                                                                                     \\\n    XX(28, PATCH, PATCH)                                                                                               \\\n    XX(29, PURGE, PURGE)                                                                                               \\\n    /* CalDAV */                                                                                                       \\\n    XX(30, MKCALENDAR, MKCALENDAR)                                                                                     \\\n    /* RFC-2068, section 19.6.1.2 */                                                                                   \\\n    XX(31, LINK, LINK)                                                                                                 \\\n    XX(32, UNLINK, UNLINK)                                                                                             \\\n    /* icecast */                                                                                                      \\\n    XX(33, SOURCE, SOURCE)\n\nenum http_method {\n\n#define XX(num, name, string) HTTP_##name = num,\n    HTTP_METHOD_MAP(XX)\n#undef XX\n};\n\ntypedef enum http_method HTTPMethod;\n#define HTTP_ANY (HTTPMethod)(255)\n</code></pre>"},{"location":"ltapi/_parsing_8cpp/","title":"File Parsing.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; Parsing.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/Parsing.cpp</code></p>"},{"location":"ltapi/_parsing_8cpp_source/","title":"File Parsing.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; Parsing.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  Parsing.cpp - HTTP request parsing.\n\n  Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#if LT_ARD_HAS_WIFI\n\n#include &lt;Arduino.h&gt;\n\n#include \"WebServer.h\"\n#include \"WiFiClient.h\"\n#include \"WiFiServer.h\"\n#include \"detail/mimetable.h\"\n\n#ifndef WEBSERVER_MAX_POST_ARGS\n#define WEBSERVER_MAX_POST_ARGS 32\n#endif\n\n#define __STR(a) #a\n#define _STR(a)  __STR(a)\nconst char *_http_method_str[] = {\n#define XX(num, name, string) _STR(name),\n    HTTP_METHOD_MAP(XX)\n#undef XX\n};\n\nstatic const char Content_Type[] PROGMEM = \"Content-Type\";\nstatic const char filename[] PROGMEM     = \"filename\";\n\nstatic char *readBytesWithTimeout(WiFiClient &amp;client, size_t maxLength, size_t &amp;dataLength, int timeout_ms) {\n    char *buf  = nullptr;\n    dataLength = 0;\n    while (dataLength &lt; maxLength) {\n        int tries = timeout_ms;\n        size_t newLength;\n        while (!(newLength = client.available()) &amp;&amp; tries--)\n            delay(1);\n        if (!newLength) {\n            break;\n        }\n        if (!buf) {\n            buf = (char *)malloc(newLength + 1);\n            if (!buf) {\n                return nullptr;\n            }\n        } else {\n            char *newBuf = (char *)realloc(buf, dataLength + newLength + 1);\n            if (!newBuf) {\n                free(buf);\n                return nullptr;\n            }\n            buf = newBuf;\n        }\n        client.readBytes(buf + dataLength, newLength);\n        dataLength += newLength;\n        buf[dataLength] = '\\0';\n    }\n    return buf;\n}\n\nbool WebServer::_parseRequest(WiFiClient &amp;client) {\n    // Read the first line of HTTP request\n    String req = client.readStringUntil('\\r');\n    client.readStringUntil('\\n');\n    // reset header value\n    for (int i = 0; i &lt; _headerKeysCount; ++i) {\n        _currentHeaders[i].value = String();\n    }\n\n    // First line of HTTP request looks like \"GET /path HTTP/1.1\"\n    // Retrieve the \"/path\" part by finding the spaces\n    int addr_start = req.indexOf(' ');\n    int addr_end   = req.indexOf(' ', addr_start + 1);\n    if (addr_start == -1 || addr_end == -1) {\n        log_e(\"Invalid request: %s\", req.c_str());\n        return false;\n    }\n\n    String methodStr  = req.substring(0, addr_start);\n    String url        = req.substring(addr_start + 1, addr_end);\n    String versionEnd = req.substring(addr_end + 8);\n    _currentVersion   = atoi(versionEnd.c_str());\n    String searchStr  = \"\";\n    int hasSearch     = url.indexOf('?');\n    if (hasSearch != -1) {\n        searchStr = url.substring(hasSearch + 1);\n        url       = url.substring(0, hasSearch);\n    }\n    _currentUri = url;\n    _chunked    = false;\n\n    HTTPMethod method  = HTTP_ANY;\n    size_t num_methods = sizeof(_http_method_str) / sizeof(const char *);\n    for (size_t i = 0; i &lt; num_methods; i++) {\n        if (methodStr == _http_method_str[i]) {\n            method = (HTTPMethod)i;\n            break;\n        }\n    }\n    if (method == HTTP_ANY) {\n        log_e(\"Unknown HTTP Method: %s\", methodStr.c_str());\n        return false;\n    }\n    _currentMethod = method;\n\n    log_v(\"method: %s url: %s search: %s\", methodStr.c_str(), url.c_str(), searchStr.c_str());\n\n    // attach handler\n    RequestHandler *handler;\n    for (handler = _firstHandler; handler; handler = handler-&gt;next()) {\n        if (handler-&gt;canHandle(_currentMethod, _currentUri))\n            break;\n    }\n    _currentHandler = handler;\n\n    String formData;\n    // below is needed only when POST type request\n    if (method == HTTP_POST || method == HTTP_PUT || method == HTTP_PATCH || method == HTTP_DELETE) {\n        String boundaryStr;\n        String headerName;\n        String headerValue;\n        bool isForm            = false;\n        bool isEncoded         = false;\n        uint32_t contentLength = 0;\n        // parse headers\n        while (1) {\n            req = client.readStringUntil('\\r');\n            client.readStringUntil('\\n');\n            if (req == \"\")\n                break; // no moar headers\n            int headerDiv = req.indexOf(':');\n            if (headerDiv == -1) {\n                break;\n            }\n            headerName  = req.substring(0, headerDiv);\n            headerValue = req.substring(headerDiv + 1);\n            headerValue.trim();\n            _collectHeader(headerName.c_str(), headerValue.c_str());\n\n            log_v(\"headerName: %s\", headerName.c_str());\n            log_v(\"headerValue: %s\", headerValue.c_str());\n\n            if (headerName.equalsIgnoreCase(FPSTR(Content_Type))) {\n                using namespace mime;\n                if (headerValue.startsWith(FPSTR(mimeTable[txt].mimeType))) {\n                    isForm = false;\n                } else if (headerValue.startsWith(F(\"application/x-www-form-urlencoded\"))) {\n                    isForm    = false;\n                    isEncoded = true;\n                } else if (headerValue.startsWith(F(\"multipart/\"))) {\n                    boundaryStr = headerValue.substring(headerValue.indexOf('=') + 1);\n                    boundaryStr.replace(\"\\\"\", \"\");\n                    isForm = true;\n                }\n            } else if (headerName.equalsIgnoreCase(F(\"Content-Length\"))) {\n                contentLength = headerValue.toInt();\n            } else if (headerName.equalsIgnoreCase(F(\"Host\"))) {\n                _hostHeader = headerValue;\n            }\n        }\n\n        if (!isForm) {\n            size_t plainLength;\n            char *plainBuf = readBytesWithTimeout(client, contentLength, plainLength, HTTP_MAX_POST_WAIT);\n            if (plainLength &lt; contentLength) {\n                free(plainBuf);\n                return false;\n            }\n            if (contentLength &gt; 0) {\n                if (isEncoded) {\n                    // url encoded form\n                    if (searchStr != \"\")\n                        searchStr += '&amp;';\n                    searchStr += plainBuf;\n                }\n                _parseArguments(searchStr);\n                if (!isEncoded) {\n                    // plain post json or other data\n                    RequestArgument &amp;arg = _currentArgs[_currentArgCount++];\n                    arg.key              = F(\"plain\");\n                    arg.value            = String(plainBuf);\n                }\n\n                log_v(\"Plain: %s\", plainBuf);\n                free(plainBuf);\n            } else {\n                // No content - but we can still have arguments in the URL.\n                _parseArguments(searchStr);\n            }\n        }\n\n        if (isForm) {\n            _parseArguments(searchStr);\n            if (!_parseForm(client, boundaryStr, contentLength)) {\n                return false;\n            }\n        }\n    } else {\n        String headerName;\n        String headerValue;\n        // parse headers\n        while (1) {\n            req = client.readStringUntil('\\r');\n            client.readStringUntil('\\n');\n            if (req == \"\")\n                break; // no moar headers\n            int headerDiv = req.indexOf(':');\n            if (headerDiv == -1) {\n                break;\n            }\n            headerName  = req.substring(0, headerDiv);\n            headerValue = req.substring(headerDiv + 2);\n            _collectHeader(headerName.c_str(), headerValue.c_str());\n\n            log_v(\"headerName: %s\", headerName.c_str());\n            log_v(\"headerValue: %s\", headerValue.c_str());\n\n            if (headerName.equalsIgnoreCase(\"Host\")) {\n                _hostHeader = headerValue;\n            }\n        }\n        _parseArguments(searchStr);\n    }\n    client.flush();\n\n    log_v(\"Request: %s\", url.c_str());\n    log_v(\" Arguments: %s\", searchStr.c_str());\n\n    return true;\n}\n\nbool WebServer::_collectHeader(const char *headerName, const char *headerValue) {\n    for (int i = 0; i &lt; _headerKeysCount; i++) {\n        if (_currentHeaders[i].key.equalsIgnoreCase(headerName)) {\n            _currentHeaders[i].value = headerValue;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid WebServer::_parseArguments(String data) {\n    log_v(\"args: %s\", data.c_str());\n    if (_currentArgs)\n        delete[] _currentArgs;\n    _currentArgs = 0;\n    if (data.length() == 0) {\n        _currentArgCount = 0;\n        _currentArgs     = new RequestArgument[1];\n        return;\n    }\n    _currentArgCount = 1;\n\n    for (int i = 0; i &lt; (int)data.length();) {\n        i = data.indexOf('&amp;', i);\n        if (i == -1)\n            break;\n        ++i;\n        ++_currentArgCount;\n    }\n    log_v(\"args count: %d\", _currentArgCount);\n\n    _currentArgs = new RequestArgument[_currentArgCount + 1];\n    int pos      = 0;\n    int iarg;\n    for (iarg = 0; iarg &lt; _currentArgCount;) {\n        int equal_sign_index = data.indexOf('=', pos);\n        int next_arg_index   = data.indexOf('&amp;', pos);\n        log_v(\"pos %d =@%d &amp;@%d\", pos, equal_sign_index, next_arg_index);\n        if ((equal_sign_index == -1) || ((equal_sign_index &gt; next_arg_index) &amp;&amp; (next_arg_index != -1))) {\n            log_e(\"arg missing value: %d\", iarg);\n            if (next_arg_index == -1)\n                break;\n            pos = next_arg_index + 1;\n            continue;\n        }\n        RequestArgument &amp;arg = _currentArgs[iarg];\n        arg.key              = urlDecode(data.substring(pos, equal_sign_index));\n        arg.value            = urlDecode(data.substring(equal_sign_index + 1, next_arg_index));\n        log_v(\"arg %d key: %s value: %s\", iarg, arg.key.c_str(), arg.value.c_str());\n        ++iarg;\n        if (next_arg_index == -1)\n            break;\n        pos = next_arg_index + 1;\n    }\n    _currentArgCount = iarg;\n    log_v(\"args count: %d\", _currentArgCount);\n}\n\nvoid WebServer::_uploadWriteByte(uint8_t b) {\n    if (_currentUpload-&gt;currentSize == HTTP_UPLOAD_BUFLEN) {\n        if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n            _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n        _currentUpload-&gt;totalSize += _currentUpload-&gt;currentSize;\n        _currentUpload-&gt;currentSize = 0;\n    }\n    _currentUpload-&gt;buf[_currentUpload-&gt;currentSize++] = b;\n}\n\nint WebServer::_uploadReadByte(WiFiClient &amp;client) {\n    int res = client.read();\n    if (res &lt; 0) {\n        // keep trying until you either read a valid byte or timeout\n        unsigned long startMillis  = millis();\n        long timeoutIntervalMillis = client.getTimeout();\n        boolean timedOut           = false;\n        for (;;) {\n            if (!client.connected())\n                return -1;\n            // loosely modeled after blinkWithoutDelay pattern\n            while (!timedOut &amp;&amp; !client.available() &amp;&amp; client.connected()) {\n                delay(2);\n                timedOut = millis() - startMillis &gt;= timeoutIntervalMillis;\n            }\n\n            res = client.read();\n            if (res &gt;= 0) {\n                return res; // exit on a valid read\n            }\n            // NOTE: it is possible to get here and have all of the following\n            //       assertions hold true\n            //\n            //       -- client.available() &gt; 0\n            //       -- client.connected == true\n            //       -- res == -1\n            //\n            //       a simple retry strategy overcomes this which is to say the\n            //       assertion is not permanent, but the reason that this works\n            //       is elusive, and possibly indicative of a more subtle underlying\n            //       issue\n\n            timedOut = millis() - startMillis &gt;= timeoutIntervalMillis;\n            if (timedOut) {\n                return res; // exit on a timeout\n            }\n        }\n    }\n\n    return res;\n}\n\nbool WebServer::_parseForm(WiFiClient &amp;client, String boundary, uint32_t len) {\n    (void)len;\n    log_v(\"Parse Form: Boundary: %s Length: %d\", boundary.c_str(), len);\n    String line;\n    int retry = 0;\n    do {\n        line = client.readStringUntil('\\r');\n        ++retry;\n    } while (line.length() == 0 &amp;&amp; retry &lt; 3);\n\n    client.readStringUntil('\\n');\n    // start reading the form\n    if (line == (\"--\" + boundary)) {\n        if (_postArgs)\n            delete[] _postArgs;\n        _postArgs    = new RequestArgument[WEBSERVER_MAX_POST_ARGS];\n        _postArgsLen = 0;\n        while (1) {\n            String argName;\n            String argValue;\n            String argType;\n            String argFilename;\n            bool argIsFile = false;\n\n            line = client.readStringUntil('\\r');\n            client.readStringUntil('\\n');\n            if (line.length() &gt; 19 &amp;&amp; line.substring(0, 19).equalsIgnoreCase(F(\"Content-Disposition\"))) {\n                int nameStart = line.indexOf('=');\n                if (nameStart != -1) {\n                    argName   = line.substring(nameStart + 2);\n                    nameStart = argName.indexOf('=');\n                    if (nameStart == -1) {\n                        argName = argName.substring(0, argName.length() - 1);\n                    } else {\n                        argFilename = argName.substring(nameStart + 2, argName.length() - 1);\n                        argName     = argName.substring(0, argName.indexOf('\"'));\n                        argIsFile   = true;\n                        log_v(\"PostArg FileName: %s\", argFilename.c_str());\n                        // use GET to set the filename if uploading using blob\n                        if (argFilename == F(\"blob\") &amp;&amp; hasArg(FPSTR(filename)))\n                            argFilename = arg(FPSTR(filename));\n                    }\n                    log_v(\"PostArg Name: %s\", argName.c_str());\n                    using namespace mime;\n                    argType = FPSTR(mimeTable[txt].mimeType);\n                    line    = client.readStringUntil('\\r');\n                    client.readStringUntil('\\n');\n                    if (line.length() &gt; 12 &amp;&amp; line.substring(0, 12).equalsIgnoreCase(FPSTR(Content_Type))) {\n                        argType = line.substring(line.indexOf(':') + 2);\n                        // skip next line\n                        client.readStringUntil('\\r');\n                        client.readStringUntil('\\n');\n                    }\n                    log_v(\"PostArg Type: %s\", argType.c_str());\n                    if (!argIsFile) {\n                        while (1) {\n                            line = client.readStringUntil('\\r');\n                            client.readStringUntil('\\n');\n                            if (line.startsWith(\"--\" + boundary))\n                                break;\n                            if (argValue.length() &gt; 0)\n                                argValue += \"\\n\";\n                            argValue += line;\n                        }\n                        log_v(\"PostArg Value: %s\", argValue.c_str());\n\n                        RequestArgument &amp;arg = _postArgs[_postArgsLen++];\n                        arg.key              = argName;\n                        arg.value            = argValue;\n\n                        if (line == (\"--\" + boundary + \"--\")) {\n                            log_v(\"Done Parsing POST\");\n                            break;\n                        } else if (_postArgsLen &gt;= WEBSERVER_MAX_POST_ARGS) {\n                            log_e(\"Too many PostArgs (max: %d) in request.\", WEBSERVER_MAX_POST_ARGS);\n                            return false;\n                        }\n                    } else {\n                        _currentUpload.reset(new HTTPUpload());\n                        _currentUpload-&gt;status      = UPLOAD_FILE_START;\n                        _currentUpload-&gt;name        = argName;\n                        _currentUpload-&gt;filename    = argFilename;\n                        _currentUpload-&gt;type        = argType;\n                        _currentUpload-&gt;totalSize   = 0;\n                        _currentUpload-&gt;currentSize = 0;\n                        log_v(\n                            \"Start File: %s Type: %s\",\n                            _currentUpload-&gt;filename.c_str(),\n                            _currentUpload-&gt;type.c_str()\n                        );\n                        if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n                            _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n                        _currentUpload-&gt;status = UPLOAD_FILE_WRITE;\n                        int argByte            = _uploadReadByte(client);\n                    readfile:\n\n                        while (argByte != 0x0D) {\n                            if (argByte &lt; 0)\n                                return _parseFormUploadAborted();\n                            _uploadWriteByte(argByte);\n                            argByte = _uploadReadByte(client);\n                        }\n\n                        argByte = _uploadReadByte(client);\n                        if (argByte &lt; 0)\n                            return _parseFormUploadAborted();\n                        if (argByte == 0x0A) {\n                            argByte = _uploadReadByte(client);\n                            if (argByte &lt; 0)\n                                return _parseFormUploadAborted();\n                            if ((char)argByte != '-') {\n                                // continue reading the file\n                                _uploadWriteByte(0x0D);\n                                _uploadWriteByte(0x0A);\n                                goto readfile;\n                            } else {\n                                argByte = _uploadReadByte(client);\n                                if (argByte &lt; 0)\n                                    return _parseFormUploadAborted();\n                                if ((char)argByte != '-') {\n                                    // continue reading the file\n                                    _uploadWriteByte(0x0D);\n                                    _uploadWriteByte(0x0A);\n                                    _uploadWriteByte((uint8_t)('-'));\n                                    goto readfile;\n                                }\n                            }\n\n                            uint8_t endBuf[boundary.length()];\n                            uint32_t i = 0;\n                            while (i &lt; boundary.length()) {\n                                argByte = _uploadReadByte(client);\n                                if (argByte &lt; 0)\n                                    return _parseFormUploadAborted();\n                                if ((char)argByte == 0x0D) {\n                                    _uploadWriteByte(0x0D);\n                                    _uploadWriteByte(0x0A);\n                                    _uploadWriteByte((uint8_t)('-'));\n                                    _uploadWriteByte((uint8_t)('-'));\n                                    uint32_t j = 0;\n                                    while (j &lt; i) {\n                                        _uploadWriteByte(endBuf[j++]);\n                                    }\n                                    goto readfile;\n                                }\n                                endBuf[i++] = (uint8_t)argByte;\n                            }\n\n                            if (strstr((const char *)endBuf, boundary.c_str()) != NULL) {\n                                if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n                                    _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n                                _currentUpload-&gt;totalSize += _currentUpload-&gt;currentSize;\n                                _currentUpload-&gt;status = UPLOAD_FILE_END;\n                                if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n                                    _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n                                log_v(\n                                    \"End File: %s Type: %s Size: %d\",\n                                    _currentUpload-&gt;filename.c_str(),\n                                    _currentUpload-&gt;type.c_str(),\n                                    _currentUpload-&gt;totalSize\n                                );\n                                line = client.readStringUntil(0x0D);\n                                client.readStringUntil(0x0A);\n                                if (line == \"--\") {\n                                    log_v(\"Done Parsing POST\");\n                                    break;\n                                }\n                                continue;\n                            } else {\n                                _uploadWriteByte(0x0D);\n                                _uploadWriteByte(0x0A);\n                                _uploadWriteByte((uint8_t)('-'));\n                                _uploadWriteByte((uint8_t)('-'));\n                                uint32_t i = 0;\n                                while (i &lt; boundary.length()) {\n                                    _uploadWriteByte(endBuf[i++]);\n                                }\n                                argByte = _uploadReadByte(client);\n                                goto readfile;\n                            }\n                        } else {\n                            _uploadWriteByte(0x0D);\n                            goto readfile;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        int iarg;\n        int totalArgs = ((WEBSERVER_MAX_POST_ARGS - _postArgsLen) &lt; _currentArgCount)\n                            ? (WEBSERVER_MAX_POST_ARGS - _postArgsLen)\n                            : _currentArgCount;\n        for (iarg = 0; iarg &lt; totalArgs; iarg++) {\n            RequestArgument &amp;arg = _postArgs[_postArgsLen++];\n            arg.key              = _currentArgs[iarg].key;\n            arg.value            = _currentArgs[iarg].value;\n        }\n        if (_currentArgs)\n            delete[] _currentArgs;\n        _currentArgs = new RequestArgument[_postArgsLen];\n        for (iarg = 0; iarg &lt; _postArgsLen; iarg++) {\n            RequestArgument &amp;arg = _currentArgs[iarg];\n            arg.key              = _postArgs[iarg].key;\n            arg.value            = _postArgs[iarg].value;\n        }\n        _currentArgCount = iarg;\n        if (_postArgs) {\n            delete[] _postArgs;\n            _postArgs    = nullptr;\n            _postArgsLen = 0;\n        }\n        return true;\n    }\n    log_e(\"Error: line: %s\", line.c_str());\n    return false;\n}\n\nString WebServer::urlDecode(const String &amp;text) {\n    String decoded   = \"\";\n    char temp[]      = \"0x00\";\n    unsigned int len = text.length();\n    unsigned int i   = 0;\n    while (i &lt; len) {\n        char decodedChar;\n        char encodedChar = text.charAt(i++);\n        if ((encodedChar == '%') &amp;&amp; (i + 1 &lt; len)) {\n            temp[2] = text.charAt(i++);\n            temp[3] = text.charAt(i++);\n\n            decodedChar = strtol(temp, NULL, 16);\n        } else {\n            if (encodedChar == '+') {\n                decodedChar = ' ';\n            } else {\n                decodedChar = encodedChar; // normal ascii char\n            }\n        }\n        decoded += decodedChar;\n    }\n    return decoded;\n}\n\nbool WebServer::_parseFormUploadAborted() {\n    _currentUpload-&gt;status = UPLOAD_FILE_ABORTED;\n    if (_currentHandler &amp;&amp; _currentHandler-&gt;canUpload(_currentUri))\n        _currentHandler-&gt;upload(*this, _currentUri, *_currentUpload);\n    return false;\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_uri_8h/","title":"File Uri.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; Uri.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_uri_8h/#classes","title":"Classes","text":"Type Name     class Uri      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/Uri.h</code></p>"},{"location":"ltapi/_uri_8h_source/","title":"File Uri.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; Uri.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;vector&gt;\n\nclass Uri {\n\n  protected:\n    const String _uri;\n\n  public:\n    Uri(const char *uri) : _uri(uri) {}\n\n    Uri(const String &amp;uri) : _uri(uri) {}\n\n    Uri(const __FlashStringHelper *uri) : _uri(String(uri)) {}\n\n    virtual ~Uri() {}\n\n    virtual Uri *clone() const {\n        return new Uri(_uri);\n    };\n\n    virtual void initPathArgs(__attribute__((unused)) std::vector&lt;String&gt; &amp;pathArgs) {}\n\n    virtual bool canHandle(const String &amp;requestUri, __attribute__((unused)) std::vector&lt;String&gt; &amp;pathArgs) {\n        return _uri == requestUri;\n    }\n};\n</code></pre>"},{"location":"ltapi/_web_server_8cpp/","title":"File WebServer.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; WebServer.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/WebServer.cpp</code></p>"},{"location":"ltapi/_web_server_8cpp_source/","title":"File WebServer.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; WebServer.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  WebServer.cpp - Dead simple web-server.\n  Supports only one simultaneous client, knows how to handle GET and POST.\n\n  Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#if LT_ARD_HAS_WIFI\n\n#include &lt;Arduino.h&gt;\n\n#include \"FS.h\"\n#include \"WebServer.h\"\n#include \"WiFiClient.h\"\n#include \"WiFiServer.h\"\n#include \"detail/RequestHandlersImpl.h\"\n// #include \"mbedtls/md5.h\"\n#include &lt;libb64/cencode.h&gt;\n\nstatic const char AUTHORIZATION_HEADER[]    = \"Authorization\";\nstatic const char qop_auth[] PROGMEM        = \"qop=auth\";\nstatic const char qop_auth_quoted[] PROGMEM = \"qop=\\\"auth\\\"\";\nstatic const char WWW_Authenticate[]        = \"WWW-Authenticate\";\nstatic const char Content_Length[]          = \"Content-Length\";\n\nWebServer::WebServer(IPAddress addr, int port)\n    : _corsEnabled(false), _server(addr, port), _currentMethod(HTTP_ANY), _currentVersion(0), _currentStatus(HC_NONE),\n      _statusChange(0), _nullDelay(true), _currentHandler(nullptr), _firstHandler(nullptr), _lastHandler(nullptr),\n      _currentArgCount(0), _currentArgs(nullptr), _postArgsLen(0), _postArgs(nullptr), _headerKeysCount(0),\n      _currentHeaders(nullptr), _contentLength(0), _chunked(false) {\n    log_v(\"WebServer::Webserver(addr=%s, port=%d)\", ipToString(addr).c_str(), port);\n}\n\nWebServer::WebServer(int port)\n    : _corsEnabled(false), _server(port), _currentMethod(HTTP_ANY), _currentVersion(0), _currentStatus(HC_NONE),\n      _statusChange(0), _nullDelay(true), _currentHandler(nullptr), _firstHandler(nullptr), _lastHandler(nullptr),\n      _currentArgCount(0), _currentArgs(nullptr), _postArgsLen(0), _postArgs(nullptr), _headerKeysCount(0),\n      _currentHeaders(nullptr), _contentLength(0), _chunked(false) {\n    log_v(\"WebServer::Webserver(port=%d)\", port);\n}\n\nWebServer::~WebServer() {\n    _server.close();\n    if (_currentHeaders)\n        delete[] _currentHeaders;\n    RequestHandler *handler = _firstHandler;\n    while (handler) {\n        RequestHandler *next = handler-&gt;next();\n        delete handler;\n        handler = next;\n    }\n}\n\nvoid WebServer::begin() {\n    close();\n    _server.begin();\n    _server.setNoDelay(true);\n}\n\nvoid WebServer::begin(uint16_t port) {\n    close();\n    _server.begin(port);\n    _server.setNoDelay(true);\n}\n\nString WebServer::_extractParam(String &amp;authReq, const String &amp;param, const char delimit) {\n    int _begin = authReq.indexOf(param);\n    if (_begin == -1)\n        return \"\";\n    return authReq.substring(_begin + param.length(), authReq.indexOf(delimit, _begin + param.length()));\n}\n\nstatic String md5str(String &amp;in) {\n    /* char out[33] = {0};\n    mbedtls_md5_context _ctx;\n    uint8_t i;\n    uint8_t *_buf = (uint8_t *)malloc(16);\n    if (_buf == NULL)\n        return String(out);\n    memset(_buf, 0x00, 16);\n    mbedtls_md5_init(&amp;_ctx);\n    mbedtls_md5_starts_ret(&amp;_ctx);\n    mbedtls_md5_update_ret(&amp;_ctx, (const uint8_t *)in.c_str(), in.length());\n    mbedtls_md5_finish_ret(&amp;_ctx, _buf);\n    for (i = 0; i &lt; 16; i++) {\n        sprintf(out + (i * 2), \"%02x\", _buf[i]);\n    }\n    out[32] = 0;\n    free(_buf);\n    return String(out); */\n    return \"\";\n}\n\nbool WebServer::authenticate(const char *username, const char *password) {\n    if (hasHeader(FPSTR(AUTHORIZATION_HEADER))) {\n        String authReq = header(FPSTR(AUTHORIZATION_HEADER));\n        if (authReq.startsWith(F(\"Basic\"))) {\n            authReq = authReq.substring(6);\n            authReq.trim();\n            char toencodeLen = strlen(username) + strlen(password) + 1;\n            char *toencode   = new char[toencodeLen + 1];\n            if (toencode == NULL) {\n                authReq = \"\";\n                return false;\n            }\n            char *encoded = new char[base64_encode_expected_len(toencodeLen) + 1];\n            if (encoded == NULL) {\n                authReq = \"\";\n                delete[] toencode;\n                return false;\n            }\n            sprintf(toencode, \"%s:%s\", username, password);\n            if (base64_encode_chars(toencode, toencodeLen, encoded) &gt; 0 &amp;&amp; authReq.equals(encoded)) {\n                authReq = \"\";\n                delete[] toencode;\n                delete[] encoded;\n                return true;\n            }\n            delete[] toencode;\n            delete[] encoded;\n        } else if (authReq.startsWith(F(\"Digest\"))) {\n            authReq = authReq.substring(7);\n            log_v(\"%s\", authReq.c_str());\n            String _username = _extractParam(authReq, F(\"username=\\\"\"), '\\\"');\n            if (!_username.length() || _username != String(username)) {\n                authReq = \"\";\n                return false;\n            }\n            // extracting required parameters for RFC 2069 simpler Digest\n            String _realm    = _extractParam(authReq, F(\"realm=\\\"\"), '\\\"');\n            String _nonce    = _extractParam(authReq, F(\"nonce=\\\"\"), '\\\"');\n            String _uri      = _extractParam(authReq, F(\"uri=\\\"\"), '\\\"');\n            String _response = _extractParam(authReq, F(\"response=\\\"\"), '\\\"');\n            String _opaque   = _extractParam(authReq, F(\"opaque=\\\"\"), '\\\"');\n\n            if ((!_realm.length()) || (!_nonce.length()) || (!_uri.length()) || (!_response.length()) ||\n                (!_opaque.length())) {\n                authReq = \"\";\n                return false;\n            }\n            if ((_opaque != _sopaque) || (_nonce != _snonce) || (_realm != _srealm)) {\n                authReq = \"\";\n                return false;\n            }\n            // parameters for the RFC 2617 newer Digest\n            String _nc, _cnonce;\n            if (authReq.indexOf(FPSTR(qop_auth)) != -1 || authReq.indexOf(FPSTR(qop_auth_quoted)) != -1) {\n                _nc     = _extractParam(authReq, F(\"nc=\"), ',');\n                _cnonce = _extractParam(authReq, F(\"cnonce=\\\"\"), '\\\"');\n            }\n            String _H1 = md5str(String(username) + ':' + _realm + ':' + String(password));\n            log_v(\"Hash of user:realm:pass=%s\", _H1.c_str());\n            String _H2 = \"\";\n            if (_currentMethod == HTTP_GET) {\n                _H2 = md5str(String(F(\"GET:\")) + _uri);\n            } else if (_currentMethod == HTTP_POST) {\n                _H2 = md5str(String(F(\"POST:\")) + _uri);\n            } else if (_currentMethod == HTTP_PUT) {\n                _H2 = md5str(String(F(\"PUT:\")) + _uri);\n            } else if (_currentMethod == HTTP_DELETE) {\n                _H2 = md5str(String(F(\"DELETE:\")) + _uri);\n            } else {\n                _H2 = md5str(String(F(\"GET:\")) + _uri);\n            }\n            log_v(\"Hash of GET:uri=%s\", _H2.c_str());\n            String _responsecheck = \"\";\n            if (authReq.indexOf(FPSTR(qop_auth)) != -1 || authReq.indexOf(FPSTR(qop_auth_quoted)) != -1) {\n                _responsecheck = md5str(_H1 + ':' + _nonce + ':' + _nc + ':' + _cnonce + F(\":auth:\") + _H2);\n            } else {\n                _responsecheck = md5str(_H1 + ':' + _nonce + ':' + _H2);\n            }\n            log_v(\"The Proper response=%s\", _responsecheck.c_str());\n            if (_response == _responsecheck) {\n                authReq = \"\";\n                return true;\n            }\n        }\n        authReq = \"\";\n    }\n    return false;\n}\n\nString WebServer::_getRandomHexString() {\n    char buffer[33]; // buffer to hold 32 Hex Digit + /0\n    int i;\n    for (i = 0; i &lt; 4; i++) {\n        sprintf(buffer + (i * 8), \"%08x\", rand());\n    }\n    return String(buffer);\n}\n\nvoid WebServer::requestAuthentication(HTTPAuthMethod mode, const char *realm, const String &amp;authFailMsg) {\n    if (realm == NULL) {\n        _srealm = String(F(\"Login Required\"));\n    } else {\n        _srealm = String(realm);\n    }\n    if (mode == BASIC_AUTH) {\n        sendHeader(String(FPSTR(WWW_Authenticate)), String(F(\"Basic realm=\\\"\")) + _srealm + String(F(\"\\\"\")));\n    } else {\n        _snonce  = _getRandomHexString();\n        _sopaque = _getRandomHexString();\n        sendHeader(\n            String(FPSTR(WWW_Authenticate)),\n            String(F(\"Digest realm=\\\"\")) + _srealm + String(F(\"\\\", qop=\\\"auth\\\", nonce=\\\"\")) + _snonce +\n                String(F(\"\\\", opaque=\\\"\")) + _sopaque + String(F(\"\\\"\"))\n        );\n    }\n    using namespace mime;\n    send(401, String(FPSTR(mimeTable[html].mimeType)), authFailMsg);\n}\n\nvoid WebServer::on(const Uri &amp;uri, WebServer::THandlerFunction handler) {\n    on(uri, HTTP_ANY, handler);\n}\n\nvoid WebServer::on(const Uri &amp;uri, HTTPMethod method, WebServer::THandlerFunction fn) {\n    on(uri, method, fn, _fileUploadHandler);\n}\n\nvoid WebServer::on(const Uri &amp;uri, HTTPMethod method, WebServer::THandlerFunction fn, WebServer::THandlerFunction ufn) {\n    _addRequestHandler(new FunctionRequestHandler(fn, ufn, uri, method));\n}\n\nvoid WebServer::addHandler(RequestHandler *handler) {\n    _addRequestHandler(handler);\n}\n\nvoid WebServer::_addRequestHandler(RequestHandler *handler) {\n    if (!_lastHandler) {\n        _firstHandler = handler;\n        _lastHandler  = handler;\n    } else {\n        _lastHandler-&gt;next(handler);\n        _lastHandler = handler;\n    }\n}\n\nvoid WebServer::serveStatic(const char *uri, FS &amp;fs, const char *path, const char *cache_header) {\n    _addRequestHandler(new StaticRequestHandler(fs, path, uri, cache_header));\n}\n\nvoid WebServer::handleClient() {\n    if (_currentStatus == HC_NONE) {\n        WiFiClient client = _server.available();\n        if (!client) {\n            if (_nullDelay) {\n                delay(1);\n            }\n            return;\n        }\n\n        log_v(\"New client: client.localIP()=%s\", ipToString(client.localIP()).c_str());\n\n        _currentClient = client;\n        _currentStatus = HC_WAIT_READ;\n        _statusChange  = millis();\n    }\n\n    bool keepCurrentClient = false;\n    bool callYield         = false;\n\n    if (_currentClient.connected()) {\n        switch (_currentStatus) {\n            case HC_NONE:\n                // No-op to avoid C++ compiler warning\n                break;\n            case HC_WAIT_READ:\n                // Wait for data from client to become available\n                if (_currentClient.available()) {\n                    if (_parseRequest(_currentClient)) {\n                        // because HTTP_MAX_SEND_WAIT is expressed in milliseconds,\n                        // it must be divided by 1000\n                        _currentClient.setTimeout(HTTP_MAX_SEND_WAIT / 1000);\n                        _contentLength = CONTENT_LENGTH_NOT_SET;\n                        _handleRequest();\n\n                        // Fix for issue with Chrome based browsers:\n                        // https://github.com/espressif/arduino-esp32/issues/3652\n                        //           if (_currentClient.connected()) {\n                        //             _currentStatus = HC_WAIT_CLOSE;\n                        //             _statusChange = millis();\n                        //             keepCurrentClient = true;\n                        //           }\n                    }\n                } else { // !_currentClient.available()\n                    if (millis() - _statusChange &lt;= HTTP_MAX_DATA_WAIT) {\n                        keepCurrentClient = true;\n                    }\n                    callYield = true;\n                }\n                break;\n            case HC_WAIT_CLOSE:\n                // Wait for client to close the connection\n                if (millis() - _statusChange &lt;= HTTP_MAX_CLOSE_WAIT) {\n                    keepCurrentClient = true;\n                    callYield         = true;\n                }\n        }\n    }\n\n    if (!keepCurrentClient) {\n        _currentClient = WiFiClient();\n        _currentStatus = HC_NONE;\n        _currentUpload.reset();\n    }\n\n    if (callYield) {\n        yield();\n    }\n}\n\nvoid WebServer::close() {\n    _server.close();\n    _currentStatus = HC_NONE;\n    if (!_headerKeysCount)\n        collectHeaders(0, 0);\n}\n\nvoid WebServer::stop() {\n    close();\n}\n\nvoid WebServer::sendHeader(const String &amp;name, const String &amp;value, bool first) {\n    String headerLine = name;\n    headerLine += F(\": \");\n    headerLine += value;\n    headerLine += \"\\r\\n\";\n\n    if (first) {\n        _responseHeaders = headerLine + _responseHeaders;\n    } else {\n        _responseHeaders += headerLine;\n    }\n}\n\nvoid WebServer::setContentLength(const size_t contentLength) {\n    _contentLength = contentLength;\n}\n\nvoid WebServer::enableDelay(boolean value) {\n    _nullDelay = value;\n}\n\nvoid WebServer::enableCORS(boolean value) {\n    _corsEnabled = value;\n}\n\nvoid WebServer::enableCrossOrigin(boolean value) {\n    enableCORS(value);\n}\n\nvoid WebServer::_prepareHeader(String &amp;response, int code, const char *content_type, size_t contentLength) {\n    response = String(F(\"HTTP/1.\")) + String(_currentVersion) + ' ';\n    response += String(code);\n    response += ' ';\n    response += _responseCodeToString(code);\n    response += \"\\r\\n\";\n\n    using namespace mime;\n    if (!content_type)\n        content_type = mimeTable[html].mimeType;\n\n    sendHeader(String(F(\"Content-Type\")), String(FPSTR(content_type)), true);\n    if (_contentLength == CONTENT_LENGTH_NOT_SET) {\n        sendHeader(String(FPSTR(Content_Length)), String(contentLength));\n    } else if (_contentLength != CONTENT_LENGTH_UNKNOWN) {\n        sendHeader(String(FPSTR(Content_Length)), String(_contentLength));\n    } else if (_contentLength == CONTENT_LENGTH_UNKNOWN &amp;&amp; _currentVersion) { // HTTP/1.1 or above client\n        // let's do chunked\n        _chunked = true;\n        sendHeader(String(F(\"Accept-Ranges\")), String(F(\"none\")));\n        sendHeader(String(F(\"Transfer-Encoding\")), String(F(\"chunked\")));\n    }\n    if (_corsEnabled) {\n        sendHeader(String(FPSTR(\"Access-Control-Allow-Origin\")), String(\"*\"));\n        sendHeader(String(FPSTR(\"Access-Control-Allow-Methods\")), String(\"*\"));\n        sendHeader(String(FPSTR(\"Access-Control-Allow-Headers\")), String(\"*\"));\n    }\n    sendHeader(String(F(\"Connection\")), String(F(\"close\")));\n\n    response += _responseHeaders;\n    response += \"\\r\\n\";\n    _responseHeaders = \"\";\n}\n\nvoid WebServer::send(int code, const char *content_type, const String &amp;content) {\n    String header;\n    // Can we asume the following?\n    // if(code == 200 &amp;&amp; content.length() == 0 &amp;&amp; _contentLength == CONTENT_LENGTH_NOT_SET)\n    //  _contentLength = CONTENT_LENGTH_UNKNOWN;\n    _prepareHeader(header, code, content_type, content.length());\n    _currentClientWrite(header.c_str(), header.length());\n    if (content.length())\n        sendContent(content);\n}\n\nvoid WebServer::send_P(int code, PGM_P content_type, PGM_P content) {\n    size_t contentLength = 0;\n\n    if (content != NULL) {\n        contentLength = strlen_P(content);\n    }\n\n    String header;\n    char type[64];\n    strncpy_P(type, (PGM_P)content_type, sizeof(type));\n    _prepareHeader(header, code, (const char *)type, contentLength);\n    _currentClientWrite(header.c_str(), header.length());\n    sendContent_P(content);\n}\n\nvoid WebServer::send_P(int code, PGM_P content_type, PGM_P content, size_t contentLength) {\n    String header;\n    char type[64];\n    strncpy_P(type, (PGM_P)content_type, sizeof(type));\n    _prepareHeader(header, code, (const char *)type, contentLength);\n    sendContent(header);\n    sendContent_P(content, contentLength);\n}\n\nvoid WebServer::send(int code, char *content_type, const String &amp;content) {\n    send(code, (const char *)content_type, content);\n}\n\nvoid WebServer::send(int code, const String &amp;content_type, const String &amp;content) {\n    send(code, (const char *)content_type.c_str(), content);\n}\n\nvoid WebServer::sendContent(const String &amp;content) {\n    sendContent(content.c_str(), content.length());\n}\n\nvoid WebServer::sendContent(const char *content, size_t contentLength) {\n    const char *footer = \"\\r\\n\";\n    if (_chunked) {\n        char *chunkSize = (char *)malloc(11);\n        if (chunkSize) {\n            sprintf(chunkSize, \"%x%s\", contentLength, footer);\n            _currentClientWrite(chunkSize, strlen(chunkSize));\n            free(chunkSize);\n        }\n    }\n    _currentClientWrite(content, contentLength);\n    if (_chunked) {\n        _currentClient.write(footer, 2);\n        if (contentLength == 0) {\n            _chunked = false;\n        }\n    }\n}\n\nvoid WebServer::sendContent_P(PGM_P content) {\n    sendContent_P(content, strlen_P(content));\n}\n\nvoid WebServer::sendContent_P(PGM_P content, size_t size) {\n    const char *footer = \"\\r\\n\";\n    if (_chunked) {\n        char *chunkSize = (char *)malloc(11);\n        if (chunkSize) {\n            sprintf(chunkSize, \"%x%s\", size, footer);\n            _currentClientWrite(chunkSize, strlen(chunkSize));\n            free(chunkSize);\n        }\n    }\n    _currentClientWrite_P(content, size);\n    if (_chunked) {\n        _currentClient.write(footer, 2);\n        if (size == 0) {\n            _chunked = false;\n        }\n    }\n}\n\nvoid WebServer::_streamFileCore(const size_t fileSize, const String &amp;fileName, const String &amp;contentType) {\n    using namespace mime;\n    setContentLength(fileSize);\n    if (fileName.endsWith(String(FPSTR(mimeTable[gz].endsWith))) &amp;&amp;\n        contentType != String(FPSTR(mimeTable[gz].mimeType)) &amp;&amp;\n        contentType != String(FPSTR(mimeTable[none].mimeType))) {\n        sendHeader(F(\"Content-Encoding\"), F(\"gzip\"));\n    }\n    send(200, contentType, \"\");\n}\n\nString WebServer::pathArg(unsigned int i) {\n    if (_currentHandler != nullptr)\n        return _currentHandler-&gt;pathArg(i);\n    return \"\";\n}\n\nString WebServer::arg(String name) {\n    for (int j = 0; j &lt; _postArgsLen; ++j) {\n        if (_postArgs[j].key == name)\n            return _postArgs[j].value;\n    }\n    for (int i = 0; i &lt; _currentArgCount; ++i) {\n        if (_currentArgs[i].key == name)\n            return _currentArgs[i].value;\n    }\n    return \"\";\n}\n\nString WebServer::arg(int i) {\n    if (i &lt; _currentArgCount)\n        return _currentArgs[i].value;\n    return \"\";\n}\n\nString WebServer::argName(int i) {\n    if (i &lt; _currentArgCount)\n        return _currentArgs[i].key;\n    return \"\";\n}\n\nint WebServer::args() {\n    return _currentArgCount;\n}\n\nbool WebServer::hasArg(String name) {\n    for (int j = 0; j &lt; _postArgsLen; ++j) {\n        if (_postArgs[j].key == name)\n            return true;\n    }\n    for (int i = 0; i &lt; _currentArgCount; ++i) {\n        if (_currentArgs[i].key == name)\n            return true;\n    }\n    return false;\n}\n\nString WebServer::header(String name) {\n    for (int i = 0; i &lt; _headerKeysCount; ++i) {\n        if (_currentHeaders[i].key.equalsIgnoreCase(name))\n            return _currentHeaders[i].value;\n    }\n    return \"\";\n}\n\nvoid WebServer::collectHeaders(const char *headerKeys[], const size_t headerKeysCount) {\n    _headerKeysCount = headerKeysCount + 1;\n    if (_currentHeaders)\n        delete[] _currentHeaders;\n    _currentHeaders        = new RequestArgument[_headerKeysCount];\n    _currentHeaders[0].key = FPSTR(AUTHORIZATION_HEADER);\n    for (int i = 1; i &lt; _headerKeysCount; i++) {\n        _currentHeaders[i].key = headerKeys[i - 1];\n    }\n}\n\nString WebServer::header(int i) {\n    if (i &lt; _headerKeysCount)\n        return _currentHeaders[i].value;\n    return \"\";\n}\n\nString WebServer::headerName(int i) {\n    if (i &lt; _headerKeysCount)\n        return _currentHeaders[i].key;\n    return \"\";\n}\n\nint WebServer::headers() {\n    return _headerKeysCount;\n}\n\nbool WebServer::hasHeader(String name) {\n    for (int i = 0; i &lt; _headerKeysCount; ++i) {\n        if ((_currentHeaders[i].key.equalsIgnoreCase(name)) &amp;&amp; (_currentHeaders[i].value.length() &gt; 0))\n            return true;\n    }\n    return false;\n}\n\nString WebServer::hostHeader() {\n    return _hostHeader;\n}\n\nvoid WebServer::onFileUpload(THandlerFunction fn) {\n    _fileUploadHandler = fn;\n}\n\nvoid WebServer::onNotFound(THandlerFunction fn) {\n    _notFoundHandler = fn;\n}\n\nvoid WebServer::_handleRequest() {\n    bool handled = false;\n    if (!_currentHandler) {\n        log_e(\"request handler not found\");\n    } else {\n        handled = _currentHandler-&gt;handle(*this, _currentMethod, _currentUri);\n        if (!handled) {\n            log_e(\"request handler failed to handle request\");\n        }\n    }\n    if (!handled &amp;&amp; _notFoundHandler) {\n        _notFoundHandler();\n        handled = true;\n    }\n    if (!handled) {\n        using namespace mime;\n        send(404, String(FPSTR(mimeTable[html].mimeType)), String(F(\"Not found: \")) + _currentUri);\n        handled = true;\n    }\n    if (handled) {\n        _finalizeResponse();\n    }\n    _currentUri = \"\";\n}\n\nvoid WebServer::_finalizeResponse() {\n    if (_chunked) {\n        sendContent(\"\");\n    }\n}\n\nString WebServer::_responseCodeToString(int code) {\n    switch (code) {\n        case 100:\n            return F(\"Continue\");\n        case 101:\n            return F(\"Switching Protocols\");\n        case 200:\n            return F(\"OK\");\n        case 201:\n            return F(\"Created\");\n        case 202:\n            return F(\"Accepted\");\n        case 203:\n            return F(\"Non-Authoritative Information\");\n        case 204:\n            return F(\"No Content\");\n        case 205:\n            return F(\"Reset Content\");\n        case 206:\n            return F(\"Partial Content\");\n        case 300:\n            return F(\"Multiple Choices\");\n        case 301:\n            return F(\"Moved Permanently\");\n        case 302:\n            return F(\"Found\");\n        case 303:\n            return F(\"See Other\");\n        case 304:\n            return F(\"Not Modified\");\n        case 305:\n            return F(\"Use Proxy\");\n        case 307:\n            return F(\"Temporary Redirect\");\n        case 400:\n            return F(\"Bad Request\");\n        case 401:\n            return F(\"Unauthorized\");\n        case 402:\n            return F(\"Payment Required\");\n        case 403:\n            return F(\"Forbidden\");\n        case 404:\n            return F(\"Not Found\");\n        case 405:\n            return F(\"Method Not Allowed\");\n        case 406:\n            return F(\"Not Acceptable\");\n        case 407:\n            return F(\"Proxy Authentication Required\");\n        case 408:\n            return F(\"Request Time-out\");\n        case 409:\n            return F(\"Conflict\");\n        case 410:\n            return F(\"Gone\");\n        case 411:\n            return F(\"Length Required\");\n        case 412:\n            return F(\"Precondition Failed\");\n        case 413:\n            return F(\"Request Entity Too Large\");\n        case 414:\n            return F(\"Request-URI Too Large\");\n        case 415:\n            return F(\"Unsupported Media Type\");\n        case 416:\n            return F(\"Requested range not satisfiable\");\n        case 417:\n            return F(\"Expectation Failed\");\n        case 500:\n            return F(\"Internal Server Error\");\n        case 501:\n            return F(\"Not Implemented\");\n        case 502:\n            return F(\"Bad Gateway\");\n        case 503:\n            return F(\"Service Unavailable\");\n        case 504:\n            return F(\"Gateway Time-out\");\n        case 505:\n            return F(\"HTTP Version not supported\");\n        default:\n            return F(\"\");\n    }\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_web_server_8h/","title":"File WebServer.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; WebServer.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"HTTP_Method.h\"</code></li> <li><code>#include \"Uri.h\"</code></li> <li><code>#include &lt;WiFi.h&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include \"detail/RequestHandler.h\"</code></li> </ul>"},{"location":"ltapi/_web_server_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace fs"},{"location":"ltapi/_web_server_8h/#classes","title":"Classes","text":"Type Name     struct HTTPUpload    class WebServer"},{"location":"ltapi/_web_server_8h/#public-types","title":"Public Types","text":"Type Name     enum HTTPAuthMethod    enum HTTPClientStatus    enum HTTPUploadStatus"},{"location":"ltapi/_web_server_8h/#macros","title":"Macros","text":"Type Name     define CONTENT_LENGTH_NOT_SET  ((size_t)-2)   define CONTENT_LENGTH_UNKNOWN  ((size_t)-1)   define HTTP_DOWNLOAD_UNIT_SIZE  1436   define HTTP_MAX_CLOSE_WAIT  2000   define HTTP_MAX_DATA_WAIT  5000   define HTTP_MAX_POST_WAIT  5000   define HTTP_MAX_SEND_WAIT  5000   define HTTP_UPLOAD_BUFLEN  1436"},{"location":"ltapi/_web_server_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/_web_server_8h/#enum-httpauthmethod","title":"enum HTTPAuthMethod","text":"<pre><code>enum HTTPAuthMethod {\n    BASIC_AUTH,\n    DIGEST_AUTH\n};\n</code></pre>"},{"location":"ltapi/_web_server_8h/#enum-httpclientstatus","title":"enum HTTPClientStatus","text":"<pre><code>enum HTTPClientStatus {\n    HC_NONE,\n    HC_WAIT_READ,\n    HC_WAIT_CLOSE\n};\n</code></pre>"},{"location":"ltapi/_web_server_8h/#enum-httpuploadstatus","title":"enum HTTPUploadStatus","text":"<pre><code>enum HTTPUploadStatus {\n    UPLOAD_FILE_START,\n    UPLOAD_FILE_WRITE,\n    UPLOAD_FILE_END,\n    UPLOAD_FILE_ABORTED\n};\n</code></pre>"},{"location":"ltapi/_web_server_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/_web_server_8h/#define-content_length_not_set","title":"define CONTENT_LENGTH_NOT_SET","text":"<pre><code>#define CONTENT_LENGTH_NOT_SET ((size_t)-2)\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-content_length_unknown","title":"define CONTENT_LENGTH_UNKNOWN","text":"<pre><code>#define CONTENT_LENGTH_UNKNOWN ((size_t)-1)\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_download_unit_size","title":"define HTTP_DOWNLOAD_UNIT_SIZE","text":"<pre><code>#define HTTP_DOWNLOAD_UNIT_SIZE 1436\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_close_wait","title":"define HTTP_MAX_CLOSE_WAIT","text":"<pre><code>#define HTTP_MAX_CLOSE_WAIT 2000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_data_wait","title":"define HTTP_MAX_DATA_WAIT","text":"<pre><code>#define HTTP_MAX_DATA_WAIT 5000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_post_wait","title":"define HTTP_MAX_POST_WAIT","text":"<pre><code>#define HTTP_MAX_POST_WAIT 5000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_max_send_wait","title":"define HTTP_MAX_SEND_WAIT","text":"<pre><code>#define HTTP_MAX_SEND_WAIT 5000\n</code></pre>"},{"location":"ltapi/_web_server_8h/#define-http_upload_buflen","title":"define HTTP_UPLOAD_BUFLEN","text":"<pre><code>#define HTTP_UPLOAD_BUFLEN 1436\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/WebServer.h</code></p>"},{"location":"ltapi/_web_server_8h_source/","title":"File WebServer.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; WebServer.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n  WebServer.h - Dead simple web-server.\n  Supports only one simultaneous client, knows how to handle GET and POST.\n\n  Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n  Modified 8 May 2015 by Hristo Gochkov (proper post and file upload handling)\n*/\n\n#pragma once\n\n#include \"HTTP_Method.h\"\n#include \"Uri.h\"\n#include &lt;WiFi.h&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n\nenum HTTPUploadStatus { UPLOAD_FILE_START, UPLOAD_FILE_WRITE, UPLOAD_FILE_END, UPLOAD_FILE_ABORTED };\n\nenum HTTPClientStatus { HC_NONE, HC_WAIT_READ, HC_WAIT_CLOSE };\n\nenum HTTPAuthMethod { BASIC_AUTH, DIGEST_AUTH };\n\n#define HTTP_DOWNLOAD_UNIT_SIZE 1436\n\n#ifndef HTTP_UPLOAD_BUFLEN\n#define HTTP_UPLOAD_BUFLEN 1436\n#endif\n\n#define HTTP_MAX_DATA_WAIT  5000 // ms to wait for the client to send the request\n#define HTTP_MAX_POST_WAIT  5000 // ms to wait for POST data to arrive\n#define HTTP_MAX_SEND_WAIT  5000 // ms to wait for data chunk to be ACKed\n#define HTTP_MAX_CLOSE_WAIT 2000 // ms to wait for the client to close the connection\n\n#define CONTENT_LENGTH_UNKNOWN ((size_t)-1)\n#define CONTENT_LENGTH_NOT_SET ((size_t)-2)\n\nclass WebServer;\n\ntypedef struct {\n    HTTPUploadStatus status;\n    String filename;\n    String name;\n    String type;\n    size_t totalSize;   // file size\n    size_t currentSize; // size of data currently in buf\n    uint8_t buf[HTTP_UPLOAD_BUFLEN];\n} HTTPUpload;\n\n#include \"detail/RequestHandler.h\"\n\nnamespace fs {\nclass FS;\n}\n\nclass WebServer {\n  public:\n    WebServer(IPAddress addr, int port = 80);\n    WebServer(int port = 80);\n    virtual ~WebServer();\n\n    virtual void begin();\n    virtual void begin(uint16_t port);\n    virtual void handleClient();\n\n    virtual void close();\n    void stop();\n\n    bool authenticate(const char *username, const char *password);\n    void requestAuthentication(\n        HTTPAuthMethod mode = BASIC_AUTH, const char *realm = NULL, const String &amp;authFailMsg = String(\"\")\n    );\n\n    typedef std::function&lt;void(void)&gt; THandlerFunction;\n    void on(const Uri &amp;uri, THandlerFunction fn);\n    void on(const Uri &amp;uri, HTTPMethod method, THandlerFunction fn);\n    void on(const Uri &amp;uri, HTTPMethod method, THandlerFunction fn, THandlerFunction ufn); // ufn handles file uploads\n    void addHandler(RequestHandler *handler);\n    void serveStatic(const char *uri, fs::FS &amp;fs, const char *path, const char *cache_header = NULL);\n    void onNotFound(THandlerFunction fn);    // called when handler is not assigned\n    void onFileUpload(THandlerFunction ufn); // handle file uploads\n\n    String uri() {\n        return _currentUri;\n    }\n\n    HTTPMethod method() {\n        return _currentMethod;\n    }\n\n    virtual WiFiClient client() {\n        return _currentClient;\n    }\n\n    HTTPUpload &amp;upload() {\n        return *_currentUpload;\n    }\n\n    String pathArg(unsigned int i);                                              // get request path argument by number\n    String arg(String name);                                                     // get request argument value by name\n    String arg(int i);                                                           // get request argument value by number\n    String argName(int i);                                                       // get request argument name by number\n    int args();                                                                  // get arguments count\n    bool hasArg(String name);                                                    // check if argument exists\n    void collectHeaders(const char *headerKeys[], const size_t headerKeysCount); // set the request headers to collect\n    String header(String name);                                                  // get request header value by name\n    String header(int i);                                                        // get request header value by number\n    String headerName(int i);                                                    // get request header name by number\n    int headers();                                                               // get header count\n    bool hasHeader(String name);                                                 // check if header exists\n\n    String hostHeader(); // get request host header if available or empty String if not\n\n    // send response to the client\n    // code - HTTP response code, can be 200 or 404\n    // content_type - HTTP content type, like \"text/plain\" or \"image/png\"\n    // content - actual content body\n    void send(int code, const char *content_type = NULL, const String &amp;content = String(\"\"));\n    void send(int code, char *content_type, const String &amp;content);\n    void send(int code, const String &amp;content_type, const String &amp;content);\n    void send_P(int code, PGM_P content_type, PGM_P content);\n    void send_P(int code, PGM_P content_type, PGM_P content, size_t contentLength);\n\n    void enableDelay(boolean value);\n    void enableCORS(boolean value = true);\n    void enableCrossOrigin(boolean value = true);\n\n    void setContentLength(const size_t contentLength);\n    void sendHeader(const String &amp;name, const String &amp;value, bool first = false);\n    void sendContent(const String &amp;content);\n    void sendContent(const char *content, size_t contentLength);\n    void sendContent_P(PGM_P content);\n    void sendContent_P(PGM_P content, size_t size);\n\n    static String urlDecode(const String &amp;text);\n\n    template &lt;typename T&gt;\n    size_t streamFile(T &amp;file, const String &amp;contentType) {\n        _streamFileCore(file.size(), file.name(), contentType);\n        return _currentClient.write(file);\n    }\n\n  protected:\n    virtual size_t _currentClientWrite(const char *b, size_t l) {\n        return _currentClient.write(b, l);\n    }\n\n    virtual size_t _currentClientWrite_P(PGM_P b, size_t l) {\n        return _currentClient.write_P(b, l);\n    }\n\n    void _addRequestHandler(RequestHandler *handler);\n    void _handleRequest();\n    void _finalizeResponse();\n    bool _parseRequest(WiFiClient &amp;client);\n    void _parseArguments(String data);\n    static String _responseCodeToString(int code);\n    bool _parseForm(WiFiClient &amp;client, String boundary, uint32_t len);\n    bool _parseFormUploadAborted();\n    void _uploadWriteByte(uint8_t b);\n    int _uploadReadByte(WiFiClient &amp;client);\n    void _prepareHeader(String &amp;response, int code, const char *content_type, size_t contentLength);\n    bool _collectHeader(const char *headerName, const char *headerValue);\n\n    void _streamFileCore(const size_t fileSize, const String &amp;fileName, const String &amp;contentType);\n\n    String _getRandomHexString();\n    // for extracting Auth parameters\n    String _extractParam(String &amp;authReq, const String &amp;param, const char delimit = '\"');\n\n    struct RequestArgument {\n        String key;\n        String value;\n    };\n\n    boolean _corsEnabled;\n    WiFiServer _server;\n\n    WiFiClient _currentClient;\n    HTTPMethod _currentMethod;\n    String _currentUri;\n    uint8_t _currentVersion;\n    HTTPClientStatus _currentStatus;\n    unsigned long _statusChange;\n    boolean _nullDelay;\n\n    RequestHandler *_currentHandler;\n    RequestHandler *_firstHandler;\n    RequestHandler *_lastHandler;\n    THandlerFunction _notFoundHandler;\n    THandlerFunction _fileUploadHandler;\n\n    int _currentArgCount;\n    RequestArgument *_currentArgs;\n    int _postArgsLen;\n    RequestArgument *_postArgs;\n\n    std::unique_ptr&lt;HTTPUpload&gt; _currentUpload;\n\n    int _headerKeysCount;\n    RequestArgument *_currentHeaders;\n    size_t _contentLength;\n    String _responseHeaders;\n\n    String _hostHeader;\n    bool _chunked;\n\n    String _snonce; // Store noance and opaque for future comparison\n    String _sopaque;\n    String _srealm; // Store the Auth realm between Calls\n};\n</code></pre>"},{"location":"ltapi/dir_15fcaca5091edc9c4415c083e03808c9/","title":"Dir arduino/libretuya/libraries/WebServer/detail","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail</p>"},{"location":"ltapi/dir_15fcaca5091edc9c4415c083e03808c9/#files","title":"Files","text":"Type Name     file RequestHandler.h    file RequestHandlersImpl.h    file mimetable.cpp    file mimetable.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/</code></p>"},{"location":"ltapi/_request_handler_8h/","title":"File RequestHandler.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; RequestHandler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_request_handler_8h/#classes","title":"Classes","text":"Type Name     class RequestHandler      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/RequestHandler.h</code></p>"},{"location":"ltapi/_request_handler_8h_source/","title":"File RequestHandler.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; RequestHandler.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;assert.h&gt;\n#include &lt;vector&gt;\n\nclass RequestHandler {\n  public:\n    virtual ~RequestHandler() {}\n\n    virtual bool canHandle(HTTPMethod method, String uri) {\n        (void)method;\n        (void)uri;\n        return false;\n    }\n\n    virtual bool canUpload(String uri) {\n        (void)uri;\n        return false;\n    }\n\n    virtual bool handle(WebServer &amp;server, HTTPMethod requestMethod, String requestUri) {\n        (void)server;\n        (void)requestMethod;\n        (void)requestUri;\n        return false;\n    }\n\n    virtual void upload(WebServer &amp;server, String requestUri, HTTPUpload &amp;upload) {\n        (void)server;\n        (void)requestUri;\n        (void)upload;\n    }\n\n    RequestHandler *next() {\n        return _next;\n    }\n\n    void next(RequestHandler *r) {\n        _next = r;\n    }\n\n  private:\n    RequestHandler *_next = nullptr;\n\n  protected:\n    std::vector&lt;String&gt; pathArgs;\n\n  public:\n    const String &amp;pathArg(unsigned int i) {\n        assert(i &lt; pathArgs.size());\n        return pathArgs[i];\n    }\n};\n</code></pre>"},{"location":"ltapi/_request_handlers_impl_8h/","title":"File RequestHandlersImpl.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; RequestHandlersImpl.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"RequestHandler.h\"</code></li> <li><code>#include \"Uri.h\"</code></li> <li><code>#include \"WString.h\"</code></li> <li><code>#include \"mimetable.h\"</code></li> </ul>"},{"location":"ltapi/_request_handlers_impl_8h/#classes","title":"Classes","text":"Type Name     class FunctionRequestHandler    class StaticRequestHandler      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/RequestHandlersImpl.h</code></p>"},{"location":"ltapi/_request_handlers_impl_8h_source/","title":"File RequestHandlersImpl.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; RequestHandlersImpl.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"RequestHandler.h\"\n#include \"Uri.h\"\n#include \"WString.h\"\n#include \"mimetable.h\"\n\nusing namespace mime;\n\nclass FunctionRequestHandler : public RequestHandler {\n  public:\n    FunctionRequestHandler(\n        WebServer::THandlerFunction fn, WebServer::THandlerFunction ufn, const Uri &amp;uri, HTTPMethod method\n    )\n        : _fn(fn), _ufn(ufn), _uri(uri.clone()), _method(method) {\n        _uri-&gt;initPathArgs(pathArgs);\n    }\n\n    ~FunctionRequestHandler() {\n        delete _uri;\n    }\n\n    bool canHandle(HTTPMethod requestMethod, String requestUri) override {\n        if (_method != HTTP_ANY &amp;&amp; _method != requestMethod)\n            return false;\n\n        return _uri-&gt;canHandle(requestUri, pathArgs);\n    }\n\n    bool canUpload(String requestUri) override {\n        if (!_ufn || !canHandle(HTTP_POST, requestUri))\n            return false;\n\n        return true;\n    }\n\n    bool handle(WebServer &amp;server, HTTPMethod requestMethod, String requestUri) override {\n        (void)server;\n        if (!canHandle(requestMethod, requestUri))\n            return false;\n\n        _fn();\n        return true;\n    }\n\n    void upload(WebServer &amp;server, String requestUri, HTTPUpload &amp;upload) override {\n        (void)server;\n        (void)upload;\n        if (canUpload(requestUri))\n            _ufn();\n    }\n\n  protected:\n    WebServer::THandlerFunction _fn;\n    WebServer::THandlerFunction _ufn;\n    Uri *_uri;\n    HTTPMethod _method;\n};\n\nclass StaticRequestHandler : public RequestHandler {\n  public:\n    StaticRequestHandler(FS &amp;fs, const char *path, const char *uri, const char *cache_header)\n        : _fs(fs), _uri(uri), _path(path), _cache_header(cache_header) {\n        File f  = fs.open(path);\n        _isFile = (f &amp;&amp; (!f.isDirectory()));\n        log_v(\n            \"StaticRequestHandler: path=%s uri=%s isFile=%d, cache_header=%s\\r\\n\",\n            path,\n            uri,\n            _isFile,\n            cache_header ? cache_header : \"\"\n        ); // issue 5506 - cache_header can be nullptr\n        _baseUriLength = _uri.length();\n    }\n\n    bool canHandle(HTTPMethod requestMethod, String requestUri) override {\n        if (requestMethod != HTTP_GET)\n            return false;\n\n        if ((_isFile &amp;&amp; requestUri != _uri) || !requestUri.startsWith(_uri))\n            return false;\n\n        return true;\n    }\n\n    bool handle(WebServer &amp;server, HTTPMethod requestMethod, String requestUri) override {\n        if (!canHandle(requestMethod, requestUri))\n            return false;\n\n        log_v(\"StaticRequestHandler::handle: request=%s _uri=%s\\r\\n\", requestUri.c_str(), _uri.c_str());\n\n        String path(_path);\n\n        if (!_isFile) {\n            // Base URI doesn't point to a file.\n            // If a directory is requested, look for index file.\n            if (requestUri.endsWith(\"/\"))\n                requestUri += \"index.htm\";\n\n            // Append whatever follows this URI in request to get the file path.\n            path += requestUri.substring(_baseUriLength);\n        }\n        log_v(\"StaticRequestHandler::handle: path=%s, isFile=%d\\r\\n\", path.c_str(), _isFile);\n\n        String contentType = getContentType(path);\n\n        // look for gz file, only if the original specified path is not a gz.  So part only works to send gzip via\n        // content encoding when a non compressed is asked for if you point the the path to gzip you will serve the gzip\n        // as content type \"application/x-gzip\", not text or javascript etc...\n        if (!path.endsWith(FPSTR(mimeTable[gz].endsWith)) &amp;&amp; !_fs.exists(path)) {\n            String pathWithGz = path + FPSTR(mimeTable[gz].endsWith);\n            if (_fs.exists(pathWithGz))\n                path += FPSTR(mimeTable[gz].endsWith);\n        }\n\n        File f = _fs.open(path, \"r\");\n        if (!f || !f.available())\n            return false;\n\n        if (_cache_header.length() != 0)\n            server.sendHeader(\"Cache-Control\", _cache_header);\n\n        server.streamFile(f, contentType);\n        return true;\n    }\n\n    static String getContentType(const String &amp;path) {\n        char buff[sizeof(mimeTable[0].mimeType)];\n        // Check all entries but last one for match, return if found\n        for (size_t i = 0; i &lt; sizeof(mimeTable) / sizeof(mimeTable[0]) - 1; i++) {\n            strcpy_P(buff, mimeTable[i].endsWith);\n            if (path.endsWith(buff)) {\n                strcpy_P(buff, mimeTable[i].mimeType);\n                return String(buff);\n            }\n        }\n        // Fall-through and just return default type\n        strcpy_P(buff, mimeTable[sizeof(mimeTable) / sizeof(mimeTable[0]) - 1].mimeType);\n        return String(buff);\n    }\n\n  protected:\n    FS _fs;\n    String _uri;\n    String _path;\n    String _cache_header;\n    bool _isFile;\n    size_t _baseUriLength;\n};\n</code></pre>"},{"location":"ltapi/mimetable_8cpp/","title":"File mimetable.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; mimetable.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"mimetable.h\"</code></li> <li><code>#include \"pgmspace.h\"</code></li> </ul>"},{"location":"ltapi/mimetable_8cpp/#namespaces","title":"Namespaces","text":"Type Name     namespace mime      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/mimetable.cpp</code></p>"},{"location":"ltapi/mimetable_8cpp_source/","title":"File mimetable.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; mimetable.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"mimetable.h\"\n#include \"pgmspace.h\"\n\nnamespace mime {\n\n// Table of extension-&gt;MIME strings stored in PROGMEM, needs to be global due to GCC section typing rules\nconst Entry mimeTable[maxType] = {\n    {\".html\",     \"text/html\"                    },\n    {\".htm\",         \"text/html\"                    },\n    {\".css\",         \"text/css\"                    },\n    {\".txt\",         \"text/plain\"                    },\n    {\".js\",     \"application/javascript\"        },\n    {\".json\",     \"application/json\"                },\n    {\".png\",         \"image/png\"                    },\n    {\".gif\",         \"image/gif\"                    },\n    {\".jpg\",         \"image/jpeg\"                    },\n    {\".ico\",         \"image/x-icon\"                },\n    {\".svg\",         \"image/svg+xml\"                },\n    {\".ttf\",         \"application/x-font-ttf\"        },\n    {\".otf\",         \"application/x-font-opentype\"  },\n    {\".woff\",     \"application/font-woff\"        },\n    {\".woff2\",     \"application/font-woff2\"    },\n    {\".eot\",         \"application/vnd.ms-fontobject\"},\n    {\".sfnt\",     \"application/font-sfnt\"        },\n    {\".xml\",         \"text/xml\"                    },\n    {\".pdf\",         \"application/pdf\"            },\n    {\".zip\",         \"application/zip\"            },\n    {\".gz\",     \"application/x-gzip\"            },\n    {\".appcache\", \"text/cache-manifest\"        },\n    {\"\",          \"application/octet-stream\"       }\n};\n\n} // namespace mime\n</code></pre>"},{"location":"ltapi/mimetable_8h/","title":"File mimetable.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; mimetable.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/mimetable_8h/#namespaces","title":"Namespaces","text":"Type Name     namespace mime"},{"location":"ltapi/mimetable_8h/#classes","title":"Classes","text":"Type Name     struct Entry      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/detail/mimetable.h</code></p>"},{"location":"ltapi/mimetable_8h_source/","title":"File mimetable.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; detail &gt; mimetable.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\nnamespace mime {\n\nenum type {\n    html,\n    htm,\n    css,\n    txt,\n    js,\n    json,\n    png,\n    gif,\n    jpg,\n    ico,\n    svg,\n    ttf,\n    otf,\n    woff,\n    woff2,\n    eot,\n    sfnt,\n    xml,\n    pdf,\n    zip,\n    gz,\n    appcache,\n    none,\n    maxType\n};\n\nstruct Entry {\n    const char endsWith[16];\n    const char mimeType[32];\n};\n\nextern const Entry mimeTable[maxType];\n} // namespace mime\n</code></pre>"},{"location":"ltapi/dir_3097ab13d76509a58d1b9f5d3c3232cd/","title":"Dir arduino/libretuya/libraries/WebServer/uri","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri</p>"},{"location":"ltapi/dir_3097ab13d76509a58d1b9f5d3c3232cd/#files","title":"Files","text":"Type Name     file UriBraces.h    file UriGlob.h    file UriRegex.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/</code></p>"},{"location":"ltapi/_uri_braces_8h/","title":"File UriBraces.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri &gt; UriBraces.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Uri.h\"</code></li> </ul>"},{"location":"ltapi/_uri_braces_8h/#classes","title":"Classes","text":"Type Name     class UriBraces      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/UriBraces.h</code></p>"},{"location":"ltapi/_uri_braces_8h_source/","title":"File UriBraces.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri &gt; UriBraces.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Uri.h\"\n\nclass UriBraces : public Uri {\n\n  public:\n    explicit UriBraces(const char *uri) : Uri(uri){};\n    explicit UriBraces(const String &amp;uri) : Uri(uri){};\n\n    Uri *clone() const override final {\n        return new UriBraces(_uri);\n    };\n\n    void initPathArgs(std::vector&lt;String&gt; &amp;pathArgs) override final {\n        int numParams = 0, start = 0;\n        do {\n            start = _uri.indexOf(\"{}\", start);\n            if (start &gt; 0) {\n                numParams++;\n                start += 2;\n            }\n        } while (start &gt; 0);\n        pathArgs.resize(numParams);\n    }\n\n    bool canHandle(const String &amp;requestUri, std::vector&lt;String&gt; &amp;pathArgs) override final {\n        if (Uri::canHandle(requestUri, pathArgs))\n            return true;\n\n        size_t uriLength             = _uri.length();\n        unsigned int pathArgIndex    = 0;\n        unsigned int requestUriIndex = 0;\n        for (unsigned int i = 0; i &lt; uriLength; i++, requestUriIndex++) {\n            char uriChar        = _uri[i];\n            char requestUriChar = requestUri[requestUriIndex];\n\n            if (uriChar == requestUriChar)\n                continue;\n            if (uriChar != '{')\n                return false;\n\n            i += 2; // index of char after '}'\n            if (i &gt;= uriLength) {\n                // there is no char after '}'\n                pathArgs[pathArgIndex] = requestUri.substring(requestUriIndex);\n                return pathArgs[pathArgIndex].indexOf(\"/\") == -1; // path argument may not contain a '/'\n            } else {\n                char charEnd = _uri[i];\n                int uriIndex = requestUri.indexOf(charEnd, requestUriIndex);\n                if (uriIndex &lt; 0)\n                    return false;\n                pathArgs[pathArgIndex] = requestUri.substring(requestUriIndex, uriIndex);\n                requestUriIndex        = (unsigned int)uriIndex;\n            }\n            pathArgIndex++;\n        }\n\n        return requestUriIndex &gt;= requestUri.length();\n    }\n};\n</code></pre>"},{"location":"ltapi/_uri_glob_8h/","title":"File UriGlob.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri &gt; UriGlob.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Uri.h\"</code></li> <li><code>#include &lt;fnmatch.h&gt;</code></li> </ul>"},{"location":"ltapi/_uri_glob_8h/#classes","title":"Classes","text":"Type Name     class UriGlob      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/UriGlob.h</code></p>"},{"location":"ltapi/_uri_glob_8h_source/","title":"File UriGlob.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri &gt; UriGlob.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Uri.h\"\n#include &lt;fnmatch.h&gt;\n\nclass UriGlob : public Uri {\n\n  public:\n    explicit UriGlob(const char *uri) : Uri(uri){};\n    explicit UriGlob(const String &amp;uri) : Uri(uri){};\n\n    Uri *clone() const override final {\n        return new UriGlob(_uri);\n    };\n\n    bool canHandle(const String &amp;requestUri, __attribute__((unused)) std::vector&lt;String&gt; &amp;pathArgs) override final {\n        return fnmatch(_uri.c_str(), requestUri.c_str(), 0) == 0;\n    }\n};\n</code></pre>"},{"location":"ltapi/_uri_regex_8h/","title":"File UriRegex.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri &gt; UriRegex.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Uri.h\"</code></li> <li><code>#include &lt;regex&gt;</code></li> </ul>"},{"location":"ltapi/_uri_regex_8h/#classes","title":"Classes","text":"Type Name     class UriRegex      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WebServer/uri/UriRegex.h</code></p>"},{"location":"ltapi/_uri_regex_8h_source/","title":"File UriRegex.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WebServer &gt; uri &gt; UriRegex.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"Uri.h\"\n#include &lt;regex&gt;\n\nclass UriRegex : public Uri {\n\n  public:\n    explicit UriRegex(const char *uri) : Uri(uri){};\n    explicit UriRegex(const String &amp;uri) : Uri(uri){};\n\n    Uri *clone() const override final {\n        return new UriRegex(_uri);\n    };\n\n    void initPathArgs(std::vector&lt;String&gt; &amp;pathArgs) override final {\n        std::regex rgx((_uri + \"|\").c_str());\n        std::smatch matches;\n        std::string s{\"\"};\n        std::regex_search(s, matches, rgx);\n        pathArgs.resize(matches.size() - 1);\n    }\n\n    bool canHandle(const String &amp;requestUri, std::vector&lt;String&gt; &amp;pathArgs) override final {\n        if (Uri::canHandle(requestUri, pathArgs))\n            return true;\n\n        unsigned int pathArgIndex = 0;\n        std::regex rgx(_uri.c_str());\n        std::smatch matches;\n        std::string s(requestUri.c_str());\n        if (std::regex_search(s, matches, rgx)) {\n            for (size_t i = 1; i &lt; matches.size(); ++i) { // skip first\n                pathArgs[pathArgIndex] = String(matches[i].str().c_str());\n                pathArgIndex++;\n            }\n            return true;\n        }\n        return false;\n    }\n};\n</code></pre>"},{"location":"ltapi/dir_bdfd2f47249e3d27d6007e32415a49aa/","title":"Dir arduino/libretuya/libraries/WiFiMulti","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WiFiMulti</p>"},{"location":"ltapi/dir_bdfd2f47249e3d27d6007e32415a49aa/#files","title":"Files","text":"Type Name     file WiFiMulti.cpp    file WiFiMulti.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WiFiMulti/</code></p>"},{"location":"ltapi/_wi_fi_multi_8cpp/","title":"File WiFiMulti.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WiFiMulti &gt; WiFiMulti.cpp</p> <p>Go to the source code of this file.</p> <p>More...</p>"},{"location":"ltapi/_wi_fi_multi_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Date:</p> <p>16.05.2015 </p> <p>Author:</p> <p>Markus Sattler</p> <p>Copyright (c) 2015 Markus Sattler. All rights reserved. This file is part of the esp8266 core for Arduino environment.</p> <p>This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p> <p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p> <p>You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA </p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WiFiMulti/WiFiMulti.cpp</code></p>"},{"location":"ltapi/_wi_fi_multi_8cpp_source/","title":"File WiFiMulti.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WiFiMulti &gt; WiFiMulti.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#if LT_ARD_HAS_WIFI\n\n#include \"WiFiMulti.h\"\n#include &lt;Arduino.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;string.h&gt;\n\nWiFiMulti::WiFiMulti() {}\n\nWiFiMulti::~WiFiMulti() {\n    for (uint32_t i = 0; i &lt; APlist.size(); i++) {\n        WifiAPlist_t entry = APlist[i];\n        if (entry.ssid) {\n            free(entry.ssid);\n        }\n        if (entry.passphrase) {\n            free(entry.passphrase);\n        }\n    }\n    APlist.clear();\n}\n\nbool WiFiMulti::addAP(const char *ssid, const char *passphrase) {\n    WifiAPlist_t newAP;\n\n    if (!ssid || *ssid == 0x00 || strlen(ssid) &gt; 31) {\n        // fail SSID too long or missing!\n        LT_EM(WIFI, \"SSID missing or too long\");\n        return false;\n    }\n\n    if (passphrase &amp;&amp; strlen(passphrase) &gt; 64) {\n        // fail passphrase too long!\n        LT_EM(WIFI, \"Passphrase too long\");\n        return false;\n    }\n\n    newAP.ssid = strdup(ssid);\n\n    if (!newAP.ssid) {\n        LT_EM(WIFI, \"Fail newAP.ssid == 0\");\n        return false;\n    }\n\n    if (passphrase &amp;&amp; *passphrase != 0x00) {\n        newAP.passphrase = strdup(passphrase);\n        if (!newAP.passphrase) {\n            LT_EM(WIFI, \"Fail newAP.passphrase == 0\");\n            free(newAP.ssid);\n            return false;\n        }\n    } else {\n        newAP.passphrase = NULL;\n    }\n\n    APlist.push_back(newAP);\n    LT_VM(WIFI, \"Add SSID: %s\", newAP.ssid);\n    return true;\n}\n\nuint8_t WiFiMulti::run(uint32_t connectTimeout) {\n    int8_t scanResult;\n    uint8_t status = WiFi.status();\n    if (status == WL_CONNECTED) {\n        for (uint32_t x = 0; x &lt; APlist.size(); x++) {\n            if (WiFi.SSID() == APlist[x].ssid) {\n                return status;\n            }\n        }\n        WiFi.disconnect(false);\n        delay(10);\n        status = WiFi.status();\n    }\n\n    scanResult = WiFi.scanNetworks();\n    if (scanResult == WIFI_SCAN_RUNNING) {\n        // scan is running\n        return WL_NO_SSID_AVAIL;\n    } else if (scanResult &gt;= 0) {\n        // scan done analyze\n        WifiAPlist_t bestNetwork{NULL, NULL};\n        int bestNetworkDb = INT_MIN;\n        uint8_t bestBSSID[6];\n        int32_t bestChannel = 0;\n\n        LT_IM(WIFI, \"Scan finished\");\n\n        if (scanResult == 0) {\n            LT_IM(WIFI, \"No networks found\");\n        } else {\n            LT_IM(WIFI, \"%d networks found\", scanResult);\n            for (int8_t i = 0; i &lt; scanResult; ++i) {\n\n                String ssid_scan;\n                int32_t rssi_scan;\n                WiFiAuthMode sec_scan;\n                uint8_t *BSSID_scan;\n                int32_t chan_scan;\n\n                WiFi.getNetworkInfo(i, ssid_scan, sec_scan, rssi_scan, BSSID_scan, chan_scan);\n\n                bool known = false;\n                for (uint32_t x = APlist.size(); x &gt; 0; x--) {\n                    WifiAPlist_t entry = APlist[x - 1];\n\n                    if (ssid_scan == entry.ssid) { // SSID match\n                        known = true;\n                        if (rssi_scan &gt; bestNetworkDb) { // best network\n                            if (sec_scan == WIFI_AUTH_OPEN ||\n                                entry.passphrase) { // check for passphrase if not open wlan\n                                bestNetworkDb = rssi_scan;\n                                bestChannel   = chan_scan;\n                                memcpy((void *)&amp;bestNetwork, (void *)&amp;entry, sizeof(bestNetwork));\n                                memcpy((void *)&amp;bestBSSID, (void *)BSSID_scan, sizeof(bestBSSID));\n                            }\n                        }\n                        break;\n                    }\n                }\n\n                if (known) {\n                    LT_DM(\n                        WIFI,\n                        \" ---&gt;   %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\",\n                        i,\n                        chan_scan,\n                        BSSID_scan[0],\n                        BSSID_scan[1],\n                        BSSID_scan[2],\n                        BSSID_scan[3],\n                        BSSID_scan[4],\n                        BSSID_scan[5],\n                        ssid_scan.c_str(),\n                        rssi_scan,\n                        (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*'\n                    );\n                } else {\n                    LT_DM(\n                        WIFI,\n                        \"       %d: [%d][%02X:%02X:%02X:%02X:%02X:%02X] %s (%d) %c\",\n                        i,\n                        chan_scan,\n                        BSSID_scan[0],\n                        BSSID_scan[1],\n                        BSSID_scan[2],\n                        BSSID_scan[3],\n                        BSSID_scan[4],\n                        BSSID_scan[5],\n                        ssid_scan.c_str(),\n                        rssi_scan,\n                        (sec_scan == WIFI_AUTH_OPEN) ? ' ' : '*'\n                    );\n                }\n            }\n        }\n\n        // clean up ram\n        WiFi.scanDelete();\n\n        if (bestNetwork.ssid) {\n            LT_IM(\n                WIFI,\n                \"Connecting to BSSID: %02X:%02X:%02X:%02X:%02X:%02X SSID: %s Channel: %d (%d)\",\n                bestBSSID[0],\n                bestBSSID[1],\n                bestBSSID[2],\n                bestBSSID[3],\n                bestBSSID[4],\n                bestBSSID[5],\n                bestNetwork.ssid,\n                bestChannel,\n                bestNetworkDb\n            );\n\n            WiFi.begin(bestNetwork.ssid, bestNetwork.passphrase, bestChannel, bestBSSID);\n            status = WiFi.status();\n\n            auto startTime = millis();\n            // wait for connection, fail, or timeout\n            while (status != WL_CONNECTED &amp;&amp; status != WL_NO_SSID_AVAIL &amp;&amp; status != WL_CONNECT_FAILED &amp;&amp;\n                   (millis() - startTime) &lt;= connectTimeout) {\n                delay(10);\n                status = WiFi.status();\n            }\n\n            IPAddress ip;\n            switch (status) {\n                case WL_CONNECTED:\n                    LT_IM(WIFI, \"Connecting done\");\n                    LT_DM(WIFI, \"SSID: %s\", WiFi.SSID().c_str());\n                    // TODO fix this after implementing IP format for printf()\n                    ip = WiFi.localIP();\n                    LT_DM(WIFI, \"IP: %u.%u.%u.%u\", ip[0], ip[1], ip[2], ip[3]);\n                    LT_DM(WIFI, \"MAC: %s\", WiFi.BSSIDstr().c_str());\n                    LT_DM(WIFI, \"Channel: %d\", WiFi.channel());\n                    break;\n                case WL_NO_SSID_AVAIL:\n                    LT_EM(WIFI, \"Connecting failed; AP not found\");\n                    break;\n                case WL_CONNECT_FAILED:\n                    LT_EM(WIFI, \"Connecting failed\");\n                    break;\n                default:\n                    LT_EM(WIFI, \"Connecting failed (%d)\", status);\n                    break;\n            }\n        } else {\n            LT_EM(WIFI, \"No matching network found!\");\n        }\n    } else {\n        // start scan\n        LT_VM(WIFI, \"Delete old wifi config...\");\n        WiFi.disconnect();\n\n        LT_DM(WIFI, \"Start scan\");\n        // scan wifi async mode\n        WiFi.scanNetworks(true);\n    }\n\n    return status;\n}\n\n#endif // LT_ARD_HAS_WIFI\n</code></pre>"},{"location":"ltapi/_wi_fi_multi_8h/","title":"File WiFiMulti.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; WiFiMulti &gt; WiFiMulti.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"WiFi.h\"</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"ltapi/_wi_fi_multi_8h/#classes","title":"Classes","text":"Type Name     class WiFiMulti    struct WifiAPlist_t      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/WiFiMulti/WiFiMulti.h</code></p>"},{"location":"ltapi/_wi_fi_multi_8h_source/","title":"File WiFiMulti.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; WiFiMulti &gt; WiFiMulti.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"WiFi.h\"\n#include &lt;vector&gt;\n\ntypedef struct {\n    char *ssid;\n    char *passphrase;\n} WifiAPlist_t;\n\nclass WiFiMulti {\n  public:\n    WiFiMulti();\n    ~WiFiMulti();\n\n    bool addAP(const char *ssid, const char *passphrase = NULL);\n\n    uint8_t run(uint32_t connectTimeout = 10000);\n\n  private:\n    std::vector&lt;WifiAPlist_t&gt; APlist;\n};\n</code></pre>"},{"location":"ltapi/dir_981cf64acfe6b4337aeced5f3a54d8a1/","title":"Dir arduino/libretuya/libraries/base64","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64</p>"},{"location":"ltapi/dir_981cf64acfe6b4337aeced5f3a54d8a1/#files","title":"Files","text":"Type Name     file base64.cpp    file base64.h"},{"location":"ltapi/dir_981cf64acfe6b4337aeced5f3a54d8a1/#directories","title":"Directories","text":"Type Name     dir libb64      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/</code></p>"},{"location":"ltapi/dir_19e08ec7d704df4c2c76e8fca92c89b7/","title":"Dir arduino/libretuya/libraries/base64/libb64","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64</p>"},{"location":"ltapi/dir_19e08ec7d704df4c2c76e8fca92c89b7/#files","title":"Files","text":"Type Name     file cdecode.c    file cdecode.h    file cencode.c    file cencode.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/</code></p>"},{"location":"ltapi/cdecode_8c/","title":"File cdecode.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cdecode.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cdecode.h\"</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"ltapi/cdecode_8c/#public-functions","title":"Public Functions","text":"Type Name     int base64_decode_block (const char * code_in, const int length_in, char * plaintext_out, base64_decodestate * state_in)    int base64_decode_chars (const char * code_in, const int length_in, char * plaintext_out)    int base64_decode_value (char value_in)    void base64_init_decodestate (base64_decodestate * state_in)"},{"location":"ltapi/cdecode_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name     int base64_decode_block_signed (const int8_t * code_in, const int length_in, int8_t * plaintext_out, base64_decodestate * state_in)    int base64_decode_chars_signed (const int8_t * code_in, const int length_in, int8_t * plaintext_out)    int base64_decode_value_signed (int8_t value_in)"},{"location":"ltapi/cdecode_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cdecode_8c/#function-base64_decode_block","title":"function base64_decode_block","text":"<pre><code>int base64_decode_block (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out,\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_chars","title":"function base64_decode_chars","text":"<pre><code>int base64_decode_chars (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_value","title":"function base64_decode_value","text":"<pre><code>int base64_decode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_init_decodestate","title":"function base64_init_decodestate","text":"<pre><code>void base64_init_decodestate (\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/cdecode_8c/#function-base64_decode_block_signed","title":"function base64_decode_block_signed","text":"<pre><code>static int base64_decode_block_signed (\n    const int8_t * code_in,\n    const int length_in,\n    int8_t * plaintext_out,\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_chars_signed","title":"function base64_decode_chars_signed","text":"<pre><code>static int base64_decode_chars_signed (\n    const int8_t * code_in,\n    const int length_in,\n    int8_t * plaintext_out\n) \n</code></pre>"},{"location":"ltapi/cdecode_8c/#function-base64_decode_value_signed","title":"function base64_decode_value_signed","text":"<pre><code>static int base64_decode_value_signed (\n    int8_t value_in\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/cdecode.c</code></p>"},{"location":"ltapi/cdecode_8c_source/","title":"File cdecode.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cdecode.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncdecoder.c - c source to a base64 decoding algorithm implementation\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#include \"cdecode.h\"\n#include &lt;stdint.h&gt;\n\nstatic int base64_decode_value_signed(int8_t value_in){\n  static const int8_t decoding[] = {62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-2,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51};\n  static const int8_t decoding_size = sizeof(decoding);\n  value_in -= 43;\n  if (value_in &lt; 0 || value_in &gt;= decoding_size) return -1;\n  return decoding[(int)value_in];\n}\n\nvoid base64_init_decodestate(base64_decodestate* state_in){\n  state_in-&gt;step = step_a;\n  state_in-&gt;plainchar = 0;\n}\n\nstatic int base64_decode_block_signed(const int8_t* code_in, const int length_in, int8_t* plaintext_out, base64_decodestate* state_in){\n  const int8_t* codechar = code_in;\n  int8_t* plainchar = plaintext_out;\n  int8_t fragment;\n\n  *plainchar = state_in-&gt;plainchar;\n\n  switch (state_in-&gt;step){\n    while (1){\n      case step_a:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_a;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar    = (fragment &amp; 0x03f) &lt;&lt; 2;\n      case step_b:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_b;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar++ |= (fragment &amp; 0x030) &gt;&gt; 4;\n        *plainchar    = (fragment &amp; 0x00f) &lt;&lt; 4;\n      case step_c:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_c;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar++ |= (fragment &amp; 0x03c) &gt;&gt; 2;\n        *plainchar    = (fragment &amp; 0x003) &lt;&lt; 6;\n      case step_d:\n        do {\n          if (codechar == code_in+length_in){\n            state_in-&gt;step = step_d;\n            state_in-&gt;plainchar = *plainchar;\n            return plainchar - plaintext_out;\n          }\n          fragment = (int8_t)base64_decode_value_signed(*codechar++);\n        } while (fragment &lt; 0);\n        *plainchar++   |= (fragment &amp; 0x03f);\n    }\n  }\n  /* control should not reach here */\n  return plainchar - plaintext_out;\n}\n\nstatic int base64_decode_chars_signed(const int8_t* code_in, const int length_in, int8_t* plaintext_out){\n  base64_decodestate _state;\n  base64_init_decodestate(&amp;_state);\n  int len = base64_decode_block_signed(code_in, length_in, plaintext_out, &amp;_state);\n  if(len &gt; 0) plaintext_out[len] = 0;\n  return len;\n}\n\nint base64_decode_value(char value_in){\n  return base64_decode_value_signed(*((int8_t *) &amp;value_in));\n}\n\nint base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in){\n  return base64_decode_block_signed((int8_t *) code_in, length_in, (int8_t *) plaintext_out, state_in);\n}\n\nint base64_decode_chars(const char* code_in, const int length_in, char* plaintext_out){\n  return base64_decode_chars_signed((int8_t *) code_in, length_in, (int8_t *) plaintext_out);\n}\n</code></pre>"},{"location":"ltapi/cdecode_8h/","title":"File cdecode.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cdecode.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/cdecode_8h/#classes","title":"Classes","text":"Type Name     struct base64_decodestate"},{"location":"ltapi/cdecode_8h/#public-types","title":"Public Types","text":"Type Name     enum base64_decodestep"},{"location":"ltapi/cdecode_8h/#public-functions","title":"Public Functions","text":"Type Name     int base64_decode_block (const char * code_in, const int length_in, char * plaintext_out, base64_decodestate * state_in)    int base64_decode_chars (const char * code_in, const int length_in, char * plaintext_out)    int base64_decode_value (char value_in)    void base64_init_decodestate (base64_decodestate * state_in)"},{"location":"ltapi/cdecode_8h/#macros","title":"Macros","text":"Type Name     define base64_decode_expected_len (n) ((n * 3) / 4)"},{"location":"ltapi/cdecode_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/cdecode_8h/#enum-base64_decodestep","title":"enum base64_decodestep","text":"<pre><code>enum base64_decodestep {\n    step_a,\n    step_b,\n    step_c,\n    step_d\n};\n</code></pre>"},{"location":"ltapi/cdecode_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cdecode_8h/#function-base64_decode_block","title":"function base64_decode_block","text":"<pre><code>int base64_decode_block (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out,\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#function-base64_decode_chars","title":"function base64_decode_chars","text":"<pre><code>int base64_decode_chars (\n    const char * code_in,\n    const int length_in,\n    char * plaintext_out\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#function-base64_decode_value","title":"function base64_decode_value","text":"<pre><code>int base64_decode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#function-base64_init_decodestate","title":"function base64_init_decodestate","text":"<pre><code>void base64_init_decodestate (\n    base64_decodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cdecode_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/cdecode_8h/#define-base64_decode_expected_len","title":"define base64_decode_expected_len","text":"<pre><code>#define base64_decode_expected_len (\n    n\n) ((n * 3) / 4)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/cdecode.h</code></p>"},{"location":"ltapi/cdecode_8h_source/","title":"File cdecode.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cdecode.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncdecode.h - c header for a base64 decoding algorithm\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#ifndef BASE64_CDECODE_H\n#define BASE64_CDECODE_H\n\n#define base64_decode_expected_len(n) ((n * 3) / 4)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n    step_a, step_b, step_c, step_d\n} base64_decodestep;\n\ntypedef struct {\n    base64_decodestep step;\n    char plainchar;\n} base64_decodestate;\n\nvoid base64_init_decodestate(base64_decodestate* state_in);\n\nint base64_decode_value(char value_in);\n\nint base64_decode_block(const char* code_in, const int length_in, char* plaintext_out, base64_decodestate* state_in);\n\nint base64_decode_chars(const char* code_in, const int length_in, char* plaintext_out);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif /* BASE64_CDECODE_H */\n</code></pre>"},{"location":"ltapi/cencode_8c/","title":"File cencode.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cencode.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cencode.h\"</code></li> </ul>"},{"location":"ltapi/cencode_8c/#public-functions","title":"Public Functions","text":"Type Name     int base64_encode_block (const char * plaintext_in, int length_in, char * code_out, base64_encodestate * state_in)    int base64_encode_blockend (char * code_out, base64_encodestate * state_in)    int base64_encode_chars (const char * plaintext_in, int length_in, char * code_out)    char base64_encode_value (char value_in)    void base64_init_encodestate (base64_encodestate * state_in)"},{"location":"ltapi/cencode_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cencode_8c/#function-base64_encode_block","title":"function base64_encode_block","text":"<pre><code>int base64_encode_block (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_encode_blockend","title":"function base64_encode_blockend","text":"<pre><code>int base64_encode_blockend (\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_encode_chars","title":"function base64_encode_chars","text":"<pre><code>int base64_encode_chars (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_encode_value","title":"function base64_encode_value","text":"<pre><code>char base64_encode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8c/#function-base64_init_encodestate","title":"function base64_init_encodestate","text":"<pre><code>void base64_init_encodestate (\n    base64_encodestate * state_in\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/cencode.c</code></p>"},{"location":"ltapi/cencode_8c_source/","title":"File cencode.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cencode.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncencoder.c - c source to a base64 encoding algorithm implementation\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#include \"cencode.h\"\n\nvoid base64_init_encodestate(base64_encodestate* state_in)\n{\n    state_in-&gt;step = step_A;\n    state_in-&gt;result = 0;\n}\n\nchar base64_encode_value(char value_in)\n{\n    static const char* encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    if (value_in &gt; 63) {\n        return '=';\n    }\n    return encoding[(int)value_in];\n}\n\nint base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in)\n{\n    const char* plainchar = plaintext_in;\n    const char* const plaintextend = plaintext_in + length_in;\n    char* codechar = code_out;\n    char result;\n    char fragment;\n\n    result = state_in-&gt;result;\n\n    switch (state_in-&gt;step) {\n        while (1) {\n        case step_A:\n            if (plainchar == plaintextend) {\n                state_in-&gt;result = result;\n                state_in-&gt;step = step_A;\n                return codechar - code_out;\n            }\n            fragment = *plainchar++;\n            result = (fragment &amp; 0x0fc) &gt;&gt; 2;\n            *codechar++ = base64_encode_value(result);\n            result = (fragment &amp; 0x003) &lt;&lt; 4;\n        case step_B:\n            if (plainchar == plaintextend) {\n                state_in-&gt;result = result;\n                state_in-&gt;step = step_B;\n                return codechar - code_out;\n            }\n            fragment = *plainchar++;\n            result |= (fragment &amp; 0x0f0) &gt;&gt; 4;\n            *codechar++ = base64_encode_value(result);\n            result = (fragment &amp; 0x00f) &lt;&lt; 2;\n        case step_C:\n            if (plainchar == plaintextend) {\n                state_in-&gt;result = result;\n                state_in-&gt;step = step_C;\n                return codechar - code_out;\n            }\n            fragment = *plainchar++;\n            result |= (fragment &amp; 0x0c0) &gt;&gt; 6;\n            *codechar++ = base64_encode_value(result);\n            result  = (fragment &amp; 0x03f) &gt;&gt; 0;\n            *codechar++ = base64_encode_value(result);\n        }\n    }\n    /* control should not reach here */\n    return codechar - code_out;\n}\n\nint base64_encode_blockend(char* code_out, base64_encodestate* state_in)\n{\n    char* codechar = code_out;\n\n    switch (state_in-&gt;step) {\n    case step_B:\n        *codechar++ = base64_encode_value(state_in-&gt;result);\n        *codechar++ = '=';\n        *codechar++ = '=';\n        break;\n    case step_C:\n        *codechar++ = base64_encode_value(state_in-&gt;result);\n        *codechar++ = '=';\n        break;\n    case step_A:\n        break;\n    }\n    *codechar = 0x00;\n\n    return codechar - code_out;\n}\n\nint base64_encode_chars(const char* plaintext_in, int length_in, char* code_out)\n{\n    base64_encodestate _state;\n    base64_init_encodestate(&amp;_state);\n    int len = base64_encode_block(plaintext_in, length_in, code_out, &amp;_state);\n    return len + base64_encode_blockend((code_out + len), &amp;_state);\n}\n</code></pre>"},{"location":"ltapi/cencode_8h/","title":"File cencode.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cencode.h</p> <p>Go to the source code of this file.</p>"},{"location":"ltapi/cencode_8h/#classes","title":"Classes","text":"Type Name     struct base64_encodestate"},{"location":"ltapi/cencode_8h/#public-types","title":"Public Types","text":"Type Name     enum base64_encodestep"},{"location":"ltapi/cencode_8h/#public-functions","title":"Public Functions","text":"Type Name     int base64_encode_block (const char * plaintext_in, int length_in, char * code_out, base64_encodestate * state_in)    int base64_encode_blockend (char * code_out, base64_encodestate * state_in)    int base64_encode_chars (const char * plaintext_in, int length_in, char * code_out)    char base64_encode_value (char value_in)    void base64_init_encodestate (base64_encodestate * state_in)"},{"location":"ltapi/cencode_8h/#macros","title":"Macros","text":"Type Name     define base64_encode_expected_len (n) ((((4 * n) / 3) + 3) &amp; ~3)"},{"location":"ltapi/cencode_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/cencode_8h/#enum-base64_encodestep","title":"enum base64_encodestep","text":"<pre><code>enum base64_encodestep {\n    step_A,\n    step_B,\n    step_C\n};\n</code></pre>"},{"location":"ltapi/cencode_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/cencode_8h/#function-base64_encode_block","title":"function base64_encode_block","text":"<pre><code>int base64_encode_block (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_encode_blockend","title":"function base64_encode_blockend","text":"<pre><code>int base64_encode_blockend (\n    char * code_out,\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_encode_chars","title":"function base64_encode_chars","text":"<pre><code>int base64_encode_chars (\n    const char * plaintext_in,\n    int length_in,\n    char * code_out\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_encode_value","title":"function base64_encode_value","text":"<pre><code>char base64_encode_value (\n    char value_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#function-base64_init_encodestate","title":"function base64_init_encodestate","text":"<pre><code>void base64_init_encodestate (\n    base64_encodestate * state_in\n) \n</code></pre>"},{"location":"ltapi/cencode_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/cencode_8h/#define-base64_encode_expected_len","title":"define base64_encode_expected_len","text":"<pre><code>#define base64_encode_expected_len (\n    n\n) ((((4 * n) / 3) + 3) &amp; ~3)\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/libb64/cencode.h</code></p>"},{"location":"ltapi/cencode_8h_source/","title":"File cencode.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; libb64 &gt; cencode.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\ncencode.h - c header for a base64 encoding algorithm\n\nThis is part of the libb64 project, and has been placed in the public domain.\nFor details, see http://sourceforge.net/projects/libb64\n*/\n\n#ifndef BASE64_CENCODE_H\n#define BASE64_CENCODE_H\n\n#define base64_encode_expected_len(n) ((((4 * n) / 3) + 3) &amp; ~3)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n    step_A, step_B, step_C\n} base64_encodestep;\n\ntypedef struct {\n    base64_encodestep step;\n    char result;\n    int stepcount;\n} base64_encodestate;\n\nvoid base64_init_encodestate(base64_encodestate* state_in);\n\nchar base64_encode_value(char value_in);\n\nint base64_encode_block(const char* plaintext_in, int length_in, char* code_out, base64_encodestate* state_in);\n\nint base64_encode_blockend(char* code_out, base64_encodestate* state_in);\n\nint base64_encode_chars(const char* plaintext_in, int length_in, char* code_out);\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n\n#endif /* BASE64_CENCODE_H */\n</code></pre>"},{"location":"ltapi/base64_8cpp/","title":"File base64.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; base64.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"Arduino.h\"</code></li> <li><code>#include \"libb64/cdecode.h\"</code></li> <li><code>#include \"libb64/cencode.h\"</code></li> <li><code>#include \"base64.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/base64.cpp</code></p>"},{"location":"ltapi/base64_8cpp_source/","title":"File base64.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; base64.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"Arduino.h\"\nextern \"C\" {\n#include \"libb64/cdecode.h\"\n#include \"libb64/cencode.h\"\n}\n#include \"base64.h\"\n\nString base64::encode(const uint8_t * data, size_t length)\n{\n    size_t size = base64_encode_expected_len(length) + 1;\n    char * buffer = (char *) malloc(size);\n    if(buffer) {\n        base64_encodestate _state;\n        base64_init_encodestate(&amp;_state);\n        int len = base64_encode_block((const char *) &amp;data[0], length, &amp;buffer[0], &amp;_state);\n        len = base64_encode_blockend((buffer + len), &amp;_state);\n\n        String base64 = String(buffer);\n        free(buffer);\n        return base64;\n    }\n    return String(\"-FAIL-\");\n}\n\nString base64::encode(const String&amp; text)\n{\n    return base64::encode((uint8_t *) text.c_str(), text.length());\n}\n</code></pre>"},{"location":"ltapi/base64_8h/","title":"File base64.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; base64.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> </ul>"},{"location":"ltapi/base64_8h/#classes","title":"Classes","text":"Type Name     class base64      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/base64/base64.h</code></p>"},{"location":"ltapi/base64_8h_source/","title":"File base64.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; base64 &gt; base64.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n\nclass base64 {\n  public:\n    static String encode(const uint8_t *data, size_t length);\n    static String encode(const String &amp;text);\n};\n</code></pre>"},{"location":"ltapi/dir_9c0909eb16fa5bf0b18ff734c0ac6660/","title":"Dir arduino/libretuya/libraries/cbuf","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; cbuf</p>"},{"location":"ltapi/dir_9c0909eb16fa5bf0b18ff734c0ac6660/#files","title":"Files","text":"Type Name     file cbuf.cpp    file cbuf.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/cbuf/</code></p>"},{"location":"ltapi/cbuf_8cpp/","title":"File cbuf.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; cbuf &gt; cbuf.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cbuf.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/cbuf/cbuf.cpp</code></p>"},{"location":"ltapi/cbuf_8cpp_source/","title":"File cbuf.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; cbuf &gt; cbuf.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n cbuf.cpp - Circular buffer implementation\n Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"cbuf.h\"\n\ncbuf::cbuf(size_t size) :\n    next(NULL), _size(size+1), _buf(new char[size+1]), _bufend(_buf + size + 1), _begin(_buf), _end(_begin)\n{\n}\n\ncbuf::~cbuf()\n{\n    delete[] _buf;\n}\n\nsize_t cbuf::resizeAdd(size_t addSize)\n{\n    return resize(_size + addSize);\n}\n\nsize_t cbuf::resize(size_t newSize)\n{\n\n    size_t bytes_available = available();\n    newSize += 1;\n    // not lose any data\n    // if data can be lost use remove or flush before resize\n    if((newSize &lt; bytes_available) || (newSize == _size)) {\n        return _size;\n    }\n\n    char *newbuf = new char[newSize];\n    char *oldbuf = _buf;\n\n    if(!newbuf) {\n        return _size;\n    }\n\n    if(_buf) {\n        read(newbuf, bytes_available);\n        memset((newbuf + bytes_available), 0x00, (newSize - bytes_available));\n    }\n\n    _begin = newbuf;\n    _end = newbuf + bytes_available;\n    _bufend = newbuf + newSize;\n    _size = newSize;\n\n    _buf = newbuf;\n    delete[] oldbuf;\n\n    return _size;\n}\n\nsize_t cbuf::available() const\n{\n    if(_end &gt;= _begin) {\n        return _end - _begin;\n    }\n    return _size - (_begin - _end);\n}\n\nsize_t cbuf::size()\n{\n    return _size;\n}\n\nsize_t cbuf::room() const\n{\n    if(_end &gt;= _begin) {\n        return _size - (_end - _begin) - 1;\n    }\n    return _begin - _end - 1;\n}\n\nint cbuf::peek()\n{\n    if(empty()) {\n        return -1;\n    }\n\n    return static_cast&lt;int&gt;(*_begin);\n}\n\nsize_t cbuf::peek(char *dst, size_t size)\n{\n    size_t bytes_available = available();\n    size_t size_to_read = (size &lt; bytes_available) ? size : bytes_available;\n    size_t size_read = size_to_read;\n    char * begin = _begin;\n    if(_end &lt; _begin &amp;&amp; size_to_read &gt; (size_t) (_bufend - _begin)) {\n        size_t top_size = _bufend - _begin;\n        memcpy(dst, _begin, top_size);\n        begin = _buf;\n        size_to_read -= top_size;\n        dst += top_size;\n    }\n    memcpy(dst, begin, size_to_read);\n    return size_read;\n}\n\nint cbuf::read()\n{\n    if(empty()) {\n        return -1;\n    }\n\n    char result = *_begin;\n    _begin = wrap_if_bufend(_begin + 1);\n    return static_cast&lt;int&gt;(result);\n}\n\nsize_t cbuf::read(char* dst, size_t size)\n{\n    size_t bytes_available = available();\n    size_t size_to_read = (size &lt; bytes_available) ? size : bytes_available;\n    size_t size_read = size_to_read;\n    if(_end &lt; _begin &amp;&amp; size_to_read &gt; (size_t) (_bufend - _begin)) {\n        size_t top_size = _bufend - _begin;\n        memcpy(dst, _begin, top_size);\n        _begin = _buf;\n        size_to_read -= top_size;\n        dst += top_size;\n    }\n    memcpy(dst, _begin, size_to_read);\n    _begin = wrap_if_bufend(_begin + size_to_read);\n    return size_read;\n}\n\nsize_t cbuf::write(char c)\n{\n    if(full()) {\n        return 0;\n    }\n\n    *_end = c;\n    _end = wrap_if_bufend(_end + 1);\n    return 1;\n}\n\nsize_t cbuf::write(const char* src, size_t size)\n{\n    size_t bytes_available = room();\n    size_t size_to_write = (size &lt; bytes_available) ? size : bytes_available;\n    size_t size_written = size_to_write;\n    if(_end &gt;= _begin &amp;&amp; size_to_write &gt; (size_t) (_bufend - _end)) {\n        size_t top_size = _bufend - _end;\n        memcpy(_end, src, top_size);\n        _end = _buf;\n        size_to_write -= top_size;\n        src += top_size;\n    }\n    memcpy(_end, src, size_to_write);\n    _end = wrap_if_bufend(_end + size_to_write);\n    return size_written;\n}\n\nvoid cbuf::flush()\n{\n    _begin = _buf;\n    _end = _buf;\n}\n\nsize_t cbuf::remove(size_t size)\n{\n    size_t bytes_available = available();\n    if(size &gt;= bytes_available) {\n        flush();\n        return 0;\n    }\n    size_t size_to_remove = (size &lt; bytes_available) ? size : bytes_available;\n    if(_end &lt; _begin &amp;&amp; size_to_remove &gt; (size_t) (_bufend - _begin)) {\n        size_t top_size = _bufend - _begin;\n        _begin = _buf;\n        size_to_remove -= top_size;\n    }\n    _begin = wrap_if_bufend(_begin + size_to_remove);\n    return available();\n}\n</code></pre>"},{"location":"ltapi/cbuf_8h/","title":"File cbuf.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; cbuf &gt; cbuf.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/cbuf_8h/#classes","title":"Classes","text":"Type Name     class cbuf      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/cbuf/cbuf.h</code></p>"},{"location":"ltapi/cbuf_8h_source/","title":"File cbuf.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; cbuf &gt; cbuf.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n cbuf.h - Circular buffer implementation\n Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.\n This file is part of the esp8266 core for Arduino environment.\n\n This library is free software; you can redistribute it and/or\n modify it under the terms of the GNU Lesser General Public\n License as published by the Free Software Foundation; either\n version 2.1 of the License, or (at your option) any later version.\n\n This library is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public\n License along with this library; if not, write to the Free Software\n Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef __cbuf_h\n#define __cbuf_h\n\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string.h&gt;\n\nclass cbuf\n{\npublic:\n    cbuf(size_t size);\n    ~cbuf();\n\n    size_t resizeAdd(size_t addSize);\n    size_t resize(size_t newSize);\n    size_t available() const;\n    size_t size();\n\n    size_t room() const;\n\n    inline bool empty() const\n    {\n        return _begin == _end;\n    }\n\n    inline bool full() const\n    {\n        return wrap_if_bufend(_end + 1) == _begin;\n    }\n\n    int peek();\n    size_t peek(char *dst, size_t size);\n\n    int read();\n    size_t read(char* dst, size_t size);\n\n    size_t write(char c);\n    size_t write(const char* src, size_t size);\n\n    void flush();\n    size_t remove(size_t size);\n\n    cbuf *next;\n\nprotected:\n    inline char* wrap_if_bufend(char* ptr) const\n    {\n        return (ptr == _bufend) ? _buf : ptr;\n    }\n\n    size_t _size;\n    char* _buf;\n    const char* _bufend;\n    char* _begin;\n    char* _end;\n\n};\n\n#endif//__cbuf_h\n</code></pre>"},{"location":"ltapi/dir_99e8ae12353a7415a6b791a1ee0fdac2/","title":"Dir arduino/libretuya/libraries/mDNS","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS</p>"},{"location":"ltapi/dir_99e8ae12353a7415a6b791a1ee0fdac2/#files","title":"Files","text":"Type Name     file ESPmDNS.h    file LwIPmDNS.cpp    file mDNS.cpp    file mDNS.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/mDNS/</code></p>"},{"location":"ltapi/_e_s_pm_d_n_s_8h/","title":"File ESPmDNS.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; ESPmDNS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"mDNS.h\"</code></li> </ul>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/mDNS/ESPmDNS.h</code></p>"},{"location":"ltapi/_e_s_pm_d_n_s_8h_source/","title":"File ESPmDNS.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; ESPmDNS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-23. */\n\n#pragma once\n\n#include \"mDNS.h\"\n</code></pre>"},{"location":"ltapi/_lw_i_pm_d_n_s_8cpp/","title":"File LwIPmDNS.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; LwIPmDNS.cpp</p> <p>Go to the source code of this file.</p>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/mDNS/LwIPmDNS.cpp</code></p>"},{"location":"ltapi/_lw_i_pm_d_n_s_8cpp_source/","title":"File LwIPmDNS.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; LwIPmDNS.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-23. */\n\n#ifdef LT_HAS_LWIP2\n\n#include \"mDNS.h\"\n#include &lt;vector&gt;\n\nextern \"C\" {\n#include &lt;errno.h&gt;\n#include &lt;lwip/apps/mdns.h&gt;\n#include &lt;lwip/igmp.h&gt;\n#include &lt;lwip/init.h&gt;\n#include &lt;lwip/netif.h&gt;\n}\n\nstatic std::vector&lt;char *&gt; services;\nstatic std::vector&lt;uint8_t&gt; protos;\nstatic std::vector&lt;std::vector&lt;char *&gt;&gt; records;\n\nmDNS::mDNS() {}\n\nmDNS::~mDNS() {}\n\nstatic void mdnsTxtCallback(struct mdns_service *service, void *userdata) {\n    size_t index = (size_t)userdata;\n    if (index &gt;= records.size())\n        return;\n\n    for (const auto record : records[index]) {\n        err_t err = mdns_resp_add_service_txtitem(service, record, strlen(record));\n        if (err != ERR_OK)\n            return;\n    }\n}\n\nstatic void mdnsStatusCallback(struct netif *netif, uint8_t result) {\n    LT_DM(MDNS, \"Status: netif %u, status %u\", netif-&gt;num, result);\n}\n\nbool mDNS::begin(const char *hostname) {\n    setInstanceName(hostname);\n    LT_DM(MDNS, \"Starting (%s)\", hostname);\n#if LWIP_VERSION_MAJOR &gt;= 2 &amp;&amp; LWIP_VERSION_MINOR &gt;= 1\n    mdns_resp_register_name_result_cb(mdnsStatusCallback);\n#endif\n    mdns_resp_init();\n    uint8_t enabled = 0;\n\n    struct netif *netif;\n    for (netif = netif_list; netif != NULL; netif = netif-&gt;next) {\n        if (!netif_is_up(netif))\n            continue;\n\n        LT_DM(MDNS, \"Adding netif %u\", netif-&gt;num);\n        if ((netif-&gt;flags &amp; NETIF_FLAG_IGMP) == 0) {\n            LT_DM(MDNS, \"Enabling IGMP\");\n            netif-&gt;flags |= NETIF_FLAG_IGMP;\n            igmp_start(netif);\n        }\n\n        err_t ret = mdns_resp_add_netif(netif, hostname, 255);\n        if (ret == ERR_OK)\n            enabled++;\n        else\n            LT_DM(MDNS, \"Cannot add netif %u; ret=%d, errno=%d\", netif-&gt;num, ret, errno);\n    }\n    return enabled &gt; 0;\n}\n\nvoid mDNS::end() {\n    struct netif *netif = netif_list;\n    while (netif != NULL) {\n        if (netif_is_up(netif))\n            mdns_resp_remove_netif(netif);\n        netif = netif-&gt;next;\n    }\n}\n\nbool mDNS::addServiceImpl(const char *name, const char *service, uint8_t proto, uint16_t port) {\n    bool added          = false;\n    struct netif *netif = netif_list;\n    while (netif != NULL) {\n        if (netif_is_up(netif)) {\n            // register TXT callback;\n            // pass service index as userdata parameter\n            LT_DM(MDNS, \"Add service: netif %u / %s / %s / %u / %u\", netif-&gt;num, name, service, proto, port);\n            mdns_resp_add_service(\n                netif,\n                name,\n                service,\n                (mdns_sd_proto)proto,\n                port,\n                255,\n                mdnsTxtCallback,\n                (void *)services.size() // index of newly added service\n            );\n            added = true;\n        }\n        netif = netif-&gt;next;\n    }\n\n    if (!added)\n        return false;\n\n    // add the service to TXT record arrays\n    services.push_back(strdup(service));\n    protos.push_back(proto);\n    records.emplace_back();\n\n    return true;\n}\n\nbool mDNS::addServiceTxtImpl(const char *service, uint8_t proto, const char *item) {\n    int8_t index = -1;\n    for (uint8_t i = 0; i &lt; services.size(); i++) {\n        // find a matching service\n        if (strcmp(services[i], service) == 0 &amp;&amp; protos[i] == proto) {\n            index = i;\n            break;\n        }\n    }\n    if (index == -1)\n        return false;\n\n    records[index].push_back(strdup(item));\n    return true;\n}\n\nMDNSResponder MDNS;\n\n#endif\n</code></pre>"},{"location":"ltapi/m_d_n_s_8cpp/","title":"File mDNS.cpp","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; mDNS.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"mDNS.h\"</code></li> </ul>"},{"location":"ltapi/m_d_n_s_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name     char * ensureUnderscore (const char * value)"},{"location":"ltapi/m_d_n_s_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"ltapi/m_d_n_s_8cpp/#function-ensureunderscore","title":"function ensureUnderscore","text":"<pre><code>static char * ensureUnderscore (\n    const char * value\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/mDNS/mDNS.cpp</code></p>"},{"location":"ltapi/m_d_n_s_8cpp_source/","title":"File mDNS.cpp","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; mDNS.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-08-26. */\n\n#include \"mDNS.h\"\n\nstatic char *ensureUnderscore(const char *value) {\n    uint8_t len  = strlen(value) + 1;\n    char *result = (char *)malloc(len);\n    result[0]    = '_';\n    strcpy(result + 1, value + (value[0] == '_'));\n    return result;\n}\n\nvoid mDNS::setInstanceName(const char *name) {\n    if (instanceName)\n        free(instanceName);\n    instanceName = strdup(name);\n}\n\nbool mDNS::addService(char *service, char *proto, uint16_t port) {\n    char *_service = ensureUnderscore(service);\n    uint8_t _proto = strncmp(proto + (proto[0] == '_'), \"tcp\", 3) == 0 ? MDNS_TCP : MDNS_UDP;\n\n    bool result = addServiceImpl(instanceName ? instanceName : \"LT mDNS\", _service, _proto, port);\n    free(_service);\n    return result;\n}\n\nbool mDNS::addServiceTxt(char *service, char *proto, char *key, char *value) {\n    char *_service = ensureUnderscore(service);\n    uint8_t _proto = strncmp(proto + (proto[0] == '_'), \"tcp\", 3) == 0 ? MDNS_TCP : MDNS_UDP;\n\n    uint8_t txt_len = strlen(key) + strlen(value) + 1;\n    char *txt       = (char *)malloc(txt_len + 1);\n    sprintf(txt, \"%s=%s\", key, value);\n\n    bool result = addServiceTxtImpl(_service, _proto, txt);\n    free(_service);\n    free(txt);\n    return result;\n}\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/","title":"File mDNS.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; mDNS.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;api/IPv6Address.h&gt;</code></li> </ul>"},{"location":"ltapi/m_d_n_s_8h/#classes","title":"Classes","text":"Type Name     class mDNS"},{"location":"ltapi/m_d_n_s_8h/#public-types","title":"Public Types","text":"Type Name     typedef mDNS MDNSResponder"},{"location":"ltapi/m_d_n_s_8h/#public-attributes","title":"Public Attributes","text":"Type Name     MDNSResponder MDNS"},{"location":"ltapi/m_d_n_s_8h/#macros","title":"Macros","text":"Type Name     define MDNS_TCP  1   define MDNS_UDP  0"},{"location":"ltapi/m_d_n_s_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/m_d_n_s_8h/#typedef-mdnsresponder","title":"typedef MDNSResponder","text":"<pre><code>typedef mDNS MDNSResponder;\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/m_d_n_s_8h/#variable-mdns","title":"variable MDNS","text":"<pre><code>MDNSResponder MDNS;\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/m_d_n_s_8h/#define-mdns_tcp","title":"define MDNS_TCP","text":"<pre><code>#define MDNS_TCP 1\n</code></pre>"},{"location":"ltapi/m_d_n_s_8h/#define-mdns_udp","title":"define MDNS_UDP","text":"<pre><code>#define MDNS_UDP 0\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/libraries/mDNS/mDNS.h</code></p>"},{"location":"ltapi/m_d_n_s_8h_source/","title":"File mDNS.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; libraries &gt; mDNS &gt; mDNS.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\nESP8266 Multicast DNS (port of CC3000 Multicast DNS library)\nVersion 1.1\nCopyright (c) 2013 Tony DiCola (tony@tonydicola.com)\nESP8266 port (c) 2015 Ivan Grokhotkov (ivan@esp8266.com)\nMDNS-SD Suport 2015 Hristo Gochkov (hristo@espressif.com)\nExtended MDNS-SD support 2016 Lars Englund (lars.englund@gmail.com)\nRewritten for ESP32 by Hristo Gochkov (hristo@espressif.com)\n\nThis is a simple implementation of multicast DNS query support for an Arduino\nrunning on ESP32 chip.\n\nUsage:\n- Include the ESP32 Multicast DNS library in the sketch.\n- Call the begin method in the sketch's setup and provide a domain name (without\n  the '.local' suffix, i.e. just provide 'foo' to resolve 'foo.local'), and the\n  Adafruit CC3000 class instance.  Optionally provide a time to live (in seconds)\n  for the DNS record--the default is 1 hour.\n- Call the update method in each iteration of the sketch's loop function.\n\nLicense (MIT license):\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n\n*/\n\n#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;api/IPv6Address.h&gt;\n\n#define MDNS_UDP 0\n#define MDNS_TCP 1\n\nclass mDNS {\n  private:\n    bool addServiceImpl(const char *name, const char *service, uint8_t proto, uint16_t port);\n    bool addServiceTxtImpl(const char *service, uint8_t proto, const char *item);\n\n    char *instanceName = NULL;\n\n  public:\n    mDNS();\n    ~mDNS();\n\n    bool begin(const char *hostname);\n    void end();\n\n    void setInstanceName(const char *name);\n    bool addService(char *service, char *proto, uint16_t port);\n    bool addServiceTxt(char *service, char *proto, char *key, char *value);\n    // void enableArduino(uint16_t port = 3232, bool auth = false);\n    // void disableArduino();\n    // void enableWorkstation(esp_interface_t interface = ESP_IF_WIFI_STA);\n    // void disableWorkstation();\n\n    IPAddress queryHost(char *host, uint32_t timeout = 2000);\n    int queryService(char *service, char *proto);\n\n    String hostname(int idx);\n    IPAddress IP(int idx);\n    IPv6Address IPv6(int idx);\n    uint16_t port(int idx);\n    int numTxt(int idx);\n    bool hasTxt(int idx, const char *key);\n    String txt(int idx, const char *key);\n    String txt(int idx, int txtIdx);\n    String txtKey(int idx, int txtIdx);\n\n    void setInstanceName(String name) {\n        setInstanceName(name.c_str());\n    }\n\n    void setInstanceName(char *name) {\n        setInstanceName((const char *)name);\n    }\n\n    bool addService(const char *service, const char *proto, uint16_t port) {\n        return addService((char *)service, (char *)proto, port);\n    }\n\n    bool addService(String service, String proto, uint16_t port) {\n        return addService(service.c_str(), proto.c_str(), port);\n    }\n\n    void addServiceTxt(const char *service, const char *proto, const char *key, const char *value) {\n        addServiceTxt((char *)service, (char *)proto, (char *)key, (char *)value);\n    }\n\n    void addServiceTxt(String service, String proto, String key, String value) {\n        addServiceTxt(service.c_str(), proto.c_str(), key.c_str(), value.c_str());\n    }\n\n    IPAddress queryHost(const char *host, uint32_t timeout = 2000) {\n        return queryHost((char *)host, timeout);\n    }\n\n    IPAddress queryHost(String host, uint32_t timeout = 2000) {\n        return queryHost(host.c_str(), timeout);\n    }\n\n    int queryService(const char *service, const char *proto) {\n        return queryService((char *)service, (char *)proto);\n    }\n\n    int queryService(String service, String proto) {\n        return queryService(service.c_str(), proto.c_str());\n    }\n};\n\ntypedef mDNS MDNSResponder;\n\nextern MDNSResponder MDNS;\n</code></pre>"},{"location":"ltapi/dir_025b3ccf035cb36eaa58e8e82bbac208/","title":"Dir arduino/libretuya/port","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port</p>"},{"location":"ltapi/dir_025b3ccf035cb36eaa58e8e82bbac208/#directories","title":"Directories","text":"Type Name     dir flashdb    dir printf      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/</code></p>"},{"location":"ltapi/dir_640720be9c9e6d6e56917fc207dddde1/","title":"Dir arduino/libretuya/port/flashdb","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; flashdb</p>"},{"location":"ltapi/dir_640720be9c9e6d6e56917fc207dddde1/#files","title":"Files","text":"Type Name     file fal_cfg.h    file fdb_cfg.h      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/flashdb/</code></p>"},{"location":"ltapi/fal__cfg_8h/","title":"File fal_cfg.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; flashdb &gt; fal_cfg.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fal_def.h&gt;</code></li> </ul>"},{"location":"ltapi/fal__cfg_8h/#public-attributes","title":"Public Attributes","text":"Type Name     fal_partition_t fal_root_part Root partition table, representing the entire flash.   const struct fal_flash_dev flash0"},{"location":"ltapi/fal__cfg_8h/#public-functions","title":"Public Functions","text":"Type Name     void printf_nop (const char * fmt, ...)"},{"location":"ltapi/fal__cfg_8h/#macros","title":"Macros","text":"Type Name     define FAL_DEBUG  0   define FAL_DEV_NAME_MAX  16   define FAL_FLASH_DEV_NAME  \"flash0\"   define FAL_FLASH_DEV_TABLE     { &amp;flash0, }   define FAL_PART_HAS_TABLE_CFG    define FAL_PART_TABLE_ITEM (part_lower, part_upper)    define FAL_PRINTF  printf_nop"},{"location":"ltapi/fal__cfg_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"ltapi/fal__cfg_8h/#variable-fal_root_part","title":"variable fal_root_part","text":"<pre><code>fal_partition_t fal_root_part;\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#variable-flash0","title":"variable flash0","text":"<pre><code>const struct fal_flash_dev flash0;\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/fal__cfg_8h/#function-printf_nop","title":"function printf_nop","text":"<pre><code>inline void printf_nop (\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/fal__cfg_8h/#define-fal_debug","title":"define FAL_DEBUG","text":"<pre><code>#define FAL_DEBUG 0\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_dev_name_max","title":"define FAL_DEV_NAME_MAX","text":"<pre><code>#define FAL_DEV_NAME_MAX 16\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_flash_dev_name","title":"define FAL_FLASH_DEV_NAME","text":"<pre><code>#define FAL_FLASH_DEV_NAME \"flash0\"\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_flash_dev_table","title":"define FAL_FLASH_DEV_TABLE","text":"<pre><code>#define FAL_FLASH_DEV_TABLE { &amp;flash0, }\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_part_has_table_cfg","title":"define FAL_PART_HAS_TABLE_CFG","text":"<pre><code>#define FAL_PART_HAS_TABLE_CFG \n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_part_table_item","title":"define FAL_PART_TABLE_ITEM","text":"<pre><code>#define FAL_PART_TABLE_ITEM (\n    part_lower,\n    part_upper\n) {                                                                                                                  \\\n        .magic_word = FAL_PART_MAGIC_WORD,         /* magic word */                                                    \\\n        .name       = #part_lower,                 /* lowercase name as string */                                      \\\n        .flash_name = FAL_FLASH_DEV_NAME,          /* flash device name */                                             \\\n        .offset     = FLASH_##part_upper##_OFFSET, /* partition offset macro as uppercase string */                    \\\n        .len        = FLASH_##part_upper##_LENGTH, /* partition length macro as uppercase string */                    \\\n    },\n</code></pre>"},{"location":"ltapi/fal__cfg_8h/#define-fal_printf","title":"define FAL_PRINTF","text":"<pre><code>#define FAL_PRINTF printf_nop\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/flashdb/fal_cfg.h</code></p>"},{"location":"ltapi/fal__cfg_8h_source/","title":"File fal_cfg.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; port &gt; flashdb &gt; fal_cfg.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-24. */\n\n#pragma once\n\ninline void printf_nop(const char *fmt, ...) {}\n\n#define FAL_PRINTF printf_nop\n#define FAL_DEBUG  0\n\n// Flash device configuration\nextern const struct fal_flash_dev flash0;\n\n#define FAL_FLASH_DEV_NAME \"flash0\"\n\n#define FAL_FLASH_DEV_TABLE                                                                                            \\\n    { &amp;flash0, }\n\n#define FAL_DEV_NAME_MAX 16 // no need for 24 chars (default)\n\n// Partition table\n#define FAL_PART_HAS_TABLE_CFG\n\n#define FAL_PART_TABLE_ITEM(part_lower, part_upper)                                                                    \\\n    {                                                                                                                  \\\n        .magic_word = FAL_PART_MAGIC_WORD,         /* magic word */                                                    \\\n        .name       = #part_lower,                 /* lowercase name as string */                                      \\\n        .flash_name = FAL_FLASH_DEV_NAME,          /* flash device name */                                             \\\n        .offset     = FLASH_##part_upper##_OFFSET, /* partition offset macro as uppercase string */                    \\\n        .len        = FLASH_##part_upper##_LENGTH, /* partition length macro as uppercase string */                    \\\n    },\n\n// for fal_partition_t\n#include &lt;fal_def.h&gt;\n\nextern fal_partition_t fal_root_part;\n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/","title":"File fdb_cfg.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; flashdb &gt; fdb_cfg.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;printf_config.h&gt;</code></li> </ul>"},{"location":"ltapi/fdb__cfg_8h/#macros","title":"Macros","text":"Type Name     define FDB_PRINT (...)    define FDB_USING_FAL_MODE    define FDB_USING_KVDB    define FDB_WRITE_GRAN  8"},{"location":"ltapi/fdb__cfg_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/fdb__cfg_8h/#define-fdb_print","title":"define FDB_PRINT","text":"<pre><code>#define FDB_PRINT (\n    ...\n) \n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/#define-fdb_using_fal_mode","title":"define FDB_USING_FAL_MODE","text":"<pre><code>#define FDB_USING_FAL_MODE \n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/#define-fdb_using_kvdb","title":"define FDB_USING_KVDB","text":"<pre><code>#define FDB_USING_KVDB \n</code></pre>"},{"location":"ltapi/fdb__cfg_8h/#define-fdb_write_gran","title":"define FDB_WRITE_GRAN","text":"<pre><code>#define FDB_WRITE_GRAN 8\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/flashdb/fdb_cfg.h</code></p>"},{"location":"ltapi/fdb__cfg_8h_source/","title":"File fdb_cfg.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; port &gt; flashdb &gt; fdb_cfg.h</p> <p>Go to the documentation of this file. </p> <pre><code>/*\n * Copyright (c) 2020, Armink, &lt;armink.ztl@gmail.com&gt;\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#ifndef _FDB_CFG_H_\n#define _FDB_CFG_H_\n\n/* using KVDB feature */\n#define FDB_USING_KVDB\n\n#ifdef FDB_USING_KVDB\n/* Auto update KV to latest default when current KVDB version number is changed. @see fdb_kvdb.ver_num */\n// #define FDB_KV_AUTO_UPDATE\n#endif\n\n/* using TSDB (Time series database) feature */\n// #define FDB_USING_TSDB\n\n/* Using FAL storage mode */\n#define FDB_USING_FAL_MODE\n\n#ifdef FDB_USING_FAL_MODE\n/* the flash write granularity, unit: bit\n * only support 1(nor flash)/ 8(stm32f2/f4)/ 32(stm32f1) */\n#define FDB_WRITE_GRAN 8\n#endif\n\n/* Using file storage mode by LIBC file API, like fopen/fread/fwrte/fclose */\n// #define FDB_USING_FILE_LIBC_MODE\n\n/* Using file storage mode by POSIX file API, like open/read/write/close */\n// #define FDB_USING_FILE_POSIX_MODE\n\n/* MCU Endian Configuration, default is Little Endian Order. */\n// #define FDB_BIG_ENDIAN\n\n#include &lt;printf_config.h&gt;\n\n#if LT_DEBUG_FDB\n#include &lt;printf/printf.h&gt;\n#define FDB_PRINT(...) __wrap_printf(__VA_ARGS__)\n#define FDB_DEBUG_ENABLE\n#else\n#define FDB_PRINT(...)\n#endif\n\n#endif /* _FDB_CFG_H_ */\n</code></pre>"},{"location":"ltapi/dir_d480c418faf0dacc52068ee6f00b9dec/","title":"Dir arduino/libretuya/port/printf","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; printf</p>"},{"location":"ltapi/dir_d480c418faf0dacc52068ee6f00b9dec/#files","title":"Files","text":"Type Name     file printf_config.h    file putchar.c    file puts.c      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/printf/</code></p>"},{"location":"ltapi/printf__config_8h/","title":"File printf_config.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; printf &gt; printf_config.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;LibreTuyaConfig.h&gt;</code></li> </ul>"},{"location":"ltapi/printf__config_8h/#public-functions","title":"Public Functions","text":"Type Name     void putchar_p (char c, unsigned long port)"},{"location":"ltapi/printf__config_8h/#macros","title":"Macros","text":"Type Name     define PRINTF_HAS_DISABLE  1   define WRAP_DISABLE_CHECK (name)    define WRAP_DISABLE_DECL (name)    define WRAP_DISABLE_DEF (name)    define WRAP_PRINTF (name)    define WRAP_SNPRINTF (name)    define WRAP_SPRINTF (name)    define WRAP_VPRINTF (name)    define WRAP_VSNPRINTF (name)    define WRAP_VSPRINTF (name)    define printf_  __wrap_printf   define snprintf_  __wrap_snprintf   define sprintf_  __wrap_sprintf   define vprintf_  __wrap_vprintf   define vsnprintf_  __wrap_vsnprintf   define vsprintf_  __wrap_vsprintf"},{"location":"ltapi/printf__config_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/printf__config_8h/#function-putchar_p","title":"function putchar_p","text":"<pre><code>void putchar_p (\n    char c,\n    unsigned long port\n) \n</code></pre>"},{"location":"ltapi/printf__config_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"ltapi/printf__config_8h/#define-printf_has_disable","title":"define PRINTF_HAS_DISABLE","text":"<pre><code>#define PRINTF_HAS_DISABLE 1\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_disable_check","title":"define WRAP_DISABLE_CHECK","text":"<pre><code>#define WRAP_DISABLE_CHECK (\n    name\n) {                                                                                                                  \\\n        if (LT_UART_SILENT_ALL)                                                                                        \\\n            return 0;                                                                                                  \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_disable_decl","title":"define WRAP_DISABLE_DECL","text":"<pre><code>#define WRAP_DISABLE_DECL (\n    name\n) void __wrap_##name##_disable() {}                                                                                  \\\n    void __wrap_##name##_enable() {}                                                                                   \\\n    void __wrap_##name##_set(unsigned char disabled) {}                                                                \\\n    unsigned char __wrap_##name##_get() {                                                                              \\\n        return LT_UART_SILENT_ALL;                                                                                     \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_disable_def","title":"define WRAP_DISABLE_DEF","text":"<pre><code>#define WRAP_DISABLE_DEF (\n    name\n) extern void __wrap_##name##_disable();                                                                             \\\n    extern void __wrap_##name##_enable();                                                                              \\\n    extern void __wrap_##name##_set(unsigned char disabled);                                                           \\\n    extern unsigned char __wrap_##name##_get();\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_printf","title":"define WRAP_PRINTF","text":"<pre><code>#define WRAP_PRINTF (\n    name\n) WRAP_DISABLE_DECL(name)                                                                                            \\\n    int __wrap_##name(const char *format, ...) {                                                                       \\\n        WRAP_DISABLE_CHECK(name);                                                                                      \\\n        va_list va;                                                                                                    \\\n        va_start(va, format);                                                                                          \\\n        const int ret = vprintf(format, va);                                                                           \\\n        va_end(va);                                                                                                    \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_snprintf","title":"define WRAP_SNPRINTF","text":"<pre><code>#define WRAP_SNPRINTF (\n    name\n) int __wrap_##name(char *s, size_t count, const char *format, ...) {                                                \\\n        va_list va;                                                                                                    \\\n        va_start(va, format);                                                                                          \\\n        const int ret = vsnprintf(s, count, format, va);                                                               \\\n        va_end(va);                                                                                                    \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_sprintf","title":"define WRAP_SPRINTF","text":"<pre><code>#define WRAP_SPRINTF (\n    name\n) int __wrap_##name(char *s, const char *format, ...) {                                                              \\\n        va_list va;                                                                                                    \\\n        va_start(va, format);                                                                                          \\\n        const int ret = vsprintf(s, format, va);                                                                       \\\n        va_end(va);                                                                                                    \\\n        return ret;                                                                                                    \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_vprintf","title":"define WRAP_VPRINTF","text":"<pre><code>#define WRAP_VPRINTF (\n    name\n) WRAP_DISABLE_DECL(name)                                                                                            \\\n    int __wrap_##name(const char *format, va_list arg) {                                                               \\\n        WRAP_DISABLE_CHECK(name);                                                                                      \\\n        return vprintf(format, arg);                                                                                   \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_vsnprintf","title":"define WRAP_VSNPRINTF","text":"<pre><code>#define WRAP_VSNPRINTF (\n    name\n) int __wrap_##name(char *s, size_t count, const char *format, va_list arg) {                                        \\\n        return vsnprintf(s, count, format, arg);                                                                       \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-wrap_vsprintf","title":"define WRAP_VSPRINTF","text":"<pre><code>#define WRAP_VSPRINTF (\n    name\n) int __wrap_##name(char *s, const char *format, va_list arg) {                                                      \\\n        return vsprintf(s, format, arg);                                                                               \\\n    }\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-printf_","title":"define printf_","text":"<pre><code>#define printf_ __wrap_printf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-snprintf_","title":"define snprintf_","text":"<pre><code>#define snprintf_ __wrap_snprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-sprintf_","title":"define sprintf_","text":"<pre><code>#define sprintf_ __wrap_sprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-vprintf_","title":"define vprintf_","text":"<pre><code>#define vprintf_ __wrap_vprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-vsnprintf_","title":"define vsnprintf_","text":"<pre><code>#define vsnprintf_ __wrap_vsnprintf\n</code></pre>"},{"location":"ltapi/printf__config_8h/#define-vsprintf_","title":"define vsprintf_","text":"<pre><code>#define vsprintf_ __wrap_vsprintf\n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/printf/printf_config.h</code></p>"},{"location":"ltapi/printf__config_8h_source/","title":"File printf_config.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; port &gt; printf &gt; printf_config.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-06-19. */\n\n#pragma once\n\n#include &lt;LibreTuyaConfig.h&gt;\n\n#define PRINTF_HAS_DISABLE 1\n\n// make printf.c define wrapper functions\n#define printf_    __wrap_printf\n#define sprintf_   __wrap_sprintf\n#define vsprintf_  __wrap_vsprintf\n#define snprintf_  __wrap_snprintf\n#define vsnprintf_ __wrap_vsnprintf\n#define vprintf_   __wrap_vprintf\n\n// declare putchar() method with custom output port\nvoid putchar_p(char c, unsigned long port);\n\n#define WRAP_DISABLE_DEF(name)                                                                                         \\\n    extern void __wrap_##name##_disable();                                                                             \\\n    extern void __wrap_##name##_enable();                                                                              \\\n    extern void __wrap_##name##_set(unsigned char disabled);                                                           \\\n    extern unsigned char __wrap_##name##_get();\n\n#if !LT_UART_SILENT_ENABLED || LT_UART_SILENT_ALL\n\n#define WRAP_DISABLE_DECL(name)                                                                                        \\\n    void __wrap_##name##_disable() {}                                                                                  \\\n    void __wrap_##name##_enable() {}                                                                                   \\\n    void __wrap_##name##_set(unsigned char disabled) {}                                                                \\\n    unsigned char __wrap_##name##_get() {                                                                              \\\n        return LT_UART_SILENT_ALL;                                                                                     \\\n    }\n\n#define WRAP_DISABLE_CHECK(name)                                                                                       \\\n    {                                                                                                                  \\\n        if (LT_UART_SILENT_ALL)                                                                                        \\\n            return 0;                                                                                                  \\\n    }\n\n#else // LT_UART_SILENT_ENABLED &amp;&amp; !LT_UART_SILENT_ALL\n\n#define WRAP_DISABLE_DECL(name)                                                                                        \\\n    static unsigned char __wrap_##name##_disabled = 0;                                                                 \\\n    void __wrap_##name##_disable() {                                                                                   \\\n        __wrap_##name##_disabled = 1;                                                                                  \\\n    }                                                                                                                  \\\n    void __wrap_##name##_enable() {                                                                                    \\\n        __wrap_##name##_disabled = 0;                                                                                  \\\n    }                                                                                                                  \\\n    void __wrap_##name##_set(unsigned char disabled) {                                                                 \\\n        __wrap_##name##_disabled = disabled;                                                                           \\\n    }                                                                                                                  \\\n    unsigned char __wrap_##name##_get() {                                                                              \\\n        return __wrap_##name##_disabled;                                                                               \\\n    }\n\n#define WRAP_DISABLE_CHECK(name)                                                                                       \\\n    {                                                                                                                  \\\n        if (__wrap_##name##_disabled)                                                                                  \\\n            return 0;                                                                                                  \\\n    }\n\n#endif // LT_UART_SILENT_ENABLED &amp;&amp; !LT_UART_SILENT_ALL\n\n#if LT_UART_SILENT_ALL\n\n#define WRAP_PRINTF(name)                                                                                              \\\n    WRAP_DISABLE_DECL(name)                                                                                            \\\n    int __wrap_##name(const char *format, ...) {                                                                       \\\n        return 0;                                                                                                      \\\n    }\n\n#define WRAP_VPRINTF(name)                                                                                             \\\n    WRAP_DISABLE_DECL(name)                                                                                            \\\n    int __wrap_##name(const char *format, va_list arg) {                                                               \\\n        return 0;                                                                                                      \\\n    }\n\n#else // !LT_UART_SILENT_ALL\n\n#define WRAP_PRINTF(name)                                                                                              \\\n    WRAP_DISABLE_DECL(name)                                                                                            \\\n    int __wrap_##name(const char *format, ...) {                                                                       \\\n        WRAP_DISABLE_CHECK(name);                                                                                      \\\n        va_list va;                                                                                                    \\\n        va_start(va, format);                                                                                          \\\n        const int ret = vprintf(format, va);                                                                           \\\n        va_end(va);                                                                                                    \\\n        return ret;                                                                                                    \\\n    }\n\n#define WRAP_VPRINTF(name)                                                                                             \\\n    WRAP_DISABLE_DECL(name)                                                                                            \\\n    int __wrap_##name(const char *format, va_list arg) {                                                               \\\n        WRAP_DISABLE_CHECK(name);                                                                                      \\\n        return vprintf(format, arg);                                                                                   \\\n    }\n\n#endif // !LT_UART_SILENT_ALL\n\n#define WRAP_SPRINTF(name)                                                                                             \\\n    int __wrap_##name(char *s, const char *format, ...) {                                                              \\\n        va_list va;                                                                                                    \\\n        va_start(va, format);                                                                                          \\\n        const int ret = vsprintf(s, format, va);                                                                       \\\n        va_end(va);                                                                                                    \\\n        return ret;                                                                                                    \\\n    }\n\n#define WRAP_SNPRINTF(name)                                                                                            \\\n    int __wrap_##name(char *s, size_t count, const char *format, ...) {                                                \\\n        va_list va;                                                                                                    \\\n        va_start(va, format);                                                                                          \\\n        const int ret = vsnprintf(s, count, format, va);                                                               \\\n        va_end(va);                                                                                                    \\\n        return ret;                                                                                                    \\\n    }\n\n#define WRAP_VSPRINTF(name)                                                                                            \\\n    int __wrap_##name(char *s, const char *format, va_list arg) {                                                      \\\n        return vsprintf(s, format, arg);                                                                               \\\n    }\n\n#define WRAP_VSNPRINTF(name)                                                                                           \\\n    int __wrap_##name(char *s, size_t count, const char *format, va_list arg) {                                        \\\n        return vsnprintf(s, count, format, arg);                                                                       \\\n    }\n</code></pre>"},{"location":"ltapi/putchar_8c/","title":"File putchar.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; printf &gt; putchar.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;printf/printf.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"ltapi/putchar_8c/#public-functions","title":"Public Functions","text":"Type Name     int __wrap_putchar (int c)"},{"location":"ltapi/putchar_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/putchar_8c/#function-__wrap_putchar","title":"function __wrap_putchar","text":"<pre><code>int __wrap_putchar (\n    int c\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/printf/putchar.c</code></p>"},{"location":"ltapi/putchar_8c_source/","title":"File putchar.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; port &gt; printf &gt; putchar.c</p> <p>Go to the documentation of this file. </p> <pre><code>// https://github.com/embeddedartistry/libc/blob/master/src/stdio/putchar.c\n\n#include &lt;printf/printf.h&gt;\n#include &lt;stdio.h&gt;\n\nint __wrap_putchar(int c) {\n    putchar_((char)c);\n    return c;\n}\n</code></pre>"},{"location":"ltapi/puts_8c/","title":"File puts.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; port &gt; printf &gt; puts.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;printf/printf.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> </ul>"},{"location":"ltapi/puts_8c/#public-functions","title":"Public Functions","text":"Type Name     int __wrap_puts (const char * str)"},{"location":"ltapi/puts_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/puts_8c/#function-__wrap_puts","title":"function __wrap_puts","text":"<pre><code>int __wrap_puts (\n    const char * str\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/port/printf/puts.c</code></p>"},{"location":"ltapi/puts_8c_source/","title":"File puts.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; port &gt; printf &gt; puts.c</p> <p>Go to the documentation of this file. </p> <pre><code>// https://github.com/embeddedartistry/libc/blob/master/src/stdio/puts.c\n\n#include &lt;printf/printf.h&gt;\n#include &lt;stdio.h&gt;\n\nint __wrap_puts(const char *str) {\n    int r = 0;\n\n    for (const char *c = str; *c != 0; c++) {\n        putchar_((int)*c);\n        r++;\n    }\n\n    // puts adds a newline\n    if (r) {\n        putchar_('\\n');\n        r++;\n    }\n\n    return r ? r : EOF;\n}\n</code></pre>"},{"location":"ltapi/dir_453ad2089eb8caa596dcdb96c498cad1/","title":"Dir arduino/libretuya/posix","text":"<p>FileList &gt; arduino &gt; libretuya &gt; posix</p>"},{"location":"ltapi/dir_453ad2089eb8caa596dcdb96c498cad1/#files","title":"Files","text":"Type Name     file lt_posix_api.h    file strcasecmp.c    file strdup.c    file time.c      <p>The documentation for this class was generated from the following file <code>arduino/libretuya/posix/</code></p>"},{"location":"ltapi/lt__posix__api_8h/","title":"File lt_posix_api.h","text":"<p>FileList &gt; arduino &gt; libretuya &gt; posix &gt; lt_posix_api.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;sys/time.h&gt;</code></li> </ul>"},{"location":"ltapi/lt__posix__api_8h/#public-functions","title":"Public Functions","text":"Type Name     int strcasecmp (const char * s1, const char * s2)    char * strdup (const char *)    int strncasecmp (const char * s1, const char * s2, size_t n)"},{"location":"ltapi/lt__posix__api_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/lt__posix__api_8h/#function-strcasecmp","title":"function strcasecmp","text":"<pre><code>int strcasecmp (\n    const char * s1,\n    const char * s2\n) \n</code></pre>"},{"location":"ltapi/lt__posix__api_8h/#function-strdup","title":"function strdup","text":"<pre><code>char * strdup (\n    const char *\n) \n</code></pre>"},{"location":"ltapi/lt__posix__api_8h/#function-strncasecmp","title":"function strncasecmp","text":"<pre><code>int strncasecmp (\n    const char * s1,\n    const char * s2,\n    size_t n\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/posix/lt_posix_api.h</code></p>"},{"location":"ltapi/lt__posix__api_8h_source/","title":"File lt_posix_api.h","text":"<p>File List &gt; arduino &gt; libretuya &gt; posix &gt; lt_posix_api.h</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-16. */\n\n#include &lt;sys/time.h&gt;\n\nextern char *strdup(const char *);\nextern int strcasecmp(const char *s1, const char *s2);\nextern int strncasecmp(const char *s1, const char *s2, size_t n);\n</code></pre>"},{"location":"ltapi/strcasecmp_8c/","title":"File strcasecmp.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; posix &gt; strcasecmp.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"ltapi/strcasecmp_8c/#public-types","title":"Public Types","text":"Type Name     typedef unsigned char u_char"},{"location":"ltapi/strcasecmp_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     const u_char charmap"},{"location":"ltapi/strcasecmp_8c/#public-functions","title":"Public Functions","text":"Type Name     int strcasecmp (const char * s1, const char * s2)    int strncasecmp (const char * s1, const char * s2, size_t n)"},{"location":"ltapi/strcasecmp_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"ltapi/strcasecmp_8c/#typedef-u_char","title":"typedef u_char","text":"<pre><code>typedef unsigned char u_char;\n</code></pre>"},{"location":"ltapi/strcasecmp_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/strcasecmp_8c/#variable-charmap","title":"variable charmap","text":"<pre><code>const u_char charmap[];\n</code></pre>"},{"location":"ltapi/strcasecmp_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strcasecmp_8c/#function-strcasecmp","title":"function strcasecmp","text":"<pre><code>int strcasecmp (\n    const char * s1,\n    const char * s2\n) \n</code></pre>"},{"location":"ltapi/strcasecmp_8c/#function-strncasecmp","title":"function strncasecmp","text":"<pre><code>int strncasecmp (\n    const char * s1,\n    const char * s2,\n    size_t n\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/posix/strcasecmp.c</code></p>"},{"location":"ltapi/strcasecmp_8c_source/","title":"File strcasecmp.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; posix &gt; strcasecmp.c</p> <p>Go to the documentation of this file. </p> <pre><code>/*  $OpenBSD: strcasecmp.c,v 1.6 2005/08/08 08:05:37 espie Exp $    */\n/*\n * Copyright (c) 1987, 1993\n *  The Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include &lt;string.h&gt;\ntypedef unsigned char u_char;\n/*\n * This array is designed for mapping upper and lower case letter\n * together for a case independent comparison.  The mappings are\n * based upon ascii character sequences.\n */\nstatic const u_char charmap[] = {\n    '\\000', '\\001', '\\002', '\\003', '\\004', '\\005', '\\006', '\\007',\n    '\\010', '\\011', '\\012', '\\013', '\\014', '\\015', '\\016', '\\017',\n    '\\020', '\\021', '\\022', '\\023', '\\024', '\\025', '\\026', '\\027',\n    '\\030', '\\031', '\\032', '\\033', '\\034', '\\035', '\\036', '\\037',\n    '\\040', '\\041', '\\042', '\\043', '\\044', '\\045', '\\046', '\\047',\n    '\\050', '\\051', '\\052', '\\053', '\\054', '\\055', '\\056', '\\057',\n    '\\060', '\\061', '\\062', '\\063', '\\064', '\\065', '\\066', '\\067',\n    '\\070', '\\071', '\\072', '\\073', '\\074', '\\075', '\\076', '\\077',\n    '\\100', '\\141', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n    '\\150', '\\151', '\\152', '\\153', '\\154', '\\155', '\\156', '\\157',\n    '\\160', '\\161', '\\162', '\\163', '\\164', '\\165', '\\166', '\\167',\n    '\\170', '\\171', '\\172', '\\133', '\\134', '\\135', '\\136', '\\137',\n    '\\140', '\\141', '\\142', '\\143', '\\144', '\\145', '\\146', '\\147',\n    '\\150', '\\151', '\\152', '\\153', '\\154', '\\155', '\\156', '\\157',\n    '\\160', '\\161', '\\162', '\\163', '\\164', '\\165', '\\166', '\\167',\n    '\\170', '\\171', '\\172', '\\173', '\\174', '\\175', '\\176', '\\177',\n    '\\200', '\\201', '\\202', '\\203', '\\204', '\\205', '\\206', '\\207',\n    '\\210', '\\211', '\\212', '\\213', '\\214', '\\215', '\\216', '\\217',\n    '\\220', '\\221', '\\222', '\\223', '\\224', '\\225', '\\226', '\\227',\n    '\\230', '\\231', '\\232', '\\233', '\\234', '\\235', '\\236', '\\237',\n    '\\240', '\\241', '\\242', '\\243', '\\244', '\\245', '\\246', '\\247',\n    '\\250', '\\251', '\\252', '\\253', '\\254', '\\255', '\\256', '\\257',\n    '\\260', '\\261', '\\262', '\\263', '\\264', '\\265', '\\266', '\\267',\n    '\\270', '\\271', '\\272', '\\273', '\\274', '\\275', '\\276', '\\277',\n    '\\300', '\\301', '\\302', '\\303', '\\304', '\\305', '\\306', '\\307',\n    '\\310', '\\311', '\\312', '\\313', '\\314', '\\315', '\\316', '\\317',\n    '\\320', '\\321', '\\322', '\\323', '\\324', '\\325', '\\326', '\\327',\n    '\\330', '\\331', '\\332', '\\333', '\\334', '\\335', '\\336', '\\337',\n    '\\340', '\\341', '\\342', '\\343', '\\344', '\\345', '\\346', '\\347',\n    '\\350', '\\351', '\\352', '\\353', '\\354', '\\355', '\\356', '\\357',\n    '\\360', '\\361', '\\362', '\\363', '\\364', '\\365', '\\366', '\\367',\n    '\\370', '\\371', '\\372', '\\373', '\\374', '\\375', '\\376', '\\377',\n};\nint\nstrcasecmp(const char *s1, const char *s2)\n{\n    const u_char *cm = charmap;\n    const u_char *us1 = (const u_char *)s1;\n    const u_char *us2 = (const u_char *)s2;\n    while (cm[*us1] == cm[*us2++])\n        if (*us1++ == '\\0')\n            return (0);\n    return (cm[*us1] - cm[*--us2]);\n}\nint\nstrncasecmp(const char *s1, const char *s2, size_t n)\n{\n    if (n != 0) {\n        const u_char *cm = charmap;\n        const u_char *us1 = (const u_char *)s1;\n        const u_char *us2 = (const u_char *)s2;\n        do {\n            if (cm[*us1] != cm[*us2++])\n                return (cm[*us1] - cm[*--us2]);\n            if (*us1++ == '\\0')\n                break;\n        } while (--n != 0);\n    }\n    return (0);\n}\n</code></pre>"},{"location":"ltapi/strdup_8c/","title":"File strdup.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; posix &gt; strdup.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;sdk_mem.h&gt;</code></li> </ul>"},{"location":"ltapi/strdup_8c/#public-functions","title":"Public Functions","text":"Type Name      __attribute__ ((weak))"},{"location":"ltapi/strdup_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/strdup_8c/#function-__attribute__","title":"function __attribute__","text":"<pre><code>__attribute__ (\n    (weak)\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/posix/strdup.c</code></p>"},{"location":"ltapi/strdup_8c_source/","title":"File strdup.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; posix &gt; strdup.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-05-16. */\n\n#include &lt;stddef.h&gt;\n#include &lt;sdk_mem.h&gt;\n\n__attribute__((weak)) char *strdup(const char *s) {\n    size_t len = strlen(s) + 1;\n    void *newp = malloc(len);\n    if (newp == NULL)\n        return NULL;\n    return (char *)memcpy(newp, s, len);\n}\n</code></pre>"},{"location":"ltapi/time_8c/","title":"File time.c","text":"<p>FileList &gt; arduino &gt; libretuya &gt; posix &gt; time.c</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;Arduino.h&gt;</code></li> <li><code>#include &lt;errno.h&gt;</code></li> </ul>"},{"location":"ltapi/time_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name     uint32_t reset_epoch   = = 0   uint32_t reset_millis   = = 0"},{"location":"ltapi/time_8c/#public-functions","title":"Public Functions","text":"Type Name     int __wrap_gettimeofday (struct timeval * tv, void * tz)    int __wrap_settimeofday (const struct timeval * tv, const struct timezone * tz)    int _gettimeofday (struct timeval * tv, void * tz)    int _settimeofday (const struct timeval * tv, const struct timezone * tz)    int gettimeofday (struct timeval * tv, void * tz)    int settimeofday (const struct timeval * tv, const struct timezone * tz)"},{"location":"ltapi/time_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"ltapi/time_8c/#variable-reset_epoch","title":"variable reset_epoch","text":"<pre><code>uint32_t reset_epoch;\n</code></pre>"},{"location":"ltapi/time_8c/#variable-reset_millis","title":"variable reset_millis","text":"<pre><code>uint32_t reset_millis;\n</code></pre>"},{"location":"ltapi/time_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"ltapi/time_8c/#function-__wrap_gettimeofday","title":"function __wrap_gettimeofday","text":"<pre><code>int __wrap_gettimeofday (\n    struct timeval * tv,\n    void * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-__wrap_settimeofday","title":"function __wrap_settimeofday","text":"<pre><code>int __wrap_settimeofday (\n    const struct timeval * tv,\n    const struct timezone * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-_gettimeofday","title":"function _gettimeofday","text":"<pre><code>int _gettimeofday (\n    struct timeval * tv,\n    void * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-_settimeofday","title":"function _settimeofday","text":"<pre><code>int _settimeofday (\n    const struct timeval * tv,\n    const struct timezone * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-gettimeofday","title":"function gettimeofday","text":"<pre><code>int gettimeofday (\n    struct timeval * tv,\n    void * tz\n) \n</code></pre>"},{"location":"ltapi/time_8c/#function-settimeofday","title":"function settimeofday","text":"<pre><code>int settimeofday (\n    const struct timeval * tv,\n    const struct timezone * tz\n) \n</code></pre>  <p>The documentation for this class was generated from the following file <code>arduino/libretuya/posix/time.c</code></p>"},{"location":"ltapi/time_8c_source/","title":"File time.c","text":"<p>File List &gt; arduino &gt; libretuya &gt; posix &gt; time.c</p> <p>Go to the documentation of this file. </p> <pre><code>/* Copyright (c) Kuba Szczodrzy\u0144ski 2022-09-03. */\n\n#include &lt;Arduino.h&gt;\n#include &lt;errno.h&gt;\n\nstatic uint32_t reset_epoch  = 0; // epoch corresponding to millis() == 0\nstatic uint32_t reset_millis = 0; // millis() when epoch reset was performed\n\nint __wrap_gettimeofday(struct timeval *tv, void *tz) {\n    if (millis() &lt; reset_millis) {\n        // the clock overflowed\n        reset_epoch += UINT32_MAX / 1000;\n        reset_millis = millis();\n    }\n    if (!tv) {\n        errno = EINVAL;\n        return -1;\n    }\n    unsigned long m = millis();\n    tv-&gt;tv_sec      = reset_epoch + (m / 1000);\n    tv-&gt;tv_usec     = (m % 1000) * 1000;\n    return 0;\n}\n\nint __wrap_settimeofday(const struct timeval *tv, const struct timezone *tz) {\n    if (!tv) {\n        errno = EINVAL;\n        return -1;\n    }\n    unsigned long m = millis();\n    reset_epoch     = tv-&gt;tv_sec - (m / 1000);\n    reset_millis    = m;\n    return 0;\n}\n\nint gettimeofday(struct timeval *tv, void *tz) {\n    return __wrap_gettimeofday(tv, tz);\n}\n\nint settimeofday(const struct timeval *tv, const struct timezone *tz) {\n    return __wrap_settimeofday(tv, tz);\n}\n\nint _gettimeofday(struct timeval *tv, void *tz) {\n    return __wrap_gettimeofday(tv, tz);\n}\n\nint _settimeofday(const struct timeval *tv, const struct timezone *tz) {\n    return __wrap_settimeofday(tv, tz);\n}\n</code></pre>"},{"location":"ltapi/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace arduino </li> <li>namespace fs </li> <li>namespace mime </li> </ul>"},{"location":"ltapi/classes/","title":"Class Index","text":""},{"location":"ltapi/classes/#a","title":"a","text":"<ul> <li>arduino_event_t</li> </ul>"},{"location":"ltapi/classes/#b","title":"b","text":"<ul> <li>base64</li> <li>base64_decodestate</li> <li>base64_encodestate</li> </ul>"},{"location":"ltapi/classes/#c","title":"c","text":"<ul> <li>cbuf</li> <li>Cookie</li> </ul>"},{"location":"ltapi/classes/#e","title":"e","text":"<ul> <li>EventHandler_s</li> <li>esp_ip4_addr</li> <li>esp_ip6_addr</li> <li>esp_netif_ip6_info_t</li> <li>esp_netif_ip_info_t</li> <li>Entry (mime)</li> </ul>"},{"location":"ltapi/classes/#f","title":"f","text":"<ul> <li>FlashClass</li> <li>FunctionRequestHandler</li> <li>FS (fs)</li> <li>FSImpl (fs)</li> <li>File (fs)</li> <li>FileImpl (fs)</li> <li>FlashId</li> </ul>"},{"location":"ltapi/classes/#h","title":"h","text":"<ul> <li>HTTPClient</li> <li>HTTPUpload</li> </ul>"},{"location":"ltapi/classes/#i","title":"i","text":"<ul> <li>IPreferences</li> <li>ITwoWire</li> <li>IWiFiClient</li> <li>IWiFiClientSecure</li> <li>IWiFiServer</li> <li>IWiFiUDP</li> <li>IPv6Address (arduino)</li> <li>ip_event_ap_staipassigned_t</li> <li>ip_event_got_ip6_t</li> <li>ip_event_got_ip_t</li> </ul>"},{"location":"ltapi/classes/#l","title":"l","text":"<ul> <li>LibreTuya</li> <li>LwIPClient</li> <li>LwIPRxBuffer</li> <li>LwIPServer</li> <li>LwIPUDP</li> </ul>"},{"location":"ltapi/classes/#m","title":"m","text":"<ul> <li>MbedTLSClient</li> <li>mDNS</li> </ul>"},{"location":"ltapi/classes/#p","title":"p","text":"<ul> <li>PinInfo</li> </ul>"},{"location":"ltapi/classes/#r","title":"r","text":"<ul> <li>RequestHandler</li> <li>RequestArgument (HTTPClient)</li> <li>RequestArgument (WebServer)</li> </ul>"},{"location":"ltapi/classes/#s","title":"s","text":"<ul> <li>StaticRequestHandler</li> <li>StreamString</li> </ul>"},{"location":"ltapi/classes/#u","title":"u","text":"<ul> <li>UpdateClass</li> <li>Uri</li> <li>UriBraces</li> <li>UriGlob</li> <li>UriRegex</li> </ul>"},{"location":"ltapi/classes/#w","title":"w","text":"<ul> <li>WebServer</li> <li>WiFiClass</li> <li>WiFiMulti</li> <li>WiFiMacAddr</li> <li>WiFiScanAP</li> <li>WiFiScanData</li> <li>WifiAPlist_t</li> <li>wifi_event_action_tx_status_t</li> <li>wifi_event_ap_probe_req_rx_t</li> <li>wifi_event_ap_staconnected_t</li> <li>wifi_event_ap_stadisconnected_t</li> <li>wifi_event_ftm_report_t</li> <li>wifi_event_roc_done_t</li> <li>wifi_event_sta_authmode_change_t</li> <li>wifi_event_sta_connected_t</li> <li>wifi_event_sta_disconnected_t</li> <li>wifi_event_sta_scan_done_t</li> <li>wifi_event_sta_wps_er_pin_t</li> <li>wifi_event_sta_wps_er_success_t</li> <li>wifi_ftm_report_entry_t</li> </ul>"},{"location":"ltapi/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class FlashClass </li> <li>class RequestHandler </li> <li>class FunctionRequestHandler </li> <li>class StaticRequestHandler </li> <li>class HTTPClient </li> <li>class IPreferences </li> <li>class IWiFiClientSecure </li> <li>class MbedTLSClient </li> <li>class LibreTuya Main LibreTuya API class.</li> <li>class LwIPRxBuffer </li> <li>class UpdateClass </li> <li>class Uri </li> <li>class UriBraces </li> <li>class UriGlob </li> <li>class UriRegex </li> <li>class WebServer </li> <li>class WiFiClass </li> <li>class WiFiMulti </li> <li>class base64 </li> <li>class cbuf </li> <li>class fs::FS </li> <li>class fs::FSImpl </li> <li>class fs::FileImpl </li> <li>class mDNS </li> <li>struct Cookie </li> <li>struct EventHandler_s </li> <li>struct FlashId Flash chip ID structure. </li> <li>struct HTTPClient::RequestArgument </li> <li>struct HTTPUpload </li> <li>struct PinInfo </li> <li>struct WebServer::RequestArgument </li> <li>struct WiFiMacAddr </li> <li>struct WiFiScanAP </li> <li>struct WiFiScanData </li> <li>struct WifiAPlist_t </li> <li>struct arduino_event_t </li> <li>struct base64_decodestate </li> <li>struct base64_encodestate </li> <li>struct esp_ip4_addr </li> <li>struct esp_ip6_addr </li> <li>struct esp_netif_ip6_info_t IPV6 IP address information. </li> <li>struct esp_netif_ip_info_t </li> <li>struct ip_event_ap_staipassigned_t </li> <li>struct ip_event_got_ip6_t </li> <li>struct ip_event_got_ip_t </li> <li>struct mime::Entry </li> <li>struct wifi_event_action_tx_status_t </li> <li>struct wifi_event_ap_probe_req_rx_t </li> <li>struct wifi_event_ap_staconnected_t </li> <li>struct wifi_event_ap_stadisconnected_t </li> <li>struct wifi_event_ftm_report_t </li> <li>struct wifi_event_roc_done_t </li> <li>struct wifi_event_sta_authmode_change_t </li> <li>struct wifi_event_sta_connected_t </li> <li>struct wifi_event_sta_disconnected_t </li> <li>struct wifi_event_sta_scan_done_t </li> <li>struct wifi_event_sta_wps_er_pin_t </li> <li>struct wifi_event_sta_wps_er_success_t </li> <li>struct wifi_ftm_report_entry_t </li> <li>class Stream </li> <li>class ITwoWire </li> <li>class StreamString </li> <li>class fs::File </li> <li>class Client </li> <li>class IWiFiClient <ul> <li>class LwIPClient </li> </ul> </li> <li>class IWiFiClient <ul> <li>class LwIPClient </li> </ul> </li> <li>class Print </li> <li>class IWiFiServer </li> <li>class IWiFiServer </li> <li>class UDP </li> <li>class IWiFiUDP <ul> <li>class LwIPUDP </li> </ul> </li> <li>class IWiFiUDP <ul> <li>class LwIPUDP </li> </ul> </li> <li>class WiFiClient </li> <li>class MbedTLSClient </li> <li>class String </li> <li>class StreamString </li> <li>class Printable </li> <li>class arduino::IPv6Address </li> </ul>"},{"location":"ltapi/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"ltapi/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"ltapi/class_members/","title":"Class Members","text":""},{"location":"ltapi/class_members/#a","title":"a","text":"<ul> <li>addHeader (HTTPClient)</li> <li>available (ITwoWire, IWiFiServer, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File)</li> <li>accept (IWiFiServer, LwIPServer)</li> <li>abort (UpdateClass)</li> <li>addHandler (WebServer)</li> <li>arg (WebServer)</li> <li>argName (WebServer)</li> <li>args (WebServer)</li> <li>authenticate (WebServer)</li> <li>addr (WiFiMacAddr, esp_ip4_addr, esp_ip6_addr)</li> <li>APlist (WiFiMulti)</li> <li>addAP (WiFiMulti)</li> <li>auth (WiFiScanAP)</li> <li>ap (WiFiScanData)</li> <li>addService (mDNS)</li> <li>addServiceImpl (mDNS)</li> <li>addServiceTxt (mDNS)</li> <li>addServiceTxtImpl (mDNS)</li> <li>aid (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> <li>authmode (wifi_event_sta_connected_t)</li> <li>ap_cred (wifi_event_sta_wps_er_success_t)</li> <li>ap_cred_cnt (wifi_event_sta_wps_er_success_t)</li> </ul>"},{"location":"ltapi/class_members/#b","title":"b","text":"<ul> <li>begin (HTTPClient, IPreferences, ITwoWire, IWiFiServer, IWiFiUDP, LwIPServer, LwIPUDP, UpdateClass, WebServer, WiFiClass, mDNS)</li> <li>beginInternal (HTTPClient)</li> <li>buf (HTTPUpload, UpdateClass)</li> <li>beginTransmission (ITwoWire)</li> <li>beginMulticast (IWiFiUDP, LwIPUDP)</li> <li>beginMulticastPacket (IWiFiUDP, LwIPUDP)</li> <li>beginPacket (IWiFiUDP, LwIPUDP)</li> <li>bufAlloc (UpdateClass)</li> <li>bufLeft (UpdateClass)</li> <li>bufPos (UpdateClass)</li> <li>bufSize (UpdateClass)</li> <li>bytesTotal (UpdateClass)</li> <li>bytesWritten (UpdateClass)</li> <li>BSSID (WiFiClass)</li> <li>BSSIDstr (WiFiClass)</li> <li>broadcastIP (WiFiClass)</li> <li>bssid (WiFiScanAP, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>bytes (arduino::IPv6Address)</li> </ul>"},{"location":"ltapi/class_members/#c","title":"c","text":"<ul> <li>cb (EventHandler_s)</li> <li>chipId (FlashId)</li> <li>chipSizeId (FlashId)</li> <li>canHandle (FunctionRequestHandler, RequestHandler, StaticRequestHandler, Uri, UriBraces, UriGlob, UriRegex)</li> <li>canUpload (FunctionRequestHandler, RequestHandler)</li> <li>clear (HTTPClient, IPreferences)</li> <li>clearAllCookies (HTTPClient)</li> <li>collectHeaders (HTTPClient, WebServer)</li> <li>connect (HTTPClient, IWiFiClient, IWiFiClientSecure, LwIPClient, MbedTLSClient)</li> <li>connected (HTTPClient, LwIPClient)</li> <li>currentSize (HTTPUpload)</li> <li>close (IWiFiServer, WebServer, fs::File, fs::FileImpl)</li> <li>callback (UpdateClass)</li> <li>canRollBack (UpdateClass)</li> <li>checkUf2Error (UpdateClass)</li> <li>cleanup (UpdateClass)</li> <li>clearError (UpdateClass)</li> <li>ctx (UpdateClass)</li> <li>clone (Uri, UriBraces, UriGlob, UriRegex)</li> <li>client (WebServer)</li> <li>calculateBroadcast (WiFiClass)</li> <li>calculateNetworkID (WiFiClass)</li> <li>calculateSubnetCIDR (WiFiClass)</li> <li>channel (WiFiClass, WiFiScanAP, wifi_event_sta_connected_t)</li> <li>config (WiFiClass)</li> <li>count (WiFiScanData)</li> <li>cbuf (cbuf)</li> <li>context (wifi_event_action_tx_status_t, wifi_event_roc_done_t)</li> </ul>"},{"location":"ltapi/class_members/#d","title":"d","text":"<ul> <li>date (Cookie)</li> <li>domain (Cookie)</li> <li>duration (Cookie)</li> <li>disconnect (HTTPClient, WiFiClass)</li> <li>dataFree (WiFiClass)</li> <li>dataInitialize (WiFiClass)</li> <li>dnsIP (WiFiClass)</li> <li>dword (arduino::IPv6Address)</li> <li>da (wifi_event_action_tx_status_t)</li> <li>dist_est (wifi_event_ftm_report_t)</li> <li>dlog_token (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_members/#e","title":"e","text":"<ul> <li>expires (Cookie)</li> <li>EventHandler_s (EventHandler_s)</li> <li>eventId (EventHandler_s)</li> <li>eraseSector (FlashClass)</li> <li>end (HTTPClient, IPreferences, ITwoWire, IWiFiServer, LwIPServer, UpdateClass, mDNS)</li> <li>errorToString (HTTPClient)</li> <li>endTransmission (ITwoWire)</li> <li>endPacket (IWiFiUDP, LwIPUDP)</li> <li>enabled (PinInfo)</li> <li>errArd (UpdateClass)</li> <li>errUf2 (UpdateClass)</li> <li>errorString (UpdateClass)</li> <li>enableCORS (WebServer)</li> <li>enableCrossOrigin (WebServer)</li> <li>enableDelay (WebServer)</li> <li>enableAP (WiFiClass)</li> <li>enableIpV6 (WiFiClass)</li> <li>enableSTA (WiFiClass)</li> <li>encryptionType (WiFiClass)</li> <li>event_id (arduino_event_t)</li> <li>event_info (arduino_event_t)</li> <li>encode (base64)</li> <li>empty (cbuf)</li> <li>exists (fs::FS, fs::FSImpl)</li> <li>esp_netif (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>endsWith (mime::Entry)</li> </ul>"},{"location":"ltapi/class_members/#f","title":"f","text":"<ul> <li>fcb (EventHandler_s)</li> <li>FunctionRequestHandler (FunctionRequestHandler)</li> <li>filename (HTTPUpload)</li> <li>freeEntries (IPreferences)</li> <li>flush (ITwoWire, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>fd (IWiFiClient, LwIPClient)</li> <li>failed (LwIPRxBuffer)</li> <li>fillBuffer (LwIPRxBuffer)</li> <li>fromString (arduino::IPv6Address)</li> <li>full (cbuf)</li> <li>FS (fs::FS)</li> <li>FSImpl (fs::FSImpl)</li> <li>File (fs::File)</li> <li>ftm_report_data (wifi_event_ftm_report_t)</li> <li>ftm_report_num_entries (wifi_event_ftm_report_t)</li> </ul>"},{"location":"ltapi/class_members/#g","title":"g","text":"<ul> <li>getChipId (FlashClass, LibreTuya)</li> <li>getSize (FlashClass, HTTPClient)</li> <li>GET (HTTPClient)</li> <li>generateCookieString (HTTPClient)</li> <li>getLocation (HTTPClient)</li> <li>getStream (HTTPClient)</li> <li>getStreamPtr (HTTPClient)</li> <li>getBool (IPreferences)</li> <li>getBytes (IPreferences)</li> <li>getBytesLength (IPreferences)</li> <li>getChar (IPreferences)</li> <li>getDouble (IPreferences)</li> <li>getFloat (IPreferences)</li> <li>getInt (IPreferences)</li> <li>getLong (IPreferences)</li> <li>getLong64 (IPreferences)</li> <li>getShort (IPreferences)</li> <li>getString (IPreferences)</li> <li>getType (IPreferences)</li> <li>getUChar (IPreferences)</li> <li>getUInt (IPreferences)</li> <li>getULong (IPreferences)</li> <li>getULong64 (IPreferences)</li> <li>getUShort (IPreferences)</li> <li>getClock (ITwoWire)</li> <li>getFingerprintSHA256 (IWiFiClientSecure, MbedTLSClient)</li> <li>getNoDelay (IWiFiServer, LwIPServer)</li> <li>getBoard (LibreTuya)</li> <li>getChipCoreType (LibreTuya)</li> <li>getChipCores (LibreTuya)</li> <li>getChipFamily (LibreTuya)</li> <li>getChipFamilyName (LibreTuya)</li> <li>getChipModel (LibreTuya)</li> <li>getChipType (LibreTuya)</li> <li>getCpuFreq (LibreTuya)</li> <li>getCpuFreqMHz (LibreTuya)</li> <li>getCycleCount (LibreTuya)</li> <li>getDeviceName (LibreTuya)</li> <li>getFlashChipId (LibreTuya)</li> <li>getFlashChipSize (LibreTuya)</li> <li>getFreeHeap (LibreTuya)</li> <li>getHeapSize (LibreTuya)</li> <li>getMaxAllocHeap (LibreTuya)</li> <li>getMaxFreeBlockSize (LibreTuya)</li> <li>getMinFreeHeap (LibreTuya)</li> <li>getRamSize (LibreTuya)</li> <li>getResetReason (LibreTuya)</li> <li>getResetReasonName (LibreTuya)</li> <li>getVersion (LibreTuya)</li> <li>gpioRecover (LibreTuya)</li> <li>gpio (PinInfo)</li> <li>getContentType (StaticRequestHandler)</li> <li>getBoardName (UpdateClass)</li> <li>getError (UpdateClass)</li> <li>getErrorCode (UpdateClass)</li> <li>getFirmwareName (UpdateClass)</li> <li>getFirmwareVersion (UpdateClass)</li> <li>getLibreTuyaVersion (UpdateClass)</li> <li>getUF2Error (UpdateClass)</li> <li>gatewayIP (WiFiClass)</li> <li>getAutoReconnect (WiFiClass)</li> <li>getEncryption (WiFiClass)</li> <li>getHostname (WiFiClass)</li> <li>getMode (WiFiClass)</li> <li>getNetworkInfo (WiFiClass)</li> <li>getSleep (WiFiClass)</li> <li>getTxPower (WiFiClass)</li> <li>gw (esp_netif_ip_info_t)</li> <li>getLastWrite (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_members/#h","title":"h","text":"<ul> <li>host (Cookie)</li> <li>http_only (Cookie)</li> <li>handle (FunctionRequestHandler, RequestHandler, StaticRequestHandler)</li> <li>HTTPClient (HTTPClient)</li> <li>handleHeaderResponse (HTTPClient)</li> <li>hasHeader (HTTPClient, WebServer)</li> <li>header (HTTPClient, WebServer)</li> <li>headerName (HTTPClient, WebServer)</li> <li>headers (HTTPClient, WebServer)</li> <li>hasClient (IWiFiServer, LwIPServer)</li> <li>hasError (UpdateClass)</li> <li>handleClient (WebServer)</li> <li>hasArg (WebServer)</li> <li>hostHeader (WebServer)</li> <li>handlers (WiFiClass)</li> <li>hostByName (WiFiClass)</li> <li>hostname (WiFiClass, mDNS)</li> <li>hasTxt (mDNS)</li> </ul>"},{"location":"ltapi/class_members/#i","title":"i","text":"<ul> <li>id (EventHandler_s)</li> <li>IPreferences (IPreferences)</li> <li>isKey (IPreferences)</li> <li>IWiFiClient (IWiFiClient)</li> <li>IWiFiServer (IWiFiServer)</li> <li>IWiFiUDP (IWiFiUDP)</li> <li>init (MbedTLSClient)</li> <li>info (UpdateClass)</li> <li>isFinished (UpdateClass)</li> <li>isRunning (UpdateClass)</li> <li>initPathArgs (Uri, UriBraces, UriRegex)</li> <li>isConnected (WiFiClass)</li> <li>IPv6Address (arduino::IPv6Address)</li> <li>ip (esp_netif_ip6_info_t, esp_netif_ip_info_t, ip_event_ap_staipassigned_t)</li> <li>isDirectory (fs::File, fs::FileImpl)</li> <li>if_index (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>ip6_info (ip_event_got_ip6_t)</li> <li>ip_index (ip_event_got_ip6_t)</li> <li>ip_changed (ip_event_got_ip_t)</li> <li>ip_info (ip_event_got_ip_t)</li> <li>IP (mDNS)</li> <li>IPv6 (mDNS)</li> <li>instanceName (mDNS)</li> <li>ifx (wifi_event_action_tx_status_t)</li> <li>is_mesh_child (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_members/#k","title":"k","text":"<ul> <li>key (HTTPClient::RequestArgument, WebServer::RequestArgument)</li> </ul>"},{"location":"ltapi/class_members/#l","title":"l","text":"<ul> <li>lastId (EventHandler_s)</li> <li>localIP (IWiFiClient, LwIPClient, WiFiClass)</li> <li>localPort (IWiFiClient, LwIPClient)</li> <li>lastError (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>loadPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>listenOnLocalhost (IWiFiServer)</li> <li>LwIPClient (LwIPClient)</li> <li>LwIPRxBuffer (LwIPRxBuffer)</li> <li>LwIPServer (LwIPServer)</li> <li>LwIPUDP (LwIPUDP)</li> <li>localIPv6 (WiFiClass)</li> </ul>"},{"location":"ltapi/class_members/#m","title":"m","text":"<ul> <li>max_age (Cookie)</li> <li>manufacturerId (FlashId)</li> <li>multicast_ip (LwIPUDP)</li> <li>MbedTLSClient (MbedTLSClient)</li> <li>mode (PinInfo, WiFiClass)</li> <li>md5 (UpdateClass)</li> <li>md5String (UpdateClass)</li> <li>method (WebServer)</li> <li>macAddress (WiFiClass)</li> <li>macToString (WiFiClass)</li> <li>modePriv (WiFiClass)</li> <li>mkdir (fs::FS, fs::FSImpl)</li> <li>mDNS (mDNS)</li> <li>mimeType (mime::Entry)</li> <li>mac (wifi_event_ap_probe_req_rx_t, wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_members/#n","title":"n","text":"<ul> <li>name (Cookie, HTTPUpload, fs::File, fs::FileImpl)</li> <li>next (RequestHandler, cbuf)</li> <li>networkID (WiFiClass)</li> <li>netmask (esp_netif_ip_info_t)</li> <li>numTxt (mDNS)</li> <li>new_mode (wifi_event_sta_authmode_change_t)</li> <li>number (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_members/#o","title":"o","text":"<ul> <li>onReceive (ITwoWire)</li> <li>onReceiveCallback (ITwoWire)</li> <li>onRequest (ITwoWire)</li> <li>onRequestCallback (ITwoWire)</li> <li>operator bool (IWiFiClient, IWiFiServer, LwIPServer, fs::File, fs::FileImpl)</li> <li>operator!= (IWiFiClient)</li> <li>operator== (IWiFiClient, arduino::IPv6Address)</li> <li>otaCanRollback (LibreTuya)</li> <li>otaGetRunning (LibreTuya)</li> <li>otaGetStoredIndex (LibreTuya)</li> <li>otaGetTarget (LibreTuya)</li> <li>otaHasImage1 (LibreTuya)</li> <li>otaHasImage2 (LibreTuya)</li> <li>otaRollback (LibreTuya)</li> <li>otaSupportsDual (LibreTuya)</li> <li>otaSwitch (LibreTuya)</li> <li>operator= (LwIPClient, arduino::IPv6Address)</li> <li>onProgress (UpdateClass)</li> <li>on (WebServer)</li> <li>onFileUpload (WebServer)</li> <li>onNotFound (WebServer)</li> <li>onEvent (WiFiClass)</li> <li>operator const uint32_t * (arduino::IPv6Address)</li> <li>operator const uint8_t * (arduino::IPv6Address)</li> <li>operator[] (arduino::IPv6Address)</li> <li>open (fs::FS, fs::FSImpl)</li> <li>openNextFile (fs::File, fs::FileImpl)</li> <li>old_mode (wifi_event_sta_authmode_change_t)</li> </ul>"},{"location":"ltapi/class_members/#p","title":"p","text":"<ul> <li>path (Cookie, fs::File, fs::FileImpl)</li> <li>PATCH (HTTPClient)</li> <li>POST (HTTPClient)</li> <li>PUT (HTTPClient)</li> <li>putBool (IPreferences)</li> <li>putBytes (IPreferences)</li> <li>putChar (IPreferences)</li> <li>putDouble (IPreferences)</li> <li>putFloat (IPreferences)</li> <li>putInt (IPreferences)</li> <li>putLong (IPreferences)</li> <li>putLong64 (IPreferences)</li> <li>putShort (IPreferences)</li> <li>putString (IPreferences)</li> <li>putUChar (IPreferences)</li> <li>putUInt (IPreferences)</li> <li>putULong (IPreferences)</li> <li>putULong64 (IPreferences)</li> <li>putUShort (IPreferences)</li> <li>peek (ITwoWire, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File)</li> <li>parsePacket (IWiFiUDP, LwIPUDP)</li> <li>pathArg (RequestHandler, WebServer)</li> <li>pathArgs (RequestHandler)</li> <li>printError (UpdateClass)</li> <li>printErrorContext1 (UpdateClass)</li> <li>printErrorContext2 (UpdateClass)</li> <li>progress (UpdateClass)</li> <li>postEvent (WiFiClass)</li> <li>printDiag (WiFiClass)</li> <li>psk (WiFiClass)</li> <li>passphrase (WifiAPlist_t, wifi_event_sta_wps_er_success_t)</li> <li>printTo (arduino::IPv6Address)</li> <li>plainchar (base64_decodestate)</li> <li>position (fs::File, fs::FileImpl)</li> <li>port (mDNS)</li> <li>peer_mac (wifi_event_ftm_report_t)</li> <li>pin_code (wifi_event_sta_wps_er_pin_t)</li> </ul>"},{"location":"ltapi/class_members/#q","title":"q","text":"<ul> <li>queryHost (mDNS)</li> <li>queryService (mDNS)</li> </ul>"},{"location":"ltapi/class_members/#r","title":"r","text":"<ul> <li>readBlock (FlashClass)</li> <li>resetCookieJar (HTTPClient)</li> <li>returnError (HTTPClient)</li> <li>remove (IPreferences, cbuf, fs::FS, fs::FSImpl)</li> <li>read (ITwoWire, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>requestFrom (ITwoWire)</li> <li>remoteIP (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>remotePort (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>restart (LibreTuya)</li> <li>restartDownloadMode (LibreTuya)</li> <li>r_available (LwIPRxBuffer)</li> <li>remote_ip (LwIPUDP)</li> <li>remote_port (LwIPUDP)</li> <li>rx_buffer (LwIPUDP)</li> <li>remaining (UpdateClass)</li> <li>rollBack (UpdateClass)</li> <li>requestAuthentication (WebServer)</li> <li>RSSI (WiFiClass)</li> <li>reconnect (WiFiClass)</li> <li>removeEvent (WiFiClass)</li> <li>run (WiFiMulti)</li> <li>rssi (WiFiScanAP, wifi_event_ap_probe_req_rx_t, wifi_ftm_report_entry_t)</li> <li>running (WiFiScanData)</li> <li>raw_address (arduino::IPv6Address)</li> <li>result (base64_encodestate)</li> <li>resize (cbuf)</li> <li>resizeAdd (cbuf)</li> <li>room (cbuf)</li> <li>rename (fs::FS, fs::FSImpl)</li> <li>rmdir (fs::FS, fs::FSImpl)</li> <li>readBytes (fs::File)</li> <li>rewindDirectory (fs::File, fs::FileImpl)</li> <li>rtt_est (wifi_event_ftm_report_t)</li> <li>rtt_raw (wifi_event_ftm_report_t)</li> <li>reason (wifi_event_sta_disconnected_t)</li> <li>rtt (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_members/#s","title":"s","text":"<ul> <li>secure (Cookie)</li> <li>scb (EventHandler_s)</li> <li>sendHeader (HTTPClient, WebServer)</li> <li>sendRequest (HTTPClient)</li> <li>setAuthorization (HTTPClient)</li> <li>setAuthorizationType (HTTPClient)</li> <li>setConnectTimeout (HTTPClient)</li> <li>setCookie (HTTPClient)</li> <li>setCookieJar (HTTPClient)</li> <li>setFollowRedirects (HTTPClient)</li> <li>setRedirectLimit (HTTPClient)</li> <li>setReuse (HTTPClient)</li> <li>setTimeout (HTTPClient, IWiFiClient, IWiFiServer, LwIPClient, LwIPServer)</li> <li>setURL (HTTPClient)</li> <li>setUserAgent (HTTPClient)</li> <li>status (HTTPUpload, WiFiClass, wifi_event_action_tx_status_t, wifi_event_ftm_report_t, wifi_event_sta_scan_done_t)</li> <li>setClock (ITwoWire)</li> <li>setPins (ITwoWire)</li> <li>socket (IWiFiClient, LwIPClient)</li> <li>setAlpnProtocols (IWiFiClientSecure, MbedTLSClient)</li> <li>setCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>setCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>setHandshakeTimeout (IWiFiClientSecure, MbedTLSClient)</li> <li>setInsecure (IWiFiClientSecure, MbedTLSClient)</li> <li>setPreSharedKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setNoDelay (IWiFiServer, LwIPServer)</li> <li>stop (IWiFiServer, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, WebServer)</li> <li>stopAll (IWiFiServer, LwIPServer)</li> <li>server_port (LwIPUDP)</li> <li>supported (PinInfo)</li> <li>StaticRequestHandler (StaticRequestHandler)</li> <li>size (UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>send (WebServer)</li> <li>sendContent (WebServer)</li> <li>sendContent_P (WebServer)</li> <li>send_P (WebServer)</li> <li>serveStatic (WebServer)</li> <li>setContentLength (WebServer)</li> <li>streamFile (WebServer)</li> <li>SSID (WiFiClass)</li> <li>scan (WiFiClass)</li> <li>scanAlloc (WiFiClass)</li> <li>scanComplete (WiFiClass)</li> <li>scanDelete (WiFiClass)</li> <li>scanInit (WiFiClass)</li> <li>scanNetworks (WiFiClass)</li> <li>setAutoReconnect (WiFiClass)</li> <li>setHostname (WiFiClass)</li> <li>setMacAddress (WiFiClass)</li> <li>setSleep (WiFiClass)</li> <li>setTxPower (WiFiClass)</li> <li>softAP (WiFiClass)</li> <li>softAPBroadcastIP (WiFiClass)</li> <li>softAPConfig (WiFiClass)</li> <li>softAPIP (WiFiClass)</li> <li>softAPIPv6 (WiFiClass)</li> <li>softAPNetworkID (WiFiClass)</li> <li>softAPSSID (WiFiClass)</li> <li>softAPSubnetCIDR (WiFiClass)</li> <li>softAPSubnetMask (WiFiClass)</li> <li>softAPdisconnect (WiFiClass)</li> <li>softAPenableIpV6 (WiFiClass)</li> <li>softAPgetHostname (WiFiClass)</li> <li>softAPgetStationNum (WiFiClass)</li> <li>softAPmacAddress (WiFiClass)</li> <li>softAPsetHostname (WiFiClass)</li> <li>subnetCIDR (WiFiClass)</li> <li>subnetMask (WiFiClass)</li> <li>ssid (WiFiScanAP, WifiAPlist_t, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t, wifi_event_sta_wps_er_success_t)</li> <li>step (base64_decodestate, base64_encodestate)</li> <li>stepcount (base64_encodestate)</li> <li>seek (fs::File, fs::FileImpl)</li> <li>setBufferSize (fs::File, fs::FileImpl)</li> <li>setInstanceName (mDNS)</li> <li>ssid_len (wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>scan_id (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_members/#t","title":"t","text":"<ul> <li>totalSize (HTTPUpload)</li> <li>type (HTTPUpload)</li> <li>tx_buffer (LwIPUDP)</li> <li>tx_buffer_len (LwIPUDP)</li> <li>THandlerFunction_Progress (UpdateClass)</li> <li>tryWriteData (UpdateClass)</li> <li>THandlerFunction (WebServer)</li> <li>timeout (WiFiScanData)</li> <li>toString (arduino::IPv6Address)</li> <li>txt (mDNS)</li> <li>txtKey (mDNS)</li> <li>t1 (wifi_ftm_report_entry_t)</li> <li>t2 (wifi_ftm_report_entry_t)</li> <li>t3 (wifi_ftm_report_entry_t)</li> <li>t4 (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_members/#u","title":"u","text":"<ul> <li>upload (FunctionRequestHandler, RequestHandler, WebServer)</li> <li>useHTTP10 (HTTPClient)</li> <li>udp_server (LwIPUDP)</li> <li>UpdateClass (UpdateClass)</li> <li>Uri (Uri)</li> <li>UriBraces (UriBraces)</li> <li>UriGlob (UriGlob)</li> <li>UriRegex (UriRegex)</li> <li>uri (WebServer)</li> <li>urlDecode (WebServer)</li> </ul>"},{"location":"ltapi/class_members/#v","title":"v","text":"<ul> <li>valid (Cookie)</li> <li>value (Cookie, HTTPClient::RequestArgument, WebServer::RequestArgument)</li> <li>verify (IWiFiClientSecure, MbedTLSClient)</li> <li>validate (WiFiClass)</li> </ul>"},{"location":"ltapi/class_members/#w","title":"w","text":"<ul> <li>writeBlock (FlashClass)</li> <li>writeToStream (HTTPClient)</li> <li>writeToStreamDataBlock (HTTPClient)</li> <li>write (ITwoWire, IWiFiClient, IWiFiServer, IWiFiUDP, LwIPClient, LwIPServer, LwIPUDP, MbedTLSClient, StreamString, UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>write_P (IWiFiClient)</li> <li>wdtDisable (LibreTuya)</li> <li>wdtEnable (LibreTuya)</li> <li>wdtFeed (LibreTuya)</li> <li>writeStream (UpdateClass)</li> <li>WebServer (WebServer)</li> <li>WiFiClass (WiFiClass)</li> <li>waitForConnectResult (WiFiClass)</li> <li>WiFiMulti (WiFiMulti)</li> <li>wrap_if_bufend (cbuf)</li> </ul>"},{"location":"ltapi/class_members/#z","title":"z","text":"<ul> <li>zone (esp_ip6_addr)</li> </ul>"},{"location":"ltapi/class_members/#_1","title":"~","text":"<ul> <li>~FunctionRequestHandler (FunctionRequestHandler)</li> <li>~HTTPClient (HTTPClient)</li> <li>~IPreferences (IPreferences)</li> <li>~IWiFiClient (IWiFiClient)</li> <li>~IWiFiServer (IWiFiServer)</li> <li>~IWiFiUDP (IWiFiUDP)</li> <li>~LwIPClient (LwIPClient)</li> <li>~LwIPRxBuffer (LwIPRxBuffer)</li> <li>~LwIPUDP (LwIPUDP)</li> <li>~MbedTLSClient (MbedTLSClient)</li> <li>~RequestHandler (RequestHandler)</li> <li>~Uri (Uri)</li> <li>~WebServer (WebServer)</li> <li>~WiFiClass (WiFiClass)</li> <li>~WiFiMulti (WiFiMulti)</li> <li>~IPv6Address (arduino::IPv6Address)</li> <li>~cbuf (cbuf)</li> <li>~FSImpl (fs::FSImpl)</li> <li>~FileImpl (fs::FileImpl)</li> <li>~mDNS (mDNS)</li> </ul>"},{"location":"ltapi/class_members/#_","title":"_","text":"<ul> <li>_fn (FunctionRequestHandler)</li> <li>_method (FunctionRequestHandler)</li> <li>_ufn (FunctionRequestHandler)</li> <li>_uri (FunctionRequestHandler, HTTPClient, StaticRequestHandler, Uri)</li> <li>_authorizationType (HTTPClient)</li> <li>_base64Authorization (HTTPClient)</li> <li>_canReuse (HTTPClient)</li> <li>_client (HTTPClient)</li> <li>_connectTimeout (HTTPClient)</li> <li>_cookieJar (HTTPClient)</li> <li>_currentHeaders (HTTPClient, WebServer)</li> <li>_followRedirects (HTTPClient)</li> <li>_headerKeysCount (HTTPClient, WebServer)</li> <li>_headers (HTTPClient)</li> <li>_host (HTTPClient)</li> <li>_location (HTTPClient)</li> <li>_port (HTTPClient, LwIPServer)</li> <li>_protocol (HTTPClient)</li> <li>_redirectLimit (HTTPClient)</li> <li>_returnCode (HTTPClient)</li> <li>_reuse (HTTPClient)</li> <li>_secure (HTTPClient)</li> <li>_size (HTTPClient, LwIPRxBuffer, cbuf)</li> <li>_tcpDeprecated (HTTPClient)</li> <li>_tcpTimeout (HTTPClient)</li> <li>_transferEncoding (HTTPClient)</li> <li>_transportTraits (HTTPClient)</li> <li>_useHTTP10 (HTTPClient)</li> <li>_userAgent (HTTPClient)</li> <li>_freq (ITwoWire)</li> <li>_scl (ITwoWire)</li> <li>_sda (ITwoWire)</li> <li>_connected (LwIPClient)</li> <li>_rxBuffer (LwIPClient)</li> <li>_sock (LwIPClient, LwIPRxBuffer, LwIPServer)</li> <li>_buffer (LwIPRxBuffer)</li> <li>_failed (LwIPRxBuffer)</li> <li>_fill (LwIPRxBuffer)</li> <li>_pos (LwIPRxBuffer)</li> <li>_active (LwIPServer)</li> <li>_addr (LwIPServer)</li> <li>_maxClients (LwIPServer)</li> <li>_noDelay (LwIPServer)</li> <li>_sockAccepted (LwIPServer)</li> <li>_alpnProtocols (MbedTLSClient)</li> <li>_caCert (MbedTLSClient)</li> <li>_caCertStr (MbedTLSClient)</li> <li>_clientCert (MbedTLSClient)</li> <li>_clientCertStr (MbedTLSClient)</li> <li>_clientKey (MbedTLSClient)</li> <li>_clientKeyStr (MbedTLSClient)</li> <li>_handshakeTimeout (MbedTLSClient)</li> <li>_insecure (MbedTLSClient)</li> <li>_peeked (MbedTLSClient)</li> <li>_pskIdentStr (MbedTLSClient)</li> <li>_pskStr (MbedTLSClient)</li> <li>_sockTls (MbedTLSClient)</li> <li>_sslCfg (MbedTLSClient)</li> <li>_sslCtx (MbedTLSClient)</li> <li>_useRootCA (MbedTLSClient)</li> <li>_next (RequestHandler)</li> <li>_baseUriLength (StaticRequestHandler)</li> <li>_cache_header (StaticRequestHandler)</li> <li>_fs (StaticRequestHandler)</li> <li>_isFile (StaticRequestHandler)</li> <li>_path (StaticRequestHandler)</li> <li>_addRequestHandler (WebServer)</li> <li>_chunked (WebServer)</li> <li>_collectHeader (WebServer)</li> <li>_contentLength (WebServer)</li> <li>_corsEnabled (WebServer)</li> <li>_currentArgCount (WebServer)</li> <li>_currentArgs (WebServer)</li> <li>_currentClient (WebServer)</li> <li>_currentClientWrite (WebServer)</li> <li>_currentClientWrite_P (WebServer)</li> <li>_currentHandler (WebServer)</li> <li>_currentMethod (WebServer)</li> <li>_currentStatus (WebServer)</li> <li>_currentUpload (WebServer)</li> <li>_currentUri (WebServer)</li> <li>_currentVersion (WebServer)</li> <li>_extractParam (WebServer)</li> <li>_fileUploadHandler (WebServer)</li> <li>_finalizeResponse (WebServer)</li> <li>_firstHandler (WebServer)</li> <li>_getRandomHexString (WebServer)</li> <li>_handleRequest (WebServer)</li> <li>_hostHeader (WebServer)</li> <li>_lastHandler (WebServer)</li> <li>_notFoundHandler (WebServer)</li> <li>_nullDelay (WebServer)</li> <li>_parseArguments (WebServer)</li> <li>_parseForm (WebServer)</li> <li>_parseFormUploadAborted (WebServer)</li> <li>_parseRequest (WebServer)</li> <li>_postArgs (WebServer)</li> <li>_postArgsLen (WebServer)</li> <li>_prepareHeader (WebServer)</li> <li>_responseCodeToString (WebServer)</li> <li>_responseHeaders (WebServer)</li> <li>_server (WebServer)</li> <li>_snonce (WebServer)</li> <li>_sopaque (WebServer)</li> <li>_srealm (WebServer)</li> <li>_statusChange (WebServer)</li> <li>_streamFileCore (WebServer)</li> <li>_uploadReadByte (WebServer)</li> <li>_uploadWriteByte (WebServer)</li> <li>_address (arduino::IPv6Address)</li> <li>_begin (cbuf)</li> <li>_buf (cbuf)</li> <li>_bufend (cbuf)</li> <li>_end (cbuf)</li> <li>_impl (fs::FS)</li> <li>_p (fs::File)</li> </ul>"},{"location":"ltapi/class_member_functions/","title":"Class Member Functions","text":""},{"location":"ltapi/class_member_functions/#a","title":"a","text":"<ul> <li>addHeader (HTTPClient)</li> <li>available (ITwoWire, IWiFiServer, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File)</li> <li>accept (IWiFiServer, LwIPServer)</li> <li>abort (UpdateClass)</li> <li>addHandler (WebServer)</li> <li>arg (WebServer)</li> <li>argName (WebServer)</li> <li>args (WebServer)</li> <li>authenticate (WebServer)</li> <li>addAP (WiFiMulti)</li> <li>addService (mDNS)</li> <li>addServiceImpl (mDNS)</li> <li>addServiceTxt (mDNS)</li> <li>addServiceTxtImpl (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#b","title":"b","text":"<ul> <li>begin (HTTPClient, IPreferences, ITwoWire, IWiFiServer, IWiFiUDP, LwIPServer, LwIPUDP, UpdateClass, WebServer, WiFiClass, mDNS)</li> <li>beginInternal (HTTPClient)</li> <li>beginTransmission (ITwoWire)</li> <li>beginMulticast (IWiFiUDP, LwIPUDP)</li> <li>beginMulticastPacket (IWiFiUDP, LwIPUDP)</li> <li>beginPacket (IWiFiUDP, LwIPUDP)</li> <li>bufAlloc (UpdateClass)</li> <li>bufLeft (UpdateClass)</li> <li>bufSize (UpdateClass)</li> <li>BSSID (WiFiClass)</li> <li>BSSIDstr (WiFiClass)</li> <li>broadcastIP (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#c","title":"c","text":"<ul> <li>canHandle (FunctionRequestHandler, RequestHandler, StaticRequestHandler, Uri, UriBraces, UriGlob, UriRegex)</li> <li>canUpload (FunctionRequestHandler, RequestHandler)</li> <li>clear (HTTPClient, IPreferences)</li> <li>clearAllCookies (HTTPClient)</li> <li>collectHeaders (HTTPClient, WebServer)</li> <li>connect (HTTPClient, IWiFiClient, IWiFiClientSecure, LwIPClient, MbedTLSClient)</li> <li>connected (HTTPClient, LwIPClient)</li> <li>close (IWiFiServer, WebServer, fs::File, fs::FileImpl)</li> <li>canRollBack (UpdateClass)</li> <li>checkUf2Error (UpdateClass)</li> <li>cleanup (UpdateClass)</li> <li>clearError (UpdateClass)</li> <li>clone (Uri, UriBraces, UriGlob, UriRegex)</li> <li>client (WebServer)</li> <li>calculateBroadcast (WiFiClass)</li> <li>calculateNetworkID (WiFiClass)</li> <li>calculateSubnetCIDR (WiFiClass)</li> <li>channel (WiFiClass)</li> <li>config (WiFiClass)</li> <li>cbuf (cbuf)</li> </ul>"},{"location":"ltapi/class_member_functions/#d","title":"d","text":"<ul> <li>disconnect (HTTPClient, WiFiClass)</li> <li>dataFree (WiFiClass)</li> <li>dataInitialize (WiFiClass)</li> <li>dnsIP (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#e","title":"e","text":"<ul> <li>EventHandler_s (EventHandler_s)</li> <li>eraseSector (FlashClass)</li> <li>end (HTTPClient, IPreferences, ITwoWire, IWiFiServer, LwIPServer, UpdateClass, mDNS)</li> <li>errorToString (HTTPClient)</li> <li>endTransmission (ITwoWire)</li> <li>endPacket (IWiFiUDP, LwIPUDP)</li> <li>errorString (UpdateClass)</li> <li>enableCORS (WebServer)</li> <li>enableCrossOrigin (WebServer)</li> <li>enableDelay (WebServer)</li> <li>enableAP (WiFiClass)</li> <li>enableIpV6 (WiFiClass)</li> <li>enableSTA (WiFiClass)</li> <li>encryptionType (WiFiClass)</li> <li>encode (base64)</li> <li>empty (cbuf)</li> <li>exists (fs::FS, fs::FSImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#f","title":"f","text":"<ul> <li>FunctionRequestHandler (FunctionRequestHandler)</li> <li>freeEntries (IPreferences)</li> <li>flush (ITwoWire, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>fd (IWiFiClient, LwIPClient)</li> <li>failed (LwIPRxBuffer)</li> <li>fillBuffer (LwIPRxBuffer)</li> <li>fromString (arduino::IPv6Address)</li> <li>full (cbuf)</li> <li>FS (fs::FS)</li> <li>FSImpl (fs::FSImpl)</li> <li>File (fs::File)</li> </ul>"},{"location":"ltapi/class_member_functions/#g","title":"g","text":"<ul> <li>getChipId (FlashClass, LibreTuya)</li> <li>getSize (FlashClass, HTTPClient)</li> <li>GET (HTTPClient)</li> <li>generateCookieString (HTTPClient)</li> <li>getLocation (HTTPClient)</li> <li>getStream (HTTPClient)</li> <li>getStreamPtr (HTTPClient)</li> <li>getBool (IPreferences)</li> <li>getBytes (IPreferences)</li> <li>getBytesLength (IPreferences)</li> <li>getChar (IPreferences)</li> <li>getDouble (IPreferences)</li> <li>getFloat (IPreferences)</li> <li>getInt (IPreferences)</li> <li>getLong (IPreferences)</li> <li>getLong64 (IPreferences)</li> <li>getShort (IPreferences)</li> <li>getString (IPreferences)</li> <li>getType (IPreferences)</li> <li>getUChar (IPreferences)</li> <li>getUInt (IPreferences)</li> <li>getULong (IPreferences)</li> <li>getULong64 (IPreferences)</li> <li>getUShort (IPreferences)</li> <li>getClock (ITwoWire)</li> <li>getFingerprintSHA256 (IWiFiClientSecure, MbedTLSClient)</li> <li>getNoDelay (IWiFiServer, LwIPServer)</li> <li>getBoard (LibreTuya)</li> <li>getChipCoreType (LibreTuya)</li> <li>getChipCores (LibreTuya)</li> <li>getChipFamily (LibreTuya)</li> <li>getChipFamilyName (LibreTuya)</li> <li>getChipModel (LibreTuya)</li> <li>getChipType (LibreTuya)</li> <li>getCpuFreq (LibreTuya)</li> <li>getCpuFreqMHz (LibreTuya)</li> <li>getCycleCount (LibreTuya)</li> <li>getDeviceName (LibreTuya)</li> <li>getFlashChipId (LibreTuya)</li> <li>getFlashChipSize (LibreTuya)</li> <li>getFreeHeap (LibreTuya)</li> <li>getHeapSize (LibreTuya)</li> <li>getMaxAllocHeap (LibreTuya)</li> <li>getMaxFreeBlockSize (LibreTuya)</li> <li>getMinFreeHeap (LibreTuya)</li> <li>getRamSize (LibreTuya)</li> <li>getResetReason (LibreTuya)</li> <li>getResetReasonName (LibreTuya)</li> <li>getVersion (LibreTuya)</li> <li>gpioRecover (LibreTuya)</li> <li>getContentType (StaticRequestHandler)</li> <li>getBoardName (UpdateClass)</li> <li>getError (UpdateClass)</li> <li>getErrorCode (UpdateClass)</li> <li>getFirmwareName (UpdateClass)</li> <li>getFirmwareVersion (UpdateClass)</li> <li>getLibreTuyaVersion (UpdateClass)</li> <li>getUF2Error (UpdateClass)</li> <li>gatewayIP (WiFiClass)</li> <li>getAutoReconnect (WiFiClass)</li> <li>getEncryption (WiFiClass)</li> <li>getHostname (WiFiClass)</li> <li>getMode (WiFiClass)</li> <li>getNetworkInfo (WiFiClass)</li> <li>getSleep (WiFiClass)</li> <li>getTxPower (WiFiClass)</li> <li>getLastWrite (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#h","title":"h","text":"<ul> <li>handle (FunctionRequestHandler, RequestHandler, StaticRequestHandler)</li> <li>HTTPClient (HTTPClient)</li> <li>handleHeaderResponse (HTTPClient)</li> <li>hasHeader (HTTPClient, WebServer)</li> <li>header (HTTPClient, WebServer)</li> <li>headerName (HTTPClient, WebServer)</li> <li>headers (HTTPClient, WebServer)</li> <li>hasClient (IWiFiServer, LwIPServer)</li> <li>hasError (UpdateClass)</li> <li>handleClient (WebServer)</li> <li>hasArg (WebServer)</li> <li>hostHeader (WebServer)</li> <li>hostByName (WiFiClass)</li> <li>hostname (WiFiClass, mDNS)</li> <li>hasTxt (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#i","title":"i","text":"<ul> <li>IPreferences (IPreferences)</li> <li>isKey (IPreferences)</li> <li>IWiFiClient (IWiFiClient)</li> <li>IWiFiServer (IWiFiServer)</li> <li>IWiFiUDP (IWiFiUDP)</li> <li>init (MbedTLSClient)</li> <li>isFinished (UpdateClass)</li> <li>isRunning (UpdateClass)</li> <li>initPathArgs (Uri, UriBraces, UriRegex)</li> <li>isConnected (WiFiClass)</li> <li>IPv6Address (arduino::IPv6Address)</li> <li>isDirectory (fs::File, fs::FileImpl)</li> <li>IP (mDNS)</li> <li>IPv6 (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#l","title":"l","text":"<ul> <li>localIP (IWiFiClient, LwIPClient, WiFiClass)</li> <li>localPort (IWiFiClient, LwIPClient)</li> <li>lastError (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>loadCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>loadPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>listenOnLocalhost (IWiFiServer)</li> <li>LwIPClient (LwIPClient)</li> <li>LwIPRxBuffer (LwIPRxBuffer)</li> <li>LwIPServer (LwIPServer)</li> <li>LwIPUDP (LwIPUDP)</li> <li>localIPv6 (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#m","title":"m","text":"<ul> <li>MbedTLSClient (MbedTLSClient)</li> <li>md5 (UpdateClass)</li> <li>md5String (UpdateClass)</li> <li>method (WebServer)</li> <li>macAddress (WiFiClass)</li> <li>macToString (WiFiClass)</li> <li>mode (WiFiClass)</li> <li>modePriv (WiFiClass)</li> <li>mkdir (fs::FS, fs::FSImpl)</li> <li>mDNS (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#n","title":"n","text":"<ul> <li>next (RequestHandler)</li> <li>networkID (WiFiClass)</li> <li>name (fs::File, fs::FileImpl)</li> <li>numTxt (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#o","title":"o","text":"<ul> <li>onReceive (ITwoWire)</li> <li>onRequest (ITwoWire)</li> <li>operator bool (IWiFiClient, IWiFiServer, LwIPServer, fs::File, fs::FileImpl)</li> <li>operator!= (IWiFiClient)</li> <li>operator== (IWiFiClient, arduino::IPv6Address)</li> <li>otaCanRollback (LibreTuya)</li> <li>otaGetRunning (LibreTuya)</li> <li>otaGetStoredIndex (LibreTuya)</li> <li>otaGetTarget (LibreTuya)</li> <li>otaHasImage1 (LibreTuya)</li> <li>otaHasImage2 (LibreTuya)</li> <li>otaRollback (LibreTuya)</li> <li>otaSupportsDual (LibreTuya)</li> <li>otaSwitch (LibreTuya)</li> <li>operator= (LwIPClient, arduino::IPv6Address)</li> <li>onProgress (UpdateClass)</li> <li>on (WebServer)</li> <li>onFileUpload (WebServer)</li> <li>onNotFound (WebServer)</li> <li>onEvent (WiFiClass)</li> <li>operator const uint32_t * (arduino::IPv6Address)</li> <li>operator const uint8_t * (arduino::IPv6Address)</li> <li>operator[] (arduino::IPv6Address)</li> <li>open (fs::FS, fs::FSImpl)</li> <li>openNextFile (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#p","title":"p","text":"<ul> <li>PATCH (HTTPClient)</li> <li>POST (HTTPClient)</li> <li>PUT (HTTPClient)</li> <li>putBool (IPreferences)</li> <li>putBytes (IPreferences)</li> <li>putChar (IPreferences)</li> <li>putDouble (IPreferences)</li> <li>putFloat (IPreferences)</li> <li>putInt (IPreferences)</li> <li>putLong (IPreferences)</li> <li>putLong64 (IPreferences)</li> <li>putShort (IPreferences)</li> <li>putString (IPreferences)</li> <li>putUChar (IPreferences)</li> <li>putUInt (IPreferences)</li> <li>putULong (IPreferences)</li> <li>putULong64 (IPreferences)</li> <li>putUShort (IPreferences)</li> <li>peek (ITwoWire, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File)</li> <li>parsePacket (IWiFiUDP, LwIPUDP)</li> <li>pathArg (RequestHandler, WebServer)</li> <li>printError (UpdateClass)</li> <li>printErrorContext1 (UpdateClass)</li> <li>printErrorContext2 (UpdateClass)</li> <li>progress (UpdateClass)</li> <li>postEvent (WiFiClass)</li> <li>printDiag (WiFiClass)</li> <li>psk (WiFiClass)</li> <li>printTo (arduino::IPv6Address)</li> <li>path (fs::File, fs::FileImpl)</li> <li>position (fs::File, fs::FileImpl)</li> <li>port (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#q","title":"q","text":"<ul> <li>queryHost (mDNS)</li> <li>queryService (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#r","title":"r","text":"<ul> <li>readBlock (FlashClass)</li> <li>resetCookieJar (HTTPClient)</li> <li>returnError (HTTPClient)</li> <li>remove (IPreferences, cbuf, fs::FS, fs::FSImpl)</li> <li>read (ITwoWire, IWiFiUDP, LwIPClient, LwIPRxBuffer, LwIPUDP, MbedTLSClient, StreamString, cbuf, fs::File, fs::FileImpl)</li> <li>requestFrom (ITwoWire)</li> <li>remoteIP (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>remotePort (IWiFiClient, IWiFiUDP, LwIPClient, LwIPUDP)</li> <li>restart (LibreTuya)</li> <li>restartDownloadMode (LibreTuya)</li> <li>r_available (LwIPRxBuffer)</li> <li>remaining (UpdateClass)</li> <li>rollBack (UpdateClass)</li> <li>requestAuthentication (WebServer)</li> <li>RSSI (WiFiClass)</li> <li>reconnect (WiFiClass)</li> <li>removeEvent (WiFiClass)</li> <li>run (WiFiMulti)</li> <li>raw_address (arduino::IPv6Address)</li> <li>resize (cbuf)</li> <li>resizeAdd (cbuf)</li> <li>room (cbuf)</li> <li>rename (fs::FS, fs::FSImpl)</li> <li>rmdir (fs::FS, fs::FSImpl)</li> <li>readBytes (fs::File)</li> <li>rewindDirectory (fs::File, fs::FileImpl)</li> </ul>"},{"location":"ltapi/class_member_functions/#s","title":"s","text":"<ul> <li>sendHeader (HTTPClient, WebServer)</li> <li>sendRequest (HTTPClient)</li> <li>setAuthorization (HTTPClient)</li> <li>setAuthorizationType (HTTPClient)</li> <li>setConnectTimeout (HTTPClient)</li> <li>setCookie (HTTPClient)</li> <li>setCookieJar (HTTPClient)</li> <li>setFollowRedirects (HTTPClient)</li> <li>setRedirectLimit (HTTPClient)</li> <li>setReuse (HTTPClient)</li> <li>setTimeout (HTTPClient, IWiFiClient, IWiFiServer, LwIPClient, LwIPServer)</li> <li>setURL (HTTPClient)</li> <li>setUserAgent (HTTPClient)</li> <li>setClock (ITwoWire)</li> <li>setPins (ITwoWire)</li> <li>socket (IWiFiClient, LwIPClient)</li> <li>setAlpnProtocols (IWiFiClientSecure, MbedTLSClient)</li> <li>setCACert (IWiFiClientSecure, MbedTLSClient)</li> <li>setCertificate (IWiFiClientSecure, MbedTLSClient)</li> <li>setHandshakeTimeout (IWiFiClientSecure, MbedTLSClient)</li> <li>setInsecure (IWiFiClientSecure, MbedTLSClient)</li> <li>setPreSharedKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setPrivateKey (IWiFiClientSecure, MbedTLSClient)</li> <li>setNoDelay (IWiFiServer, LwIPServer)</li> <li>stop (IWiFiServer, IWiFiUDP, LwIPClient, LwIPUDP, MbedTLSClient, WebServer)</li> <li>stopAll (IWiFiServer, LwIPServer)</li> <li>StaticRequestHandler (StaticRequestHandler)</li> <li>size (UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>send (WebServer)</li> <li>sendContent (WebServer)</li> <li>sendContent_P (WebServer)</li> <li>send_P (WebServer)</li> <li>serveStatic (WebServer)</li> <li>setContentLength (WebServer)</li> <li>streamFile (WebServer)</li> <li>SSID (WiFiClass)</li> <li>scanAlloc (WiFiClass)</li> <li>scanComplete (WiFiClass)</li> <li>scanDelete (WiFiClass)</li> <li>scanInit (WiFiClass)</li> <li>scanNetworks (WiFiClass)</li> <li>setAutoReconnect (WiFiClass)</li> <li>setHostname (WiFiClass)</li> <li>setMacAddress (WiFiClass)</li> <li>setSleep (WiFiClass)</li> <li>setTxPower (WiFiClass)</li> <li>softAP (WiFiClass)</li> <li>softAPBroadcastIP (WiFiClass)</li> <li>softAPConfig (WiFiClass)</li> <li>softAPIP (WiFiClass)</li> <li>softAPIPv6 (WiFiClass)</li> <li>softAPNetworkID (WiFiClass)</li> <li>softAPSSID (WiFiClass)</li> <li>softAPSubnetCIDR (WiFiClass)</li> <li>softAPSubnetMask (WiFiClass)</li> <li>softAPdisconnect (WiFiClass)</li> <li>softAPenableIpV6 (WiFiClass)</li> <li>softAPgetHostname (WiFiClass)</li> <li>softAPgetStationNum (WiFiClass)</li> <li>softAPmacAddress (WiFiClass)</li> <li>softAPsetHostname (WiFiClass)</li> <li>status (WiFiClass)</li> <li>subnetCIDR (WiFiClass)</li> <li>subnetMask (WiFiClass)</li> <li>seek (fs::File, fs::FileImpl)</li> <li>setBufferSize (fs::File, fs::FileImpl)</li> <li>setInstanceName (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#t","title":"t","text":"<ul> <li>tryWriteData (UpdateClass)</li> <li>toString (arduino::IPv6Address)</li> <li>txt (mDNS)</li> <li>txtKey (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#u","title":"u","text":"<ul> <li>upload (FunctionRequestHandler, RequestHandler, WebServer)</li> <li>useHTTP10 (HTTPClient)</li> <li>UpdateClass (UpdateClass)</li> <li>Uri (Uri)</li> <li>UriBraces (UriBraces)</li> <li>UriGlob (UriGlob)</li> <li>UriRegex (UriRegex)</li> <li>uri (WebServer)</li> <li>urlDecode (WebServer)</li> </ul>"},{"location":"ltapi/class_member_functions/#v","title":"v","text":"<ul> <li>verify (IWiFiClientSecure, MbedTLSClient)</li> <li>validate (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_functions/#w","title":"w","text":"<ul> <li>writeBlock (FlashClass)</li> <li>writeToStream (HTTPClient)</li> <li>writeToStreamDataBlock (HTTPClient)</li> <li>write (ITwoWire, IWiFiClient, IWiFiServer, IWiFiUDP, LwIPClient, LwIPServer, LwIPUDP, MbedTLSClient, StreamString, UpdateClass, cbuf, fs::File, fs::FileImpl)</li> <li>write_P (IWiFiClient)</li> <li>wdtDisable (LibreTuya)</li> <li>wdtEnable (LibreTuya)</li> <li>wdtFeed (LibreTuya)</li> <li>writeStream (UpdateClass)</li> <li>WebServer (WebServer)</li> <li>WiFiClass (WiFiClass)</li> <li>waitForConnectResult (WiFiClass)</li> <li>WiFiMulti (WiFiMulti)</li> <li>wrap_if_bufend (cbuf)</li> </ul>"},{"location":"ltapi/class_member_functions/#_1","title":"~","text":"<ul> <li>~FunctionRequestHandler (FunctionRequestHandler)</li> <li>~HTTPClient (HTTPClient)</li> <li>~IPreferences (IPreferences)</li> <li>~IWiFiClient (IWiFiClient)</li> <li>~IWiFiServer (IWiFiServer)</li> <li>~IWiFiUDP (IWiFiUDP)</li> <li>~LwIPClient (LwIPClient)</li> <li>~LwIPRxBuffer (LwIPRxBuffer)</li> <li>~LwIPUDP (LwIPUDP)</li> <li>~MbedTLSClient (MbedTLSClient)</li> <li>~RequestHandler (RequestHandler)</li> <li>~Uri (Uri)</li> <li>~WebServer (WebServer)</li> <li>~WiFiClass (WiFiClass)</li> <li>~WiFiMulti (WiFiMulti)</li> <li>~IPv6Address (arduino::IPv6Address)</li> <li>~cbuf (cbuf)</li> <li>~FSImpl (fs::FSImpl)</li> <li>~FileImpl (fs::FileImpl)</li> <li>~mDNS (mDNS)</li> </ul>"},{"location":"ltapi/class_member_functions/#_","title":"_","text":"<ul> <li>_addRequestHandler (WebServer)</li> <li>_collectHeader (WebServer)</li> <li>_currentClientWrite (WebServer)</li> <li>_currentClientWrite_P (WebServer)</li> <li>_extractParam (WebServer)</li> <li>_finalizeResponse (WebServer)</li> <li>_getRandomHexString (WebServer)</li> <li>_handleRequest (WebServer)</li> <li>_parseArguments (WebServer)</li> <li>_parseForm (WebServer)</li> <li>_parseFormUploadAborted (WebServer)</li> <li>_parseRequest (WebServer)</li> <li>_prepareHeader (WebServer)</li> <li>_responseCodeToString (WebServer)</li> <li>_streamFileCore (WebServer)</li> <li>_uploadReadByte (WebServer)</li> <li>_uploadWriteByte (WebServer)</li> </ul>"},{"location":"ltapi/class_member_variables/","title":"Class Member Variables","text":""},{"location":"ltapi/class_member_variables/#a","title":"a","text":"<ul> <li>addr (WiFiMacAddr, esp_ip4_addr, esp_ip6_addr)</li> <li>APlist (WiFiMulti)</li> <li>auth (WiFiScanAP)</li> <li>ap (WiFiScanData)</li> <li>aid (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> <li>authmode (wifi_event_sta_connected_t)</li> <li>ap_cred (wifi_event_sta_wps_er_success_t)</li> <li>ap_cred_cnt (wifi_event_sta_wps_er_success_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#b","title":"b","text":"<ul> <li>buf (HTTPUpload, UpdateClass)</li> <li>bufPos (UpdateClass)</li> <li>bytesTotal (UpdateClass)</li> <li>bytesWritten (UpdateClass)</li> <li>bssid (WiFiScanAP, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>bytes (arduino::IPv6Address)</li> </ul>"},{"location":"ltapi/class_member_variables/#c","title":"c","text":"<ul> <li>cb (EventHandler_s)</li> <li>chipId (FlashId)</li> <li>chipSizeId (FlashId)</li> <li>currentSize (HTTPUpload)</li> <li>callback (UpdateClass)</li> <li>ctx (UpdateClass)</li> <li>channel (WiFiScanAP, wifi_event_sta_connected_t)</li> <li>count (WiFiScanData)</li> <li>context (wifi_event_action_tx_status_t, wifi_event_roc_done_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#d","title":"d","text":"<ul> <li>date (Cookie)</li> <li>domain (Cookie)</li> <li>duration (Cookie)</li> <li>dword (arduino::IPv6Address)</li> <li>da (wifi_event_action_tx_status_t)</li> <li>dist_est (wifi_event_ftm_report_t)</li> <li>dlog_token (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#e","title":"e","text":"<ul> <li>expires (Cookie)</li> <li>eventId (EventHandler_s)</li> <li>enabled (PinInfo)</li> <li>errArd (UpdateClass)</li> <li>errUf2 (UpdateClass)</li> <li>event_id (arduino_event_t)</li> <li>event_info (arduino_event_t)</li> <li>esp_netif (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>endsWith (mime::Entry)</li> </ul>"},{"location":"ltapi/class_member_variables/#f","title":"f","text":"<ul> <li>fcb (EventHandler_s)</li> <li>filename (HTTPUpload)</li> <li>ftm_report_data (wifi_event_ftm_report_t)</li> <li>ftm_report_num_entries (wifi_event_ftm_report_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#g","title":"g","text":"<ul> <li>gpio (PinInfo)</li> <li>gw (esp_netif_ip_info_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#h","title":"h","text":"<ul> <li>host (Cookie)</li> <li>http_only (Cookie)</li> <li>handlers (WiFiClass)</li> </ul>"},{"location":"ltapi/class_member_variables/#i","title":"i","text":"<ul> <li>id (EventHandler_s)</li> <li>info (UpdateClass)</li> <li>ip (esp_netif_ip6_info_t, esp_netif_ip_info_t, ip_event_ap_staipassigned_t)</li> <li>if_index (ip_event_got_ip6_t, ip_event_got_ip_t)</li> <li>ip6_info (ip_event_got_ip6_t)</li> <li>ip_index (ip_event_got_ip6_t)</li> <li>ip_changed (ip_event_got_ip_t)</li> <li>ip_info (ip_event_got_ip_t)</li> <li>instanceName (mDNS)</li> <li>ifx (wifi_event_action_tx_status_t)</li> <li>is_mesh_child (wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#k","title":"k","text":"<ul> <li>key (HTTPClient::RequestArgument, WebServer::RequestArgument)</li> </ul>"},{"location":"ltapi/class_member_variables/#l","title":"l","text":"<ul> <li>lastId (EventHandler_s)</li> </ul>"},{"location":"ltapi/class_member_variables/#m","title":"m","text":"<ul> <li>max_age (Cookie)</li> <li>manufacturerId (FlashId)</li> <li>multicast_ip (LwIPUDP)</li> <li>mode (PinInfo)</li> <li>mimeType (mime::Entry)</li> <li>mac (wifi_event_ap_probe_req_rx_t, wifi_event_ap_staconnected_t, wifi_event_ap_stadisconnected_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#n","title":"n","text":"<ul> <li>name (Cookie, HTTPUpload)</li> <li>next (cbuf)</li> <li>netmask (esp_netif_ip_info_t)</li> <li>new_mode (wifi_event_sta_authmode_change_t)</li> <li>number (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#o","title":"o","text":"<ul> <li>onReceiveCallback (ITwoWire)</li> <li>onRequestCallback (ITwoWire)</li> <li>old_mode (wifi_event_sta_authmode_change_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#p","title":"p","text":"<ul> <li>path (Cookie)</li> <li>pathArgs (RequestHandler)</li> <li>passphrase (WifiAPlist_t, wifi_event_sta_wps_er_success_t)</li> <li>plainchar (base64_decodestate)</li> <li>peer_mac (wifi_event_ftm_report_t)</li> <li>pin_code (wifi_event_sta_wps_er_pin_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#r","title":"r","text":"<ul> <li>remote_ip (LwIPUDP)</li> <li>remote_port (LwIPUDP)</li> <li>rx_buffer (LwIPUDP)</li> <li>rssi (WiFiScanAP, wifi_event_ap_probe_req_rx_t, wifi_ftm_report_entry_t)</li> <li>running (WiFiScanData)</li> <li>result (base64_encodestate)</li> <li>rtt_est (wifi_event_ftm_report_t)</li> <li>rtt_raw (wifi_event_ftm_report_t)</li> <li>reason (wifi_event_sta_disconnected_t)</li> <li>rtt (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#s","title":"s","text":"<ul> <li>secure (Cookie)</li> <li>scb (EventHandler_s)</li> <li>status (HTTPUpload, wifi_event_action_tx_status_t, wifi_event_ftm_report_t, wifi_event_sta_scan_done_t)</li> <li>server_port (LwIPUDP)</li> <li>supported (PinInfo)</li> <li>scan (WiFiClass)</li> <li>ssid (WiFiScanAP, WifiAPlist_t, wifi_event_sta_connected_t, wifi_event_sta_disconnected_t, wifi_event_sta_wps_er_success_t)</li> <li>step (base64_decodestate, base64_encodestate)</li> <li>stepcount (base64_encodestate)</li> <li>ssid_len (wifi_event_sta_connected_t, wifi_event_sta_disconnected_t)</li> <li>scan_id (wifi_event_sta_scan_done_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#t","title":"t","text":"<ul> <li>totalSize (HTTPUpload)</li> <li>type (HTTPUpload)</li> <li>tx_buffer (LwIPUDP)</li> <li>tx_buffer_len (LwIPUDP)</li> <li>timeout (WiFiScanData)</li> <li>t1 (wifi_ftm_report_entry_t)</li> <li>t2 (wifi_ftm_report_entry_t)</li> <li>t3 (wifi_ftm_report_entry_t)</li> <li>t4 (wifi_ftm_report_entry_t)</li> </ul>"},{"location":"ltapi/class_member_variables/#u","title":"u","text":"<ul> <li>udp_server (LwIPUDP)</li> </ul>"},{"location":"ltapi/class_member_variables/#v","title":"v","text":"<ul> <li>valid (Cookie)</li> <li>value (Cookie, HTTPClient::RequestArgument, WebServer::RequestArgument)</li> </ul>"},{"location":"ltapi/class_member_variables/#z","title":"z","text":"<ul> <li>zone (esp_ip6_addr)</li> </ul>"},{"location":"ltapi/class_member_variables/#_","title":"_","text":"<ul> <li>_fn (FunctionRequestHandler)</li> <li>_method (FunctionRequestHandler)</li> <li>_ufn (FunctionRequestHandler)</li> <li>_uri (FunctionRequestHandler, HTTPClient, StaticRequestHandler, Uri)</li> <li>_authorizationType (HTTPClient)</li> <li>_base64Authorization (HTTPClient)</li> <li>_canReuse (HTTPClient)</li> <li>_client (HTTPClient)</li> <li>_connectTimeout (HTTPClient)</li> <li>_cookieJar (HTTPClient)</li> <li>_currentHeaders (HTTPClient, WebServer)</li> <li>_followRedirects (HTTPClient)</li> <li>_headerKeysCount (HTTPClient, WebServer)</li> <li>_headers (HTTPClient)</li> <li>_host (HTTPClient)</li> <li>_location (HTTPClient)</li> <li>_port (HTTPClient, LwIPServer)</li> <li>_protocol (HTTPClient)</li> <li>_redirectLimit (HTTPClient)</li> <li>_returnCode (HTTPClient)</li> <li>_reuse (HTTPClient)</li> <li>_secure (HTTPClient)</li> <li>_size (HTTPClient, LwIPRxBuffer, cbuf)</li> <li>_tcpDeprecated (HTTPClient)</li> <li>_tcpTimeout (HTTPClient)</li> <li>_transferEncoding (HTTPClient)</li> <li>_transportTraits (HTTPClient)</li> <li>_useHTTP10 (HTTPClient)</li> <li>_userAgent (HTTPClient)</li> <li>_freq (ITwoWire)</li> <li>_scl (ITwoWire)</li> <li>_sda (ITwoWire)</li> <li>_connected (LwIPClient)</li> <li>_rxBuffer (LwIPClient)</li> <li>_sock (LwIPClient, LwIPRxBuffer, LwIPServer)</li> <li>_buffer (LwIPRxBuffer)</li> <li>_failed (LwIPRxBuffer)</li> <li>_fill (LwIPRxBuffer)</li> <li>_pos (LwIPRxBuffer)</li> <li>_active (LwIPServer)</li> <li>_addr (LwIPServer)</li> <li>_maxClients (LwIPServer)</li> <li>_noDelay (LwIPServer)</li> <li>_sockAccepted (LwIPServer)</li> <li>_alpnProtocols (MbedTLSClient)</li> <li>_caCert (MbedTLSClient)</li> <li>_caCertStr (MbedTLSClient)</li> <li>_clientCert (MbedTLSClient)</li> <li>_clientCertStr (MbedTLSClient)</li> <li>_clientKey (MbedTLSClient)</li> <li>_clientKeyStr (MbedTLSClient)</li> <li>_handshakeTimeout (MbedTLSClient)</li> <li>_insecure (MbedTLSClient)</li> <li>_peeked (MbedTLSClient)</li> <li>_pskIdentStr (MbedTLSClient)</li> <li>_pskStr (MbedTLSClient)</li> <li>_sockTls (MbedTLSClient)</li> <li>_sslCfg (MbedTLSClient)</li> <li>_sslCtx (MbedTLSClient)</li> <li>_useRootCA (MbedTLSClient)</li> <li>_next (RequestHandler)</li> <li>_baseUriLength (StaticRequestHandler)</li> <li>_cache_header (StaticRequestHandler)</li> <li>_fs (StaticRequestHandler)</li> <li>_isFile (StaticRequestHandler)</li> <li>_path (StaticRequestHandler)</li> <li>_chunked (WebServer)</li> <li>_contentLength (WebServer)</li> <li>_corsEnabled (WebServer)</li> <li>_currentArgCount (WebServer)</li> <li>_currentArgs (WebServer)</li> <li>_currentClient (WebServer)</li> <li>_currentHandler (WebServer)</li> <li>_currentMethod (WebServer)</li> <li>_currentStatus (WebServer)</li> <li>_currentUpload (WebServer)</li> <li>_currentUri (WebServer)</li> <li>_currentVersion (WebServer)</li> <li>_fileUploadHandler (WebServer)</li> <li>_firstHandler (WebServer)</li> <li>_hostHeader (WebServer)</li> <li>_lastHandler (WebServer)</li> <li>_notFoundHandler (WebServer)</li> <li>_nullDelay (WebServer)</li> <li>_postArgs (WebServer)</li> <li>_postArgsLen (WebServer)</li> <li>_responseHeaders (WebServer)</li> <li>_server (WebServer)</li> <li>_snonce (WebServer)</li> <li>_sopaque (WebServer)</li> <li>_srealm (WebServer)</li> <li>_statusChange (WebServer)</li> <li>_address (arduino::IPv6Address)</li> <li>_begin (cbuf)</li> <li>_buf (cbuf)</li> <li>_bufend (cbuf)</li> <li>_end (cbuf)</li> <li>_impl (fs::FS)</li> <li>_p (fs::File)</li> </ul>"},{"location":"ltapi/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"ltapi/class_member_typedefs/#t","title":"t","text":"<ul> <li>THandlerFunction_Progress (UpdateClass)</li> <li>THandlerFunction (WebServer)</li> </ul>"},{"location":"ltapi/class_member_enums/","title":"Class Member Enums","text":""},{"location":"ltapi/namespace_members/","title":"Namespace Members","text":""},{"location":"ltapi/namespace_members/#f","title":"f","text":"<ul> <li>FSImplPtr (fs)</li> <li>FileImplPtr (fs)</li> </ul>"},{"location":"ltapi/namespace_members/#m","title":"m","text":"<ul> <li>mimeTable (mime)</li> </ul>"},{"location":"ltapi/namespace_members/#s","title":"s","text":"<ul> <li>SeekMode (fs)</li> </ul>"},{"location":"ltapi/namespace_members/#t","title":"t","text":"<ul> <li>type (mime)</li> </ul>"},{"location":"ltapi/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"ltapi/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"ltapi/namespace_member_variables/#m","title":"m","text":"<ul> <li>mimeTable (mime)</li> </ul>"},{"location":"ltapi/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"ltapi/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>FSImplPtr (fs)</li> <li>FileImplPtr (fs)</li> </ul>"},{"location":"ltapi/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"ltapi/namespace_member_enums/#s","title":"s","text":"<ul> <li>SeekMode (fs)</li> </ul>"},{"location":"ltapi/namespace_member_enums/#t","title":"t","text":"<ul> <li>type (mime)</li> </ul>"},{"location":"ltapi/functions/","title":"Functions","text":""},{"location":"ltapi/functions/#a","title":"a","text":"<ul> <li>analogRead (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>analogReadResolution (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>analogWriteFrequency (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>analogWritePeriod (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>analogWriteResolution (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>analogReadMaxVoltage (LibreTuyaCustom.h)</li> <li>analogReadVoltage (LibreTuyaCustom.h)</li> </ul>"},{"location":"ltapi/functions/#b","title":"b","text":"<ul> <li>base64_decode_block (cdecode.c, cdecode.h)</li> <li>base64_decode_block_signed (cdecode.c)</li> <li>base64_decode_chars (cdecode.c, cdecode.h)</li> <li>base64_decode_chars_signed (cdecode.c)</li> <li>base64_decode_value (cdecode.c, cdecode.h)</li> <li>base64_decode_value_signed (cdecode.c)</li> <li>base64_init_decodestate (cdecode.c, cdecode.h)</li> <li>base64_encode_block (cencode.c, cencode.h)</li> <li>base64_encode_blockend (cencode.c, cencode.h)</li> <li>base64_encode_chars (cencode.c, cencode.h)</li> <li>base64_encode_value (cencode.c, cencode.h)</li> <li>base64_init_encodestate (cencode.c, cencode.h)</li> </ul>"},{"location":"ltapi/functions/#d","title":"d","text":"<ul> <li>dtostrf (dtostrf.c)</li> </ul>"},{"location":"ltapi/functions/#e","title":"e","text":"<ul> <li>ensureUnderscore (mDNS.cpp)</li> </ul>"},{"location":"ltapi/functions/#g","title":"g","text":"<ul> <li>gettimeofday (time.c)</li> </ul>"},{"location":"ltapi/functions/#h","title":"h","text":"<ul> <li>hexdump (LibreTuyaAPI.cpp, LibreTuyaAPI.h)</li> </ul>"},{"location":"ltapi/functions/#i","title":"i","text":"<ul> <li>itoa (itoa.c)</li> <li>ipToString (LibreTuyaAPI.cpp, LibreTuyaAPI.h)</li> <li>initArduino (main.cpp)</li> <li>initVariant (main.cpp)</li> </ul>"},{"location":"ltapi/functions/#l","title":"l","text":"<ul> <li>ltoa (itoa.c)</li> <li>lt_rand_bytes (LibreTuyaAPI.cpp, LibreTuyaAPI.h)</li> <li>lt_log (lt_logger.c, lt_logger.h)</li> <li>lt_log_disable (lt_logger.c, lt_logger.h)</li> <li>lt_log_set_port (lt_logger.c, lt_logger.h)</li> </ul>"},{"location":"ltapi/functions/#m","title":"m","text":"<ul> <li>mainTask (LibreTuyaCustom.h, main.cpp)</li> <li>millis (lt_logger.c)</li> <li>main (main.cpp)</li> <li>MD5Final (MD5.h)</li> <li>MD5Init (MD5.h)</li> <li>MD5Update (MD5.h)</li> </ul>"},{"location":"ltapi/functions/#p","title":"p","text":"<ul> <li>pinEnabled (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>pinInfo (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>pinInvalid (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>pinIsInput (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>pinIsOutput (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>pinSupported (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>printf_nop (fal_cfg.h)</li> <li>putchar_p (printf_config.h)</li> </ul>"},{"location":"ltapi/functions/#r","title":"r","text":"<ul> <li>random (WMath.cpp)</li> <li>randomSeed (WMath.cpp)</li> <li>runPeriodicTasks (LibreTuyaCustom.h, main.cpp)</li> </ul>"},{"location":"ltapi/functions/#s","title":"s","text":"<ul> <li>sysTickHook (hooks.c)</li> <li>Serial_available (serial_event.cpp)</li> <li>serialEvent (serial_event.cpp)</li> <li>serialEventRun (serial_event.cpp)</li> <li>shiftIn (wiring_shift.c)</li> <li>shiftOut (wiring_shift.c)</li> <li>startMainTask (LibreTuyaCustom.h)</li> <li>strptime (strptime.c, strptime.h)</li> <li>strcasecmp (lt_posix_api.h, strcasecmp.c)</li> <li>strdup (lt_posix_api.h)</li> <li>strncasecmp (lt_posix_api.h, strcasecmp.c)</li> <li>settimeofday (time.c)</li> </ul>"},{"location":"ltapi/functions/#u","title":"u","text":"<ul> <li>ultoa (itoa.c)</li> <li>utoa (itoa.c)</li> </ul>"},{"location":"ltapi/functions/#y","title":"y","text":"<ul> <li>yield (hooks.c)</li> </ul>"},{"location":"ltapi/functions/#_","title":"_","text":"<ul> <li>__attribute__ (WiFi.cpp, WiFiAP.cpp, WiFiGeneric.cpp, WiFiSTA.cpp, LibreTuyaClass.cpp, LibreTuyaCustom.c, strdup.c)</li> <li>__cxa_deleted_virtual (abi.cpp)</li> <li>__cxa_pure_virtual (abi.cpp)</li> <li>__empty (hooks.c)</li> <li>__libc_init_array (main.cpp)</li> <li>__wrap_putchar (putchar.c)</li> <li>__wrap_puts (puts.c)</li> <li>__wrap_gettimeofday (time.c)</li> <li>__wrap_settimeofday (time.c)</li> <li>_gettimeofday (time.c)</li> <li>_settimeofday (time.c)</li> </ul>"},{"location":"ltapi/macros/","title":"Macros","text":""},{"location":"ltapi/macros/#a","title":"a","text":"<ul> <li>attachInterruptArg (LibreTuyaCompat.h)</li> </ul>"},{"location":"ltapi/macros/#b","title":"b","text":"<ul> <li>base64_decode_expected_len (cdecode.h)</li> <li>base64_encode_expected_len (cencode.h)</li> </ul>"},{"location":"ltapi/macros/#c","title":"c","text":"<ul> <li>CHIP_TYPE (ChipType.h)</li> <li>CHIP_TYPE_ENUM (ChipType.h)</li> <li>CONFIG_LWIP_MAX_ACTIVE_TCP (LibreTuyaCompat.h)</li> <li>COLOR_BLACK (lt_logger.c)</li> <li>COLOR_BLUE (lt_logger.c)</li> <li>COLOR_BRIGHT_BLACK (lt_logger.c)</li> <li>COLOR_BRIGHT_BLUE (lt_logger.c)</li> <li>COLOR_BRIGHT_CYAN (lt_logger.c)</li> <li>COLOR_BRIGHT_GREEN (lt_logger.c)</li> <li>COLOR_BRIGHT_MAGENTA (lt_logger.c)</li> <li>COLOR_BRIGHT_RED (lt_logger.c)</li> <li>COLOR_BRIGHT_WHITE (lt_logger.c)</li> <li>COLOR_BRIGHT_YELLOW (lt_logger.c)</li> <li>COLOR_CYAN (lt_logger.c)</li> <li>COLOR_FMT (lt_logger.c)</li> <li>COLOR_GREEN (lt_logger.c)</li> <li>COLOR_MAGENTA (lt_logger.c)</li> <li>COLOR_RED (lt_logger.c)</li> <li>COLOR_WHITE (lt_logger.c)</li> <li>COLOR_YELLOW (lt_logger.c)</li> <li>CONTENT_LENGTH_NOT_SET (WebServer.h)</li> <li>CONTENT_LENGTH_UNKNOWN (WebServer.h)</li> </ul>"},{"location":"ltapi/macros/#e","title":"e","text":"<ul> <li>EventId (Events.h)</li> <li>EventId_t (Events.h)</li> <li>EventInfo (Events.h)</li> <li>EventInfo_t (Events.h)</li> <li>Event_t (Events.h)</li> <li>ESP_FAIL (LibreTuyaCompat.h)</li> <li>ESP_OK (LibreTuyaCompat.h)</li> <li>esp_err_t (LibreTuyaCompat.h)</li> <li>ESP_EARLY_LOGD (lt_logger.h)</li> <li>ESP_EARLY_LOGE (lt_logger.h)</li> <li>ESP_EARLY_LOGI (lt_logger.h)</li> <li>ESP_EARLY_LOGV (lt_logger.h)</li> <li>ESP_EARLY_LOGW (lt_logger.h)</li> <li>ESP_LOGD (lt_logger.h)</li> <li>ESP_LOGE (lt_logger.h)</li> <li>ESP_LOGI (lt_logger.h)</li> <li>ESP_LOGV (lt_logger.h)</li> <li>ESP_LOGW (lt_logger.h)</li> <li>ETS_PRINTF (lt_logger.h)</li> <li>ets_printf (lt_logger.h)</li> <li>ENCRYPTED_BLOCK_SIZE (Update.h)</li> </ul>"},{"location":"ltapi/macros/#f","title":"f","text":"<ul> <li>FILE_APPEND (FS.h)</li> <li>FILE_READ (FS.h)</li> <li>FILE_WRITE (FS.h)</li> <li>FPSTR (LibreTuyaCompat.h)</li> <li>FAL_DEBUG (fal_cfg.h)</li> <li>FAL_DEV_NAME_MAX (fal_cfg.h)</li> <li>FAL_FLASH_DEV_NAME (fal_cfg.h)</li> <li>FAL_FLASH_DEV_TABLE (fal_cfg.h)</li> <li>FAL_PART_HAS_TABLE_CFG (fal_cfg.h)</li> <li>FAL_PART_TABLE_ITEM (fal_cfg.h)</li> <li>FAL_PRINTF (fal_cfg.h)</li> <li>FDB_PRINT (fdb_cfg.h)</li> <li>FDB_USING_FAL_MODE (fdb_cfg.h)</li> <li>FDB_USING_KVDB (fdb_cfg.h)</li> <li>FDB_WRITE_GRAN (fdb_cfg.h)</li> </ul>"},{"location":"ltapi/macros/#h","title":"h","text":"<ul> <li>HTTPCLIENT_1_1_COMPATIBLE (HTTPClient.h)</li> <li>HTTPCLIENT_DEFAULT_TCP_TIMEOUT (HTTPClient.h)</li> <li>HTTPC_ERROR_CONNECTION_LOST (HTTPClient.h)</li> <li>HTTPC_ERROR_CONNECTION_REFUSED (HTTPClient.h)</li> <li>HTTPC_ERROR_ENCODING (HTTPClient.h)</li> <li>HTTPC_ERROR_NOT_CONNECTED (HTTPClient.h)</li> <li>HTTPC_ERROR_NO_HTTP_SERVER (HTTPClient.h)</li> <li>HTTPC_ERROR_NO_STREAM (HTTPClient.h)</li> <li>HTTPC_ERROR_READ_TIMEOUT (HTTPClient.h)</li> <li>HTTPC_ERROR_SEND_HEADER_FAILED (HTTPClient.h)</li> <li>HTTPC_ERROR_SEND_PAYLOAD_FAILED (HTTPClient.h)</li> <li>HTTPC_ERROR_STREAM_WRITE (HTTPClient.h)</li> <li>HTTPC_ERROR_TOO_LESS_RAM (HTTPClient.h)</li> <li>HTTP_TCP_BUFFER_SIZE (HTTPClient.h)</li> <li>HTTP_ANY (HTTP_Method.h)</li> <li>HTTP_METHOD_MAP (HTTP_Method.h)</li> <li>HTTP_DOWNLOAD_UNIT_SIZE (WebServer.h)</li> <li>HTTP_MAX_CLOSE_WAIT (WebServer.h)</li> <li>HTTP_MAX_DATA_WAIT (WebServer.h)</li> <li>HTTP_MAX_POST_WAIT (WebServer.h)</li> <li>HTTP_MAX_SEND_WAIT (WebServer.h)</li> <li>HTTP_UPLOAD_BUFLEN (WebServer.h)</li> </ul>"},{"location":"ltapi/macros/#i","title":"i","text":"<ul> <li>isr_log_d (lt_logger.h)</li> <li>isr_log_e (lt_logger.h)</li> <li>isr_log_i (lt_logger.h)</li> <li>isr_log_n (lt_logger.h)</li> <li>isr_log_v (lt_logger.h)</li> <li>isr_log_w (lt_logger.h)</li> </ul>"},{"location":"ltapi/macros/#l","title":"l","text":"<ul> <li>LT_BANNER (LibreTuyaAPI.h)</li> <li>LT_BOARD (LibreTuyaAPI.h)</li> <li>LT_BOARD_STR (LibreTuyaAPI.h)</li> <li>LT_VERSION (LibreTuyaAPI.h)</li> <li>LT_VERSION_STR (LibreTuyaAPI.h)</li> <li>LT_AUTO_DOWNLOAD_REBOOT (LibreTuyaConfig.h)</li> <li>LT_DEBUG_ALL (LibreTuyaConfig.h)</li> <li>LT_DEBUG_CLIENT (LibreTuyaConfig.h)</li> <li>LT_DEBUG_FDB (LibreTuyaConfig.h)</li> <li>LT_DEBUG_LWIP (LibreTuyaConfig.h)</li> <li>LT_DEBUG_LWIP_ASSERT (LibreTuyaConfig.h)</li> <li>LT_DEBUG_MDNS (LibreTuyaConfig.h)</li> <li>LT_DEBUG_OTA (LibreTuyaConfig.h)</li> <li>LT_DEBUG_SERVER (LibreTuyaConfig.h)</li> <li>LT_DEBUG_SSL (LibreTuyaConfig.h)</li> <li>LT_DEBUG_WIFI (LibreTuyaConfig.h)</li> <li>LT_LEVEL_DEBUG (LibreTuyaConfig.h)</li> <li>LT_LEVEL_ERROR (LibreTuyaConfig.h)</li> <li>LT_LEVEL_FATAL (LibreTuyaConfig.h)</li> <li>LT_LEVEL_INFO (LibreTuyaConfig.h)</li> <li>LT_LEVEL_NONE (LibreTuyaConfig.h)</li> <li>LT_LEVEL_TRACE (LibreTuyaConfig.h)</li> <li>LT_LEVEL_VERBOSE (LibreTuyaConfig.h)</li> <li>LT_LEVEL_WARN (LibreTuyaConfig.h)</li> <li>LT_LOGGER (LibreTuyaConfig.h)</li> <li>LT_LOGGER_CALLER (LibreTuyaConfig.h)</li> <li>LT_LOGGER_COLOR (LibreTuyaConfig.h)</li> <li>LT_LOGGER_TASK (LibreTuyaConfig.h)</li> <li>LT_LOGGER_TIMESTAMP (LibreTuyaConfig.h)</li> <li>LT_LOGLEVEL (LibreTuyaConfig.h)</li> <li>LT_LOG_ERRNO (LibreTuyaConfig.h)</li> <li>LT_LOG_HEAP (LibreTuyaConfig.h)</li> <li>LT_MICROS_HIGH_RES (LibreTuyaConfig.h)</li> <li>LT_PRINTF_BROKEN (LibreTuyaConfig.h)</li> <li>LT_UART_DEFAULT_LOGGER (LibreTuyaConfig.h)</li> <li>LT_UART_DEFAULT_SERIAL (LibreTuyaConfig.h)</li> <li>LT_UART_SILENT_ALL (LibreTuyaConfig.h)</li> <li>LT_UART_SILENT_ENABLED (LibreTuyaConfig.h)</li> <li>LT_USE_TIME (LibreTuyaConfig.h)</li> <li>LT_D (lt_logger.h)</li> <li>LT_DM (lt_logger.h)</li> <li>LT_E (lt_logger.h)</li> <li>LT_EM (lt_logger.h)</li> <li>LT_ERRNO (lt_logger.h)</li> <li>LT_ERRNO_LEZ (lt_logger.h)</li> <li>LT_ERRNO_LZ (lt_logger.h)</li> <li>LT_ERRNO_NZ (lt_logger.h)</li> <li>LT_F (lt_logger.h)</li> <li>LT_FM (lt_logger.h)</li> <li>LT_HEAP_I (lt_logger.h)</li> <li>LT_I (lt_logger.h)</li> <li>LT_IM (lt_logger.h)</li> <li>LT_LOG (lt_logger.h)</li> <li>LT_LOGM (lt_logger.h)</li> <li>LT_RET (lt_logger.h)</li> <li>LT_RET_LEZ (lt_logger.h)</li> <li>LT_RET_LZ (lt_logger.h)</li> <li>LT_RET_NZ (lt_logger.h)</li> <li>LT_T (lt_logger.h)</li> <li>LT_TM (lt_logger.h)</li> <li>LT_V (lt_logger.h)</li> <li>LT_VM (lt_logger.h)</li> <li>LT_W (lt_logger.h)</li> <li>LT_WM (lt_logger.h)</li> <li>log_d (lt_logger.h)</li> <li>log_e (lt_logger.h)</li> <li>log_i (lt_logger.h)</li> <li>log_n (lt_logger.h)</li> <li>log_printf (lt_logger.h)</li> <li>log_v (lt_logger.h)</li> <li>log_w (lt_logger.h)</li> <li>LT_MD5_CTX_T (MD5.h, MD5HostapdImpl.h, MD5MbedTLSImpl.h, MD5PolarSSLImpl.h)</li> </ul>"},{"location":"ltapi/macros/#m","title":"m","text":"<ul> <li>MAX_PASSPHRASE_LEN (WiFiEvents.h)</li> <li>MAX_SSID_LEN (WiFiEvents.h)</li> <li>MAX_WPS_AP_CRED (WiFiEvents.h)</li> <li>MDNS_TCP (mDNS.h)</li> <li>MDNS_UDP (mDNS.h)</li> </ul>"},{"location":"ltapi/macros/#o","title":"o","text":"<ul> <li>OUTPUT_OPEN_DRAIN (LibreTuyaCompat.h)</li> </ul>"},{"location":"ltapi/macros/#p","title":"p","text":"<ul> <li>PGM_VOID_P (LibreTuyaCompat.h)</li> <li>PIN_ADC (LibreTuyaCustom.h)</li> <li>PIN_DAC (LibreTuyaCustom.h)</li> <li>PIN_GPIO (LibreTuyaCustom.h)</li> <li>PIN_I2C (LibreTuyaCustom.h)</li> <li>PIN_I2S (LibreTuyaCustom.h)</li> <li>PIN_IRQ (LibreTuyaCustom.h)</li> <li>PIN_JTAG (LibreTuyaCustom.h)</li> <li>PIN_NONE (LibreTuyaCustom.h)</li> <li>PIN_PWM (LibreTuyaCustom.h)</li> <li>PIN_SPI (LibreTuyaCustom.h)</li> <li>PIN_SWD (LibreTuyaCustom.h)</li> <li>PIN_UART (LibreTuyaCustom.h)</li> <li>PRINTF_HAS_DISABLE (printf_config.h)</li> <li>printf_ (printf_config.h)</li> </ul>"},{"location":"ltapi/macros/#s","title":"s","text":"<ul> <li>STRINGIFY (LibreTuyaAPI.h)</li> <li>STRINGIFY_MACRO (LibreTuyaAPI.h)</li> <li>snprintf_ (printf_config.h)</li> <li>sprintf_ (printf_config.h)</li> </ul>"},{"location":"ltapi/macros/#u","title":"u","text":"<ul> <li>UPDATE_ERROR_ABORT (Update.h)</li> <li>UPDATE_ERROR_ACTIVATE (Update.h)</li> <li>UPDATE_ERROR_BAD_ARGUMENT (Update.h)</li> <li>UPDATE_ERROR_ERASE (Update.h)</li> <li>UPDATE_ERROR_MAGIC_BYTE (Update.h)</li> <li>UPDATE_ERROR_MD5 (Update.h)</li> <li>UPDATE_ERROR_NO_PARTITION (Update.h)</li> <li>UPDATE_ERROR_OK (Update.h)</li> <li>UPDATE_ERROR_READ (Update.h)</li> <li>UPDATE_ERROR_SIZE (Update.h)</li> <li>UPDATE_ERROR_SPACE (Update.h)</li> <li>UPDATE_ERROR_STREAM (Update.h)</li> <li>UPDATE_ERROR_WRITE (Update.h)</li> <li>UPDATE_SIZE_UNKNOWN (Update.h)</li> <li>UPDATE_TIMEOUT_MS (Update.h)</li> <li>U_AUTH (Update.h)</li> <li>U_FLASH (Update.h)</li> <li>U_SPIFFS (Update.h)</li> </ul>"},{"location":"ltapi/macros/#v","title":"v","text":"<ul> <li>voidFuncPtrArg (LibreTuyaCompat.h)</li> <li>vsnprintf_P (LibreTuyaCompat.h)</li> <li>vprintf_ (printf_config.h)</li> <li>vsnprintf_ (printf_config.h)</li> <li>vsprintf_ (printf_config.h)</li> </ul>"},{"location":"ltapi/macros/#w","title":"w","text":"<ul> <li>WIFI_STATIS_ALL (WiFiEvents.h)</li> <li>WIFI_STATIS_BUFFER (WiFiEvents.h)</li> <li>WIFI_STATIS_DIAG (WiFiEvents.h)</li> <li>WIFI_STATIS_HW (WiFiEvents.h)</li> <li>WIFI_STATIS_PS (WiFiEvents.h)</li> <li>WIFI_STATIS_RXTX (WiFiEvents.h)</li> <li>WIFI_AP (WiFiType.h)</li> <li>WIFI_AP_STA (WiFiType.h)</li> <li>WIFI_OFF (WiFiType.h)</li> <li>WIFI_SCAN_FAILED (WiFiType.h)</li> <li>WIFI_SCAN_RUNNING (WiFiType.h)</li> <li>WIFI_STA (WiFiType.h)</li> <li>WiFiAuthMode (WiFiType.h)</li> <li>WiFiEventId_t (WiFiType.h)</li> <li>WiFiEventInfo_t (WiFiType.h)</li> <li>WiFiEvent_t (WiFiType.h)</li> <li>WiFiMode (WiFiType.h)</li> <li>WiFiMode_t (WiFiType.h)</li> <li>WiFiStatus (WiFiType.h)</li> <li>WRAP_DISABLE_CHECK (printf_config.h)</li> <li>WRAP_DISABLE_DECL (printf_config.h)</li> <li>WRAP_DISABLE_DEF (printf_config.h)</li> <li>WRAP_PRINTF (printf_config.h)</li> <li>WRAP_SNPRINTF (printf_config.h)</li> <li>WRAP_SPRINTF (printf_config.h)</li> <li>WRAP_VPRINTF (printf_config.h)</li> <li>WRAP_VSNPRINTF (printf_config.h)</li> <li>WRAP_VSPRINTF (printf_config.h)</li> </ul>"},{"location":"ltapi/macros/#x","title":"x","text":"<ul> <li>XX (HTTP_Method.h)</li> </ul>"},{"location":"ltapi/variables/","title":"Variables","text":""},{"location":"ltapi/variables/#a","title":"a","text":"<ul> <li>arduino_event_id_t (Events.h)</li> </ul>"},{"location":"ltapi/variables/#b","title":"b","text":"<ul> <li>base64_decodestep (cdecode.h)</li> <li>base64_encodestep (cencode.h)</li> </ul>"},{"location":"ltapi/variables/#c","title":"c","text":"<ul> <li>ChipFamily (ChipType.h)</li> <li>ChipType (ChipType.h)</li> <li>CookieJar (HTTPClient.h)</li> <li>charmap (strcasecmp.c)</li> </ul>"},{"location":"ltapi/variables/#d","title":"d","text":"<ul> <li>deviceName (LibreTuyaClass.cpp)</li> </ul>"},{"location":"ltapi/variables/#e","title":"e","text":"<ul> <li>EventCb (Events.h)</li> <li>EventFuncCb (Events.h)</li> <li>EventHandler (Events.h)</li> <li>EventSysCb (Events.h)</li> <li>esp_ip4_addr_t (WiFiType.h)</li> <li>esp_ip6_addr_t (WiFiType.h)</li> <li>ESP (LibreTuyaClass.h)</li> <li>errorMap (UpdateUtil.cpp)</li> <li>errorStr (UpdateUtil.cpp)</li> </ul>"},{"location":"ltapi/variables/#f","title":"f","text":"<ul> <li>fal_root_part (main.cpp, fal_cfg.h)</li> <li>Flash (Flash.cpp, Flash.h)</li> <li>followRedirects_t (HTTPClient.h)</li> <li>flash0 (fal_cfg.h)</li> </ul>"},{"location":"ltapi/variables/#h","title":"h","text":"<ul> <li>HTTPMethod (HTTP_Method.h)</li> <li>http_method (HTTP_Method.h)</li> <li>HTTPAuthMethod (WebServer.h)</li> <li>HTTPClientStatus (WebServer.h)</li> <li>HTTPUploadStatus (WebServer.h)</li> </ul>"},{"location":"ltapi/variables/#l","title":"l","text":"<ul> <li>LT (LibreTuyaClass.h)</li> <li>levels (lt_logger.c)</li> </ul>"},{"location":"ltapi/variables/#m","title":"m","text":"<ul> <li>md5_context_t (MD5.h)</li> <li>MDNS (mDNS.h)</li> <li>MDNSResponder (mDNS.h)</li> </ul>"},{"location":"ltapi/variables/#p","title":"p","text":"<ul> <li>PreferenceType (Preferences.h)</li> <li>pWiFi (WiFi.cpp, WiFi.h)</li> <li>pinTable (LibreTuyaCustom.h)</li> <li>periodicTasks (main.cpp)</li> </ul>"},{"location":"ltapi/variables/#r","title":"r","text":"<ul> <li>ResetReason (LibreTuyaClass.h)</li> <li>reset_epoch (time.c)</li> <li>reset_millis (time.c)</li> </ul>"},{"location":"ltapi/variables/#t","title":"t","text":"<ul> <li>TransportTraitsPtr (HTTPClient.h)</li> <li>t_http_codes (HTTPClient.h)</li> <li>transferEncoding_t (HTTPClient.h)</li> </ul>"},{"location":"ltapi/variables/#u","title":"u","text":"<ul> <li>uart_port (lt_logger.c)</li> <li>Update (Update.cpp, Update.h)</li> <li>u_char (strcasecmp.c)</li> </ul>"},{"location":"ltapi/variables/#w","title":"w","text":"<ul> <li>WiFi (WiFi.cpp, WiFi.h)</li> <li>wifi_event_sta_wps_fail_reason_t (WiFiEvents.h)</li> <li>wifi_ftm_status_t (WiFiEvents.h)</li> <li>WiFiModeAction (WiFiType.h)</li> <li>wifi_auth_mode_t (WiFiType.h)</li> <li>wifi_err_reason_t (WiFiType.h)</li> <li>wifi_mode_t (WiFiType.h)</li> <li>wl_status_t (WiFiType.h)</li> </ul>"},{"location":"ltapi/variables/#_","title":"_","text":"<ul> <li>_analogReadResolution (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>_analogWritePeriod (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> <li>_analogWriteResolution (LibreTuyaCustom.c, LibreTuyaCustom.h)</li> </ul>"},{"location":"ltapi/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List<ul> <li>struct Cookie</li> <li>struct EventHandler_s</li> <li>class FlashClass</li> <li>struct FlashId</li> <li>class FunctionRequestHandler</li> <li>class HTTPClient</li> <li>struct HTTPClient::RequestArgument</li> <li>struct HTTPUpload</li> <li>class IPreferences</li> <li>class ITwoWire</li> <li>class IWiFiClient</li> <li>class IWiFiClientSecure</li> <li>class IWiFiServer</li> <li>class IWiFiUDP</li> <li>class LibreTuya</li> <li>class LwIPClient</li> <li>class LwIPRxBuffer</li> <li>class LwIPServer</li> <li>class LwIPUDP</li> <li>class MbedTLSClient</li> <li>struct PinInfo</li> <li>class RequestHandler</li> <li>class StaticRequestHandler</li> <li>class StreamString</li> <li>class UpdateClass</li> <li>class Uri</li> <li>class UriBraces</li> <li>class UriGlob</li> <li>class UriRegex</li> <li>class WebServer</li> <li>struct WebServer::RequestArgument</li> <li>class WiFiClass</li> <li>struct WiFiMacAddr</li> <li>class WiFiMulti</li> <li>struct WiFiScanAP</li> <li>struct WiFiScanData</li> <li>struct WifiAPlist_t</li> <li>namespace arduino</li> <li>class arduino::IPv6Address</li> <li>union arduino_event_info_t</li> <li>struct arduino_event_t</li> <li>class base64</li> <li>struct base64_decodestate</li> <li>struct base64_encodestate</li> <li>class cbuf</li> <li>struct esp_ip4_addr</li> <li>struct esp_ip6_addr</li> <li>struct esp_netif_ip6_info_t</li> <li>struct esp_netif_ip_info_t</li> <li>namespace fs</li> <li>class fs::FS</li> <li>class fs::FSImpl</li> <li>class fs::File</li> <li>class fs::FileImpl</li> <li>struct ip_event_ap_staipassigned_t</li> <li>struct ip_event_got_ip6_t</li> <li>struct ip_event_got_ip_t</li> <li>class mDNS</li> <li>namespace mime</li> <li>struct mime::Entry</li> <li>struct wifi_event_action_tx_status_t</li> <li>struct wifi_event_ap_probe_req_rx_t</li> <li>struct wifi_event_ap_staconnected_t</li> <li>struct wifi_event_ap_stadisconnected_t</li> <li>struct wifi_event_ftm_report_t</li> <li>struct wifi_event_roc_done_t</li> <li>struct wifi_event_sta_authmode_change_t</li> <li>struct wifi_event_sta_connected_t</li> <li>struct wifi_event_sta_disconnected_t</li> <li>struct wifi_event_sta_scan_done_t</li> <li>struct wifi_event_sta_wps_er_pin_t</li> <li>struct wifi_event_sta_wps_er_success_t</li> <li>struct wifi_ftm_report_entry_t</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>arduino</li> <li>arduino/libretuya<ul> <li>arduino/libretuya/api</li> <li>Events.cpp</li> <li>Events.cpp source</li> <li>Events.h</li> <li>Events.h source</li> <li>FS.cpp</li> <li>FS.cpp source</li> <li>FS.h</li> <li>FS.h source</li> <li>Preferences.h</li> <li>Preferences.h source</li> <li>SoftwareSerial.cpp</li> <li>SoftwareSerial.cpp source</li> <li>SoftwareSerial.h</li> <li>SoftwareSerial.h source</li> <li>WiFiClient.h</li> <li>WiFiClient.h source</li> <li>WiFiClientSecure.h</li> <li>WiFiClientSecure.h source</li> <li>WiFiServer.h</li> <li>WiFiServer.h source</li> <li>WiFiUdp.h</li> <li>WiFiUdp.h source</li> <li>Wire.h</li> <li>Wire.h source</li> <li>arduino/libretuya/api/WiFi<ul> <li>WiFi.cpp</li> <li>WiFi.cpp source</li> <li>WiFi.h</li> <li>WiFi.h source</li> <li>WiFiAP.cpp</li> <li>WiFiAP.cpp source</li> <li>WiFiEvents.cpp</li> <li>WiFiEvents.cpp source</li> <li>WiFiEvents.h</li> <li>WiFiEvents.h source</li> <li>WiFiGeneric.cpp</li> <li>WiFiGeneric.cpp source</li> <li>WiFiSTA.cpp</li> <li>WiFiSTA.cpp source</li> <li>WiFiScan.cpp</li> <li>WiFiScan.cpp source</li> <li>WiFiType.h</li> <li>WiFiType.h source</li> </ul> </li> <li>arduino/libretuya/common</li> <li>WMath.cpp</li> <li>WMath.cpp source</li> <li>abi.cpp</li> <li>abi.cpp source</li> <li>dtostrf.c</li> <li>dtostrf.c source</li> <li>hooks.c</li> <li>hooks.c source</li> <li>itoa.c</li> <li>itoa.c source</li> <li>serial_event.cpp</li> <li>serial_event.cpp source</li> <li>wiring_shift.c</li> <li>wiring_shift.c source</li> <li>arduino/libretuya/compat</li> <li>FS.h</li> <li>FS.h source</li> <li>FSImpl.h</li> <li>FSImpl.h source</li> <li>WiFiAP.h</li> <li>WiFiAP.h source</li> <li>md5.h</li> <li>md5.h source</li> <li>pgmspace.h</li> <li>pgmspace.h source</li> <li>vfs_api.h</li> <li>vfs_api.h source</li> <li>arduino/libretuya/core</li> <li>ChipType.h</li> <li>ChipType.h source</li> <li>LibreTuyaAPI.cpp</li> <li>LibreTuyaAPI.cpp source</li> <li>LibreTuyaAPI.h</li> <li>LibreTuyaAPI.h source</li> <li>LibreTuyaClass.cpp</li> <li>LibreTuyaClass.cpp source</li> <li>LibreTuyaClass.h</li> <li>LibreTuyaClass.h source</li> <li>LibreTuyaCompat.cpp</li> <li>LibreTuyaCompat.cpp source</li> <li>LibreTuyaCompat.h</li> <li>LibreTuyaCompat.h source</li> <li>LibreTuyaConfig.h</li> <li>LibreTuyaConfig.h source</li> <li>LibreTuyaCustom.c</li> <li>LibreTuyaCustom.c source</li> <li>LibreTuyaCustom.h</li> <li>LibreTuyaCustom.h source</li> <li>SerialExtern.h</li> <li>SerialExtern.h source</li> <li>lt_logger.c</li> <li>lt_logger.c source</li> <li>lt_logger.h</li> <li>lt_logger.h source</li> <li>main.cpp</li> <li>main.cpp source</li> <li>arduino/libretuya/libraries</li> <li>arduino/libretuya/libraries/Flash<ul> <li>Flash.cpp</li> <li>Flash.cpp source</li> <li>Flash.h</li> <li>Flash.h source</li> </ul> </li> <li>arduino/libretuya/libraries/HTTPClient<ul> <li>HTTPClient.cpp</li> <li>HTTPClient.cpp source</li> <li>HTTPClient.h</li> <li>HTTPClient.h source</li> <li>arduino/libretuya/libraries/HTTPClient/strptime</li> <li>strptime.c</li> <li>strptime.c source</li> <li>strptime.h</li> <li>strptime.h source</li> </ul> </li> <li>arduino/libretuya/libraries/MD5<ul> <li>MD5.h</li> <li>MD5.h source</li> <li>MD5HostapdImpl.h</li> <li>MD5HostapdImpl.h source</li> <li>MD5MbedTLSImpl.cpp</li> <li>MD5MbedTLSImpl.cpp source</li> <li>MD5MbedTLSImpl.h</li> <li>MD5MbedTLSImpl.h source</li> <li>MD5PolarSSLImpl.cpp</li> <li>MD5PolarSSLImpl.cpp source</li> <li>MD5PolarSSLImpl.h</li> <li>MD5PolarSSLImpl.h source</li> </ul> </li> <li>arduino/libretuya/libraries/NetUtils<ul> <li>IPv6Address.cpp</li> <li>IPv6Address.cpp source</li> <li>IPv6Address.h</li> <li>IPv6Address.h source</li> <li>arduino/libretuya/libraries/NetUtils/api</li> <li>IPv6Address.h</li> <li>IPv6Address.h source</li> <li>arduino/libretuya/libraries/NetUtils/lwip</li> <li>LwIPClient.cpp</li> <li>LwIPClient.cpp source</li> <li>LwIPClient.h</li> <li>LwIPClient.h source</li> <li>LwIPRxBuffer.cpp</li> <li>LwIPRxBuffer.cpp source</li> <li>LwIPRxBuffer.h</li> <li>LwIPRxBuffer.h source</li> <li>LwIPServer.cpp</li> <li>LwIPServer.cpp source</li> <li>LwIPServer.h</li> <li>LwIPServer.h source</li> <li>LwIPUdp.cpp</li> <li>LwIPUdp.cpp source</li> <li>LwIPUdp.h</li> <li>LwIPUdp.h source</li> <li>arduino/libretuya/libraries/NetUtils/ssl</li> <li>MbedTLSClient.cpp</li> <li>MbedTLSClient.cpp source</li> <li>MbedTLSClient.h</li> <li>MbedTLSClient.h source</li> </ul> </li> <li>arduino/libretuya/libraries/StreamString<ul> <li>StreamString.cpp</li> <li>StreamString.cpp source</li> <li>StreamString.h</li> <li>StreamString.h source</li> </ul> </li> <li>arduino/libretuya/libraries/Update<ul> <li>Update.cpp</li> <li>Update.cpp source</li> <li>Update.h</li> <li>Update.h source</li> <li>UpdateUtil.cpp</li> <li>UpdateUtil.cpp source</li> </ul> </li> <li>arduino/libretuya/libraries/WebServer<ul> <li>HTTP_Method.h</li> <li>HTTP_Method.h source</li> <li>Parsing.cpp</li> <li>Parsing.cpp source</li> <li>Uri.h</li> <li>Uri.h source</li> <li>WebServer.cpp</li> <li>WebServer.cpp source</li> <li>WebServer.h</li> <li>WebServer.h source</li> <li>arduino/libretuya/libraries/WebServer/detail</li> <li>RequestHandler.h</li> <li>RequestHandler.h source</li> <li>RequestHandlersImpl.h</li> <li>RequestHandlersImpl.h source</li> <li>mimetable.cpp</li> <li>mimetable.cpp source</li> <li>mimetable.h</li> <li>mimetable.h source</li> <li>arduino/libretuya/libraries/WebServer/uri</li> <li>UriBraces.h</li> <li>UriBraces.h source</li> <li>UriGlob.h</li> <li>UriGlob.h source</li> <li>UriRegex.h</li> <li>UriRegex.h source</li> </ul> </li> <li>arduino/libretuya/libraries/WiFiMulti<ul> <li>WiFiMulti.cpp</li> <li>WiFiMulti.cpp source</li> <li>WiFiMulti.h</li> <li>WiFiMulti.h source</li> </ul> </li> <li>arduino/libretuya/libraries/base64<ul> <li>arduino/libretuya/libraries/base64/libb64</li> <li>cdecode.c</li> <li>cdecode.c source</li> <li>cdecode.h</li> <li>cdecode.h source</li> <li>cencode.c</li> <li>cencode.c source</li> <li>cencode.h</li> <li>cencode.h source</li> <li>base64.cpp</li> <li>base64.cpp source</li> <li>base64.h</li> <li>base64.h source</li> </ul> </li> <li>arduino/libretuya/libraries/cbuf<ul> <li>cbuf.cpp</li> <li>cbuf.cpp source</li> <li>cbuf.h</li> <li>cbuf.h source</li> </ul> </li> <li>arduino/libretuya/libraries/mDNS<ul> <li>ESPmDNS.h</li> <li>ESPmDNS.h source</li> <li>LwIPmDNS.cpp</li> <li>LwIPmDNS.cpp source</li> <li>mDNS.cpp</li> <li>mDNS.cpp source</li> <li>mDNS.h</li> <li>mDNS.h source</li> </ul> </li> <li>arduino/libretuya/port</li> <li>arduino/libretuya/port/flashdb<ul> <li>fal_cfg.h</li> <li>fal_cfg.h source</li> <li>fdb_cfg.h</li> <li>fdb_cfg.h source</li> </ul> </li> <li>arduino/libretuya/port/printf<ul> <li>printf_config.h</li> <li>printf_config.h source</li> <li>putchar.c</li> <li>putchar.c source</li> <li>puts.c</li> <li>puts.c source</li> </ul> </li> <li>arduino/libretuya/posix</li> <li>lt_posix_api.h</li> <li>lt_posix_api.h source</li> <li>strcasecmp.c</li> <li>strcasecmp.c source</li> <li>strdup.c</li> <li>strdup.c source</li> <li>time.c</li> <li>time.c source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}